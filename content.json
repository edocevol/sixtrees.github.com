{"meta":{"title":"shugenniu's blogger","subtitle":null,"description":"shugen使用hexo搭建的个人博客","author":"sixtrees","url":"http://www.wanqing520.cn"},"pages":[{"title":"","date":"2018-05-22T13:32:11.193Z","updated":"2018-05-22T13:32:11.183Z","comments":false,"path":"tags/index.html","permalink":"http://www.wanqing520.cn/tags/index.html","excerpt":"","text":""},{"title":"","date":"2018-05-22T13:32:16.779Z","updated":"2018-05-22T13:32:16.769Z","comments":false,"path":"categories/index.html","permalink":"http://www.wanqing520.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"乐享开发指南","slug":"杂谈/乐享开发指南","date":"2018-05-22T14:11:28.426Z","updated":"2018-05-22T14:25:51.490Z","comments":true,"path":"201805/22/杂谈/乐享开发指南.html","link":"","permalink":"http://www.wanqing520.cn/201805/22/杂谈/乐享开发指南.html","excerpt":"","text":"拷贝集成环境找乐享开发组同事拷贝虚拟机镜像， 导入到虚拟机中。 拷贝镜像","categories":[],"tags":[{"name":"更新说明","slug":"更新说明","permalink":"http://www.wanqing520.cn/tags/更新说明/"},{"name":"小书匠","slug":"小书匠","permalink":"http://www.wanqing520.cn/tags/小书匠/"}]},{"title":"blog-migration","slug":"blog-migration","date":"2018-05-22T13:26:53.000Z","updated":"2018-05-22T13:35:40.840Z","comments":true,"path":"201805/22/blog-migration.html","link":"","permalink":"http://www.wanqing520.cn/201805/22/blog-migration.html","excerpt":"","text":"","categories":[],"tags":[{"name":"你好;博客迁移;hexo","slug":"你好-博客迁移-hexo","permalink":"http://www.wanqing520.cn/tags/你好-博客迁移-hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-05-22T13:15:39.091Z","updated":"2018-05-22T13:34:56.308Z","comments":true,"path":"201805/22/hello-world.html","link":"","permalink":"http://www.wanqing520.cn/201805/22/hello-world.html","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"你好","slug":"你好","permalink":"http://www.wanqing520.cn/tags/你好/"}]},{"title":"nodejs下利用parallel从redis中pop多个数据","slug":"fontend/nodejs/nodejs-redis-popall","date":"2018-04-23T08:45:41.000Z","updated":"2018-05-24T06:04:19.770Z","comments":true,"path":"201804/23/fontend/nodejs/nodejs-redis-popall.html","link":"","permalink":"http://www.wanqing520.cn/201804/23/fontend/nodejs/nodejs-redis-popall.html","excerpt":"","text":"场景描述 redis nodejs的api没有提供pop多个元素的指令 redis的smember函数没有办法移除要pop出去的元素，且高并发下可能存在问题 使用 async.parallel来实现多个任务并列执行，最终可以一次性得到所有结果 避免了nodejs异步编程中无法实现for循环+异步的问题 123456789101112131415161718192021222324252627282930313233343536router.post('/pictures_list', function (req, res, next) &#123; var app_id = req.body.app_id; # 获取redis的key client.scard(app_id, function (error, data) &#123; if (error) &#123; res.setHeader('Content-Type', 'text/json'); res.json(JSON.stringify(&#123;'url': datas&#125;)) &#125; else &#123; //得到redis中appid对应的Set集合中的元素数量，将其全部pop出来 var tasks = create_task(data, app_id); // 创建num个pop任务，将num个任务parallel执行，result中的结果是 //num个pop任务得到的结果 async.parallel(tasks, function (error, result) &#123; res.setHeader('Content-Type', 'text/json'); res.json(JSON.stringify(&#123;'url': result&#125;)); &#125;); &#125; &#125;);&#125;);/*** count是要pop出来的数量* app_id是redis的Set的key*/function create_task(count, app_id) &#123; var tasks = []; for (var i = 0; i &lt; count; i++) &#123; tasks[i] = function (num) &#123; return function (callback) &#123; client.spop(app_id, function (error, datas) &#123; callback(null, datas); &#125;); &#125; &#125;(i); &#125; return tasks;&#125;","categories":[{"name":"frontend","slug":"frontend","permalink":"http://www.wanqing520.cn/categories/frontend/"}],"tags":[]},{"title":"java爬取80s电影网站的视频信息","slug":"java/2016-10-31-use-java-spide-80movies-information","date":"2016-10-30T16:58:14.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201610/31/java/2016-10-31-use-java-spide-80movies-information.html","link":"","permalink":"http://www.wanqing520.cn/201610/31/java/2016-10-31-use-java-spide-80movies-information.html","excerpt":"","text":"链接https://git.oschina.net/jsper/MovieDownload.git 项目参考链接 jsoup的使用 maven依赖查找 使用httpclient获取相应字符串 网页分析我们使用正在播出的电视剧《暗战危城》的页面来说明如何获取页面信息如下图所示，在浏览器的开发者工具中，我们审查《暗战危城》页面的元素的时候，可以看到其head标签中含有大量的meta元素，我们只要能够提出出meta的信息就可以获取到电视剧的剧名、简介、海报等信息。 在这里输入图片标题 如下图所示，页面中还包含了最近更新：,更新周期：,演员：等信息。 在这里输入图片标题 下图红色箭头的部分都是可以点击，调用浏览器或者迅雷进行下载的UI按钮。 在这里输入图片标题 审查上面图中的第18集的所在的li的元素，截图如下 在这里输入图片标题 可以看到，只要我们根据li提取出第一个span标签下的input标签和后面两个span标签的a标签就可以获取到http下载路径和迅雷下载路径 关于多线程的使用1234567ExecutorService pool = Executors.newFixedThreadPool(100);Runnable runnable = () -&gt; &#123; //线程要进行的操作&#125;;//线程池调度线程pool.execute(runnable); 上面的代码创建了一个大小为100的线程池，线程池自动调用线程，并维持线程的声明周期。 项目对应的POM123456789101112&lt;!-- https://mvnrepository.com/artifact/org.jsoup/jsoup --&gt;&lt;dependency&gt; &lt;groupId&gt;org.jsoup&lt;/groupId&gt; &lt;artifactId&gt;jsoup&lt;/artifactId&gt; &lt;version&gt;1.10.1&lt;/version&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient --&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.2&lt;/version&gt;&lt;/dependency&gt; 程序运行结果爬取电视剧页面 在这里输入图片标题 爬取电影页面 在这里输入图片标题","categories":[{"name":"java","slug":"java","permalink":"http://www.wanqing520.cn/categories/java/"}],"tags":[]},{"title":"博客由github迁移到gitosc","slug":"git/2016-10-17-migration_gitpages_to_giteepages","date":"2016-10-17T09:47:00.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201610/17/git/2016-10-17-migration_gitpages_to_giteepages.html","link":"","permalink":"http://www.wanqing520.cn/201610/17/git/2016-10-17-migration_gitpages_to_giteepages.html","excerpt":"","text":"在git.oschina.net上新建项目如下图所示，创建一个项目，项目名为自己的开源中国的个性域名的名字（我的是jsper）,我这里的项目已经存在了 在这里输入图片标题 从空的项目拉取到本地123456Administrator@XB-201606171743 MINGW64 /d/牛中超个人文件/nodejs/gitpages/backup$ pwd/d/牛中超个人文件/nodejs/gitpages/backupAdministrator@XB-201606171743 MINGW64 /d/牛中超个人文件/nodejs/gitpages/backup$ git clone https://git.oschina.net/jsper/jsper.git 拷贝文件文件将github的https://github.com/sixtrees/sixtrees.github.com.git项目拷贝到本地 在这里输入图片标题 复制除.git文件夹外的所有内容，到刚才从OSC GIT上拷贝下来的空项目目录中 在这里输入图片标题 修改_config.yml修改_config.yml要做的工作很少，项目在github上能够很好的运行的话，这里只需要添加一项配置 1gems: [jekyll-paginate] 提交代码add1git add . commit1git commit -m \"迁移\" push1git push #开启pages如下图所示，在项目主页，选择Pages选项卡， 在这里输入图片标题 如下图所示，这里可以选择master分支，方便提交 在这里输入图片标题 点击启动按钮，最后的内容如下： 在这里输入图片标题 访问http://jsper.oschina.io 在这里输入图片标题 几点说明 如果想使用http://username.oschina.io/来访问自己的博客，那个项目名就必须是自己username _config.yml必须添加gems: [jekyll-paginate]配置，否则将找不到_post文件夹下的md文章 pages采用jekyll支持，想了解更多内容，看这里：jekyll中文站点 致谢感谢开源中国的开源精神，想迁移博客到osc上的目的，就是osc的md文件可以直接复制图片，不需要考虑图片的上传问题，很方便有木有。在博客的迁移过程中，非常感谢 温家成 （http://git.oschina.net/wenjiachengy）的帮助。下面是issue的路径http://git.oschina.net/oschina/git-osc/issues/5277#note_483947","categories":[{"name":"git","slug":"git","permalink":"http://www.wanqing520.cn/categories/git/"}],"tags":[]},{"title":"Java FAQ","slug":"java/2016-10-15-some-java-problems","date":"2016-10-15T03:46:00.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201610/15/java/2016-10-15-some-java-problems.html","link":"","permalink":"http://www.wanqing520.cn/201610/15/java/2016-10-15-some-java-problems.html","excerpt":"","text":"1.String、StringBuffer 和 StringBuilder 的区别：String：不可变字符串； String 字符串的 + 法实际是生成了新的 String 对象，如果频繁滴有 + 操作，那么效率可能会很差；StringBuffer：线程安全的可变字符串； 使用 append 来进行连接 + 操作， 如果频繁有字符串 + 操作，应该采用；StringBuilder：非线程安全的可变字符串；如果频繁有字符串 +，那么可以采用，效率比 StringBuffer 会高那么一点，但注意是非线程安全的；String.intern()方法： 将字符串对应值放到常量区。 2. 将构造函数声明为 private 有哪些用途 ？类外不能直接构造对象(实例化这个类)，如果要获取对象那么只有通过 static 的 public 方法，单例模式和工厂模式常如此用；该类不能继承。 3. try-catch-finally 的 try 块中如果有 return 语句， finally 块是否还会执行？会。 finally 语句会在 return 之前执行，但是会在 return expression 的 expression 求值之后。 随之一个问题：try 块中 return 1 而 finally 块中 return 2 ，那么函数是返回 1 还是 2 呢？ —— 答案是 2 。这也说明，如果 try/catch 块中 throw Exception ，而 finally 中 return 值，那么异常也不会真 throw 到外层。 4. 在哪些情况下 try-catch-finally 结构中的 finally 语句块不会执行？如果虚拟机在 try/catch 语句块执行期间退出；除了 power off 或是 reset 这些外部不可抗拒的因素外，System.exit(1) 也会造成 JVM 异常退出，这时候 finally 块可能还来不及执行；如果执行 try/catch 语句块的线程被杀死终止了。 5. final、finally 和 finalize 的使用场景 ？final 用在不同的地方含义也不同： 修饰变量，表明变量初始化之后不可修改，也就是不能重新赋值；如果 final 来修饰对象，只表明不能重新赋值，但可以修改对象的值；修饰方法，表明方法不能重写；修饰类，表明类不能继承；final 和 abstract 不能同时修饰一个类，因为前者说明不能继承，后者则必须继承才能实例化；finally 是 try-catch-finally 块的一部分， 可选。 try/catch 块执行之后一定会执行的一部分，一般用于资源回收或是垃圾清理。 (当然在某些极端情况下， finally 不会执行。) finalize() 方法： 当 gc 要回收一个对象之前会执行 finalize() 方法。 6. Java 泛型 和 c++ 泛型的区别。最核心区别： c++ 中泛型中的类型是泛型类的一部分， java 中不是。 7. java 的 major.minor 版本运行java程序有时候会遇到的一个问题：Exception in thread “main” java.lang.UnsupportedClassVersionError: org/apache/catalina/util/ServerInfo : Unsupported major.minor version 51.0 ，这说明当前的 JRE 版本和 class 要求的版本不一致， 51.0 表明需要 JRE7。 Java major.minor 会存在字节码中，具体 major 版本对应的 JDK： J2SE 8 = 52J2SE 7 = 51J2SE 6.0 = 50J2SE 5.0 = 49JDK 1.4 = 48JDK 1.3 = 47JDK 1.2 = 46JDK 1.1 = 45 8. JRE 的 rt.jar 中包的结构，或是有哪些包？rt.jar 有 java., javax., com., org., sun., sunw. 六个包，其中前四个为 public 包，api 一般保持兼容； 后两个为非 public 包，不同系统上的实现可能不同，也不保证兼容性。 9. switch() 可以跟的类型有哪些？jdk7 之前只能支持 char, byte, short, int 四种整型， jdk7 开始支持 String 类型。long 是不支持的呀！ 10. == 和 equals() 的区别？== 用来比较相等，可以用于基本类型和引用类型；equals() 是对象(引用)来比较相等。 == 用于对象的时候，比较的是“是否引用的同一个对象”，而非“内容是否相等”； equals() 往往是比较“内容是否相等”。需要注意的是 String 和 Long(包括 Integer 等)： String s1=”hello”, s2=”hello”, s3=new String(“hello”), s4=new String(“hello”) ： s1 == s2 true，其他 == 比较都是 false 。 任意一个 equals() 比较都是 true ！Integer i = 10; Long l = 10L; i == l 和 i.equls(l) 都是 false，后者是因为 Integer/Long.equals() 首先比较类型是否相同其次比较 value 是否 == ！ 11. Object 类以及常用方法？Object 是 Java 中所有类的祖先类：一个类要么直接继承要么间接继承自 Object。一个类如果没有显式地继承一个类，那么默认 extends Object 。 Object 的几个方法： toString()，equals()，hashCode()，以及 getClass()，clone() 和finalize()。另外几个用于线程类： wait() 、notify() 和 notifyAll() 。 toString() ： 对象字符串化的格式， 除了直接调用之外，在字符串拼接 + ，或是 print 的时候会调用之；equals()： 定制对象相等比较的逻辑，集合类的 contains() 方法会调用之；hashCode() ： 哈希值，一个 int 值； (同一个进程中)同一个对象的 hashCode() 相等， equals() 相等的对象的 hashCode() 也应该相等，除此之外可以相等也可以不相等；getClass() ： 获取类对应的 Class&lt;?&gt; 类对象；clone() ： 拷贝逻辑；finalize() ： gc 之前的处理逻辑； 12. 换行符是神马？跟换行符有关的两个字符\\r (CR: carriage return) 和 \\n (LF: line feed)。 windows 下换行符是 \\r\\n， *unix是 \\n， mac 下最初是 \\r (直到 Mac OS Version 9)后来是 \\n (Mac OS X)。╮(╯▽╰)╭ 有没有一种错乱的感觉！ 所以 System.out.println() 和 System.out.print(&#39;\\n&#39;) 是有差异的！System.out.println() 和 System.out.printf(&quot;%n&quot;)是一致的。 获取换行符： System.lineSeparator(); 或是 System.getProperty(“line.separator”); 13. java 的 system properties 有哪些？具体有哪些可以通过 System.getProperties() 查看。有一些是系统定义的，有一些是应用程序定义的，不过我们主要系统定义的一部分。 Java相关：”java.home”, “java.library.path”, “java.class.path”, “java.ext.dirs”,”java.version”, “java.runtime.version” 分别是： JRE目录、native库目录、load库目录、扩展库目录，java版本，jre版本；分隔符相关： “file.separator”, “path.separator”, “line.separator” 分别是文件分隔符、路径分隔符和换行分隔符；用户相关：”user.home”, “user.name”, “user.dir” 分别是用户主目录、用户名以及用户当前目录；os相关：”os.name”, “os.version”, “os.arch” 分别是操作系统名称、版本、平台； 14. 三元表达式三元表达式 a ? b : c 在某些场景下是 if…else… 很好的替代品。语义就是如果 a 为 true 则 b 的值作为表达式的值， 否则 c 的值作为表达式的值。很好理解。不过需要注意的是 boolen f = true; f ? 10 : 12.5 的结果的值是 10.0 而非 10，原因是表达式 b 和 c 部分的类型需要保持一致，如果不一致会进行默认的类型转换，这里 int 的 10 会转换为 double 的 10.0 。 15. 求余运算 % 和整数除法 /求余运算通常能得到预期的结果，譬如 13 % 3 == 1 。但是 -13 % 3 == ? 13 % -3 == ? -13 % -3 == ? 上面答案分别是：-1 、1和 -1 。记忆方式也挺简单，就是余数的符号和被除数的符号一致。 对应的需要注意：13/3 == 4， -13/3 == -4， 13%-3 == -4， -13/-4 == 3 。总之符合： a = (a/b)*b + (a%b) 。 16. volatile 关键字volatile修饰变量 v 的话，表明变量 v 的值对外具有一致性。也就是说即使在多线程环境下，如果 v 的值修改了，那么去读 v 的值能取到新的 v 值，否则不一定。 v 可以用来修饰基本类型的变量，譬如 int 型， 或是对象。对于后者只是保证引用的对外一致性，而引用的对象的修改不在“一致”范围内。 so，volatile 具有部分线程同步功能，特别是“一写多读”的情形。 17. synchronized 关键字synchronized 可以用来修饰普通方法、类方法或是对象，来控制对方法或是对象的互斥访问。 18. SimpleDateFormatjava doc上有云“Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.”。 所以，SimpleDateFormat作为 static 变量共享的时候需要显式同步，譬如用 synchronized。另外一种处理是借助 ThreadLocal ，这样同一个线程内是安全的，又不需要每一次进行同步。如果将 SimpleDateFormat 作为 local 变量，当然也是线程安全的，只不过每次使用都需要进行重新构造。 转载自:文琼","categories":[{"name":"java","slug":"java","permalink":"http://www.wanqing520.cn/categories/java/"}],"tags":[]},{"title":"使用https://www.processon.com来分享创作的图片","slug":"git/2016-10-14-share_photo_on_processon","date":"2016-10-14T09:47:00.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201610/14/git/2016-10-14-share_photo_on_processon.html","link":"","permalink":"http://www.wanqing520.cn/201610/14/git/2016-10-14-share_photo_on_processon.html","excerpt":"","text":"问题的提出因为在搭建我的git pages时，无意中，看到有文章说，git pages服务器只提供给用户300M的存储空间，因此，我们需要考虑博客的图片的存放。 问题的解决方法使用csdn来同步存储博客内容由于，我之前都是在CSDN使用MARKDOWN编辑器来书写博客，而CSDN的MARKDOWN编辑器支持.md的上传和下载，因此，我之前都是将博客内容写在CSDN上，复制或者下载编写好的markdown文件，再上传到git pages上。这是，比较方法的一种方法。 使用在线图片编辑软件来自己动手画图https://www.processon.com这种网站有很多，随意地打开了这个网站，发现打开速度挺快的，就使用了这个网站。 如何分享在processon上创建的图片1.注册，登录。自己来； 2.在线创作文件这里给出一个我创建的文件的编辑链接：https://www.processon.com/diagraming/5800a208e4b02e1122423a42 3.获取分享连接然后，该网站提供分享该文件的连接，上面的文件对应的分享查看的连接是https://www.processon.com/view/link/5800a353e4b0cff94f9d577e但是，这个路径不是图片，因此，并不是很好的复合我们将其放在markdown中作为图片来展示。 4.下载jpg格式的文件值得高兴的事情，该网站提供文件的下载，并且支持将文件下载为.jpg格式的文件，上面的文件的对应的下载链接为：https://www.processon.com/diagram_export?type=image&amp;title=JMM&amp;chartId=5800a208e4b02e1122423a42&amp;ignore=definition 5.重要的东西来了通过上面的几个步骤，相信你应该可以看到了一个5800a208e4b02e1122423a42的chartId，这个就是我们创建的文件对应的ID，根据4中的下载的下载链接，我们可以构造出一个文件下载链接的模板https://www.processon.com/diagram_export?type=image&amp;title=JMM&amp;chartId=yourChartID&amp;ignore=definition 6.测试下面，我用markdown格式加载我们创建的图片 测试图片 上面图片的markdown代码为： 1![测试图片](https://www.processon.com/diagram_export?type=image&amp;title=JMM&amp;chartId=5800a208e4b02e1122423a42&amp;ignore=definition)","categories":[{"name":"git","slug":"git","permalink":"http://www.wanqing520.cn/categories/git/"}],"tags":[]},{"title":"总线锁和缓存锁","slug":"java/2016-10-14-java-lock","date":"2016-10-14T04:03:14.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201610/14/java/2016-10-14-java-lock.html","link":"","permalink":"http://www.wanqing520.cn/201610/14/java/2016-10-14-java-lock.html","excerpt":"","text":"关系现在的处理器能够自动保证每个处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供总线锁定和缓存锁定两个机制来保证复杂的内存操作的原子性。 总线锁总线索就是使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出此信号，其他处理器的请求将被阻塞，那么该处理器就可以独占共享锁。 缓存锁由于，我们只需要保证对某个内存地址的操作是原子的即可，但是总线锁把CPU和内存之间的通信锁住了，这使得在锁定期间，其他处理器也不能操作其他内存地址的数据，所以总线锁的开销比较大。目前，处理器在某些场合下使用缓存锁来代替总线索进行优化。 缓存锁就是指内存区域如果被缓存在处理器的缓存行中，并且在LOCK#操作期间，那么当它执行操作回写到内存时，处理器不在总线上声言LOCK#信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，其他处理器回写已被锁定的缓存行的数据时，就会使缓存无效。 使用场景如上面所说，在多数情况下，处理器还是使用缓存锁来代替总线锁，但是在下面两种情况下，我们还是使用总线锁来完成相应保证一致性。 情况1：当操作的数据不能被缓存在处理器内部，或者操作的数据跨多个缓存行时，则处理器会字调用总线锁锁定。 情况2：有些处理器不支持缓存行锁定。","categories":[{"name":"java","slug":"java","permalink":"http://www.wanqing520.cn/categories/java/"}],"tags":[]},{"title":"2016-10-13-如果打印机不能连接","slug":"杂谈/2016-10-13-intranet-printer","date":"2016-10-13T08:57:14.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201610/13/杂谈/2016-10-13-intranet-printer.html","link":"","permalink":"http://www.wanqing520.cn/201610/13/杂谈/2016-10-13-intranet-printer.html","excerpt":"","text":"问题描述如果使用WIN+R,输入\\\\172.16.135.41,需要输入用户名和密码才能访问打印机或者直接提示用户被禁止，无法登陆的情况。请参考下面的设置方法。 解决这个问题，是由那台打印机附属的电脑升级成win10系统之后，才出现的这个问题。出现上面描述的问题，是因为Guest用户被禁用，需要关闭该用户的禁用。 在桌面，右键计算机，选择管理； 进入计算机管理（本地）之后，选择本地用户和组; 进入本地用户和组后，选择用户； 计入用户后，查看Guest用户 如果Guest用户图标有一个向下的箭头，则表示该用户被禁用； guest取消禁用的方法：双击guest，修改Guest用户的属性； 该属性中的账户已禁用取消","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.wanqing520.cn/categories/杂谈/"}],"tags":[]},{"title":"2016-10-12-Spring MV异步请求","slug":"java/2016-10-12-SpringMVC-async-reuest","date":"2016-10-12T08:58:14.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201610/12/java/2016-10-12-SpringMVC-async-reuest.html","link":"","permalink":"http://www.wanqing520.cn/201610/12/java/2016-10-12-SpringMVC-async-reuest.html","excerpt":"","text":"第22章 异步请求Servlet3.0规范新增了对异步请求的支持，Spring MVC也在此基础上对异步请求提供了方便。异步请求是在处理比较耗时的业务时先将request返回，然后另起线程处理耗时的业务，处理完后再返回给用户。 异步请求可以给我们带来很多方便，最直接的用法就是处理耗时的业务，比如，需要查询数据库、需要调用别的服务器来处理等情况下可以先将请求返回给客户端，然后启用新线程处理耗时业务，等处理完成后再将结果返回给用户。稍微扩展一下还可以实现订阅者模式的消息订阅功能，比如，当有异常情况发生时可以主动将相关信息发给运维人员，还有现在很多邮箱系统中收到新邮件的自动提示功能也是这种技术。甚至更进一步的使用方式是在浏览器上做即时通信的程序！ HTTP协议是单向的，只能客户端自己拉不能服务器主动推，Servlet对异步请求的支持并没有修改HTTP协议，而是对Http的巧妙利用。异步请求的核心原理主要分为两大类，一类是轮询，另一类是长连接。轮询就是定时自动发起请求检查有没有需要返回的数据，这种方式对资源的浪费是比较大的；长连接的原理是在客户端发起请求，服务端处理并返回后并不结束连接，这样就可以在后面再次运回给客户端数据。Servlet对异步请求的支持其实采用的是长连接的方式，也就是说，异步请求中在原始的请求返回的时候并没有关闭连接，关闭的只是处理请求的那个线程（一般是回收的线程池里了），只有在异步请求全部处理完之后才会关闭连接。 22.1 Servlet3．O对异步请求的支持在Servlet3.0规范巾使用异步处理请求非常简单，只需要在请求处理过程中调用request的startAsync方法即可，其返回值是AsyncContext类型。 AsyncContext在异步请求中充当着非常重要的角色，可以称为异步请求上下文也可以称为异步请求容器，无论叫什么其实就是个名字，它的作用是保存与异步请求相关的所有信息，类似于Servlet中的ServletContext。异步请求主要是使用AsyncContext进行操作，它是在请求处理的过程中调用Request的startAsync方法返回的，需要注意的是多次调用startAsync方法返回的是同一个AsyncContext。AsyncContext接口定义如下：1234567891011121314151617181920212223242526272829303132333435363738394041public interface AsyncContext &#123; static final String ASYNC_REQUEST_URI = \"javax.servlet.async.request_uri\"; static final String ASYNC_CONTEXT_PATH = \"javax.servlet.async.context_path\"; static final String ASYNC_PATH_INFO = \"javax.servlet.async.path_info\"; static final String ASYNC_SERVLET_PATH = \"javax.servlet.async.servlet_path\"; static final String ASYNC_QUERY_STRING = \"javax.servlet.async.query_string\"; public ServletRequest getRequest(); public ServletResponse getResponse(); public boolean hasOriginalRequestAndResponse(); public void dispatch(); public void dispatch(String path); public void complete(); public void start(Runnable run); public void addListener(AsyncListener listener); public void addListener(AsyncListener listener, ServletRequest servletRequest, ServletResponse servletResponse); public &lt;T extends AsyncListener&gt; T createListener(Class&lt;T&gt; clazz) throws ServletException; public void setTimeout(long timeout); public long getTimeout();&#125; 其中，getResponse方法用得非常多，它可以获取到response，然后就可以对response进行各种操作了；dispatch方法用于将请求发送到一个新地址，有三个重载实现方法，其中没有参数dispatch方法的会发送到request原来的地址（如果有forward则使用forward后的最后一个地址）．一个path参数的dispatch方法直接将path作为地址，两个参数的dispatch方法可以发送给别的应用指定的地址；complete方法用于通知容器请求已经处理完了；start方法用于启动实际处理线程．不过也可以自己创建线程在其中使用AsyncContext保存的信息(如response)进行处理；addListener用于添加监听器；setTimeout方法用于修改超时时间，因为异步请求一般耗时比较长，而正常的请求设置的有效时长一般比较短，所以在异步请求中很多时候都需要修改超时的时间。 22.1.1 Servlet 3.0处理异步请求实例使用Servlet 3.0处理异步请求需要三步：①配置Servlet时将async-supported设置为true；②在Servlet处理方法中调用Request的startAsync方法启动异步处理；③使用第2步中返同的AsyncContext处理异步请求。 要想使用Servlet 3.0异步请求的功能需要在配置Servlet时将async-supported设置为true，比如，配置一个叫WorkServlet的可以处理异步请求的Servlet。 123456789&lt;servlet&gt; &lt;servlet-name&gt;WorkServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.excelib.servlet.WorkServlet&lt;/servlet-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;WorkServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/work&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 然后新建一个叫WorkServlet的Servlet，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566package com.excelib.servlet;import javax.servlet.*;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;import java.text.SimpleDateFormat;import java.util.*;public class WorkServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; this.doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse res) throws ServletException, IOException &#123; // 设置contentType、关闭缓存 res.setContentType(\"text/plain;charset=UTF-8\"); res.setHeader(\"Cache-Control\", \"private\"); res.setHeader(\"Pragma\", \"no-cache\"); // 原始请求可以做一些简单业务的处理 final PrintWriter writer = res.getWriter(); writer.println(\"老板检查当前需要做的工作\"); writer.flush(); // jobs表示需要做的工作，使用循环模拟初始化 List&lt;String&gt; jobs = new ArrayList&lt;&gt;(); for(int i=0;i&lt;10;i++)&#123; jobs.add(\"job\"+i); &#125; // 使用request的startAsync方法开启异步处理 final AsyncContext ac = req.startAsync(); // 具体处理请求，内部处理启用了新线程，不会阻塞当前线程 doWork(ac, jobs); writer.println(\"老板布置完工作就走了\"); writer.flush(); &#125; private void doWork(AsyncContext ac, List&lt;String&gt; jobs)&#123; // 设置超时时间1小时 ac.setTimeout(1*60*60*1000L); // 使用新线程具体处理请求 ac.start(new Runnable() &#123; @Override public void run() &#123; try &#123; // 从AsyncContext获取到Response进而获取到Writer PrintWriter w = ac.getResponse().getWriter(); for(String job:jobs)&#123; w.println(\"\\\"\"+job+\"\\\"请求处理中。。。\"); Thread.sleep(1 * 1000L); w.flush(); &#125; // 发出请求处理完成通知 ac.complete(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 这里的异步处理过程是在doWork方法中，它使用req．startAsync()返回的AsyncContext来处理的请求，处理完成后调用complete方法发出完成通知告诉容器请求已经处理完。doPost中除了startAsync和doWork外都是正常的操作，而且都有注释，就不解析了。当调用诸求时，返回页面结果如图22-1所示。 一个通过异步请求完成工作的示例程序就写完了。 22.1.2异步请求监听器AsyncListener上面的程序已经可以完成工作了，不过还不够完善。老板这个职业是需要思考宏观问题的，它需要宏观的数据，所以在干完活后最好给领导汇报一下什么时候干完的、干的怎么样、有没有出什么问题等综合性的数据，不过这些事情按照分工并不应该由实际干活的人来做，如果非让它们做就可能会影响效率，而且它们汇报的数据也有可能不真实，所以老板应该找专人来做这件事，这就有了二线人员。在Servlet异步请求中干这个活的二线人员就是AsyncListener监听器，AsyncListener定义如下： 1234567891011public interface AsyncListener extends EventListener &#123; public void onComplete(AsyncEvent event) throws IOException; public void onTimeout(AsyncEvent event) throws IOException; public void onError(AsyncEvent event) throws IOException; public void onStartAsync(AsyncEvent event) throws IOException; &#125; onComplete方法在请求处理完成后调用，onTimeout方法在超时后调用，onError方法在出错时调用，onStartAsync方法在Request调用startAsync方法启动异步处理时调用。 这里需要注意的是只有在调用request.startAsync前将监听器添加到AsyncContext，监听器的onStartAsync方法才会起作用，而调用startAsync前AsyncContext还不存在，所以第一次调用startAsync是不会被监听器中的onStartAsync方法捕获的，只有在超时后又重新开始的情况下onStartAsync方法才会起作用。这一般也没有什么太大的问题，就像上面的例子中开始的时候是老板安排的任务，他自己当然知道，所以不汇报也没关系，不过如果到了时间节点任务没完成又重新开始了那还是要汇报的。 我们给前面的WorkServlet添加两个AsyncListener监听器BossListener和LeaderListener．一个用来给老板汇报，另一个用来给项目负责人汇报，它们都是定义在WorkServlet中的私有类，而且代码也都一样，其中BossListener的代码如下：1234567891011121314151617181920private class BossListener implements AsyncListener &#123; final SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); @Override public void onComplete(AsyncEvent event) throws IOException &#123; System.out.println(\"在\" + formatter.format(new Date()) + \"工作处理完成\"); &#125; @Override public void onError(AsyncEvent event) throws IOException &#123; System.out.println(\"在\" + formatter.format(new Date()) + \"工作处理出错，详情如下：\\t\" +event.getThrowable().getMessage()); &#125; @Override public void onStartAsync(AsyncEvent event) throws IOException &#123; System.out.println(\"在\" + formatter.format(new Date()) + \"工作处理开始\"); &#125; @Override public void onTimeout(AsyncEvent event) throws IOException &#123; System.out.println(\"在\" + formatter.format(new Date()) + \"工作处理超时\"); &#125;&#125; 然后将监听器注册到WorkServlet中，注册方法是在获取到AsyncContext后将监听器添加进去，相关代码如下：123456789// 使用request的startAsync方法开启异步处理final AsyncContext ac = req.startAsync();// 添加两个监听器ac.addListener(new BossListener());ac.addListener(new LeaderListener(), req, res);// 具体处理请求，内部处理启用了新线程，不会阻塞当前线程doWork(ac, jobs);writer.println(\"老板布置完工作就走了\");writer.flush(); 这样就将两个监听器注册完了。这里之所以添加了两个监听器，是要告诉大家一个AsyncContext可以添加多个监听器，而且有两个重载的添加方法。在监听器中可以使用AsyncEvent事件获取Request、Response以及在有异常的时候获取Throwable，代码如下：123event.getSuppliedRequest();event.getSuppliedReponse();event.getThrowable(); 22.2 Spring MVC中的异步请求Spring MVC为了方便使用异步请求专门提供了AsyncWebRequest类型的request，并且提供了处理异步请求的管理器WebAsyncManager和工具WebAsyncUtils。 Spring MVC将异步请求细分为了Callable、WebAsyncTask、DeferredResult和ListenableFuture四种类型。前两种是一类，它们的核心是Callable，这一类很容易理解，因为大家对Callable应该都比较熟悉；DeferredResult类可能不是很容易理解，因为它是Spring MVC自己定义的类型，我们平时可能没使用过，而且相关资料也不多，所以刚接触的时候会觉得不知道从哪里人手，不过弄明白后其实是非常简单的；ListenableFuture足Spring MVC4.0新增的，它在Java的Future基础上增加了设置回调方法的功能，主要用于需要在处理器中调用别的资源（如别的url）的情况，Spring MVC专门提供了AsyncRestTemplate方法调用别的资源，并返回ListenableFuture类型。 本章先分析Spring MVC中异步请求使用到的组件，然后分析Spring MVC是怎么使用这些组件处理异步请求的，最后再分别对每一类返回值进行介绍。 22.2.1 Spring MVC中异步请求相关组件这里主要分析AsyncWebRequest、WebAsyncManager和WebAsyncUtils组件。WebAsyncManager里面还包含了一些别的组件，在分析的过程中也一起分析。AsyncWebRequest首先来看AsyncWebRequest，它是专门用来处理异步请求的request，定义如下：1234567891011121314151617public interface AsyncWebRequest extends NativeWebRequest &#123; void setTimeout(Long timeout); void addTimeoutHandler(Runnable runnable); void addCompletionHandler(Runnable runnable); void startAsync(); boolean isAsyncStarted(); void dispatch(); boolean isAsyncComplete();&#125; 其中，addTimeoutHandler方法和addCompletionHandler方法分别用于添加请求超时和请求处理完成的处理器，其作用相当于AsyncListener监听器中的onTimeout和onComplete方法；isAsyncStarted方法用于判断是否启动了异步处理；isAsyncComplete方法用于判断异步处理是否已经处理完了。别的方法都与AsyncContext中的同名方法作用一样，就不一一解释了。它的实现类有两个，一个是NoSupportAsyncWebRequest，另一个是StandardServletAsyncWebRequest，前者不支持异步请求，所以在Spring MVC中实际用作异步请求的request是StandardServletAsync WebRequest. StandardServletAsyncWebRequest除了实现了AsyncWebRequest接口，还实现了AsyncListener接口，另外还继承了ServletWebRequest，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111public class StandardServletAsyncWebRequest extends ServletWebRequest implements AsyncWebRequest, AsyncListener &#123; private Long timeout; private AsyncContext asyncContext; private AtomicBoolean asyncCompleted = new AtomicBoolean(false); private final List&lt;Runnable&gt; timeoutHandlers = new ArrayList&lt;Runnable&gt;(); private final List&lt;Runnable&gt; completionHandlers = new ArrayList&lt;Runnable&gt;(); /** * Create a new instance for the given request/response pair. * @param request current HTTP request * @param response current HTTP response */ public StandardServletAsyncWebRequest(HttpServletRequest request, HttpServletResponse response) &#123; super(request, response); &#125; /** * &#123;@inheritDoc&#125; * &lt;p&gt;In Servlet 3 async processing, the timeout period begins after the * container processing thread has exited. */ @Override public void setTimeout(Long timeout) &#123; Assert.state(!isAsyncStarted(), \"Cannot change the timeout with concurrent handling in progress\"); this.timeout = timeout; &#125; @Override public void addTimeoutHandler(Runnable timeoutHandler) &#123; this.timeoutHandlers.add(timeoutHandler); &#125; @Override public void addCompletionHandler(Runnable runnable) &#123; this.completionHandlers.add(runnable); &#125; @Override public boolean isAsyncStarted() &#123; return ((this.asyncContext != null) &amp;&amp; getRequest().isAsyncStarted()); &#125; /** * Whether async request processing has completed. * &lt;p&gt;It is important to avoid use of request and response objects after async * processing has completed. Servlet containers often re-use them. */ @Override public boolean isAsyncComplete() &#123; return this.asyncCompleted.get(); &#125; @Override public void startAsync() &#123; Assert.state(getRequest().isAsyncSupported(), \"Async support must be enabled on a servlet and for all filters involved \" + \"in async request processing. This is done in Java code using the Servlet API \" + \"or by adding \\\"&lt;async-supported&gt;true&lt;/async-supported&gt;\\\" to servlet and \" + \"filter declarations in web.xml.\"); Assert.state(!isAsyncComplete(), \"Async processing has already completed\"); if (isAsyncStarted()) &#123; return; &#125; this.asyncContext = getRequest().startAsync(getRequest(), getResponse()); this.asyncContext.addListener(this); if (this.timeout != null) &#123; this.asyncContext.setTimeout(this.timeout); &#125; &#125; @Override public void dispatch() &#123; Assert.notNull(this.asyncContext, \"Cannot dispatch without an AsyncContext\"); this.asyncContext.dispatch(); &#125; // --------------------------------------------------------------------- // Implementation of AsyncListener methods // --------------------------------------------------------------------- @Override public void onStartAsync(AsyncEvent event) throws IOException &#123; &#125; @Override public void onError(AsyncEvent event) throws IOException &#123; &#125; @Override public void onTimeout(AsyncEvent event) throws IOException &#123; for (Runnable handler : this.timeoutHandlers) &#123; handler.run(); &#125; &#125; @Override public void onComplete(AsyncEvent event) throws IOException &#123; for (Runnable handler : this.completionHandlers) &#123; handler.run(); &#125; this.asyncContext = null; this.asyncCompleted.set(true); &#125;&#125; 这里的代码比较长，不过很容易理解，它里面封装了个AsyncContext类型的属性asyncContext，在startAsync方法中会将Request#startAsync返回的AsyncContext设置给它，然后在别的地方主要使用它来完成各种功能。 另外，南于StandardServletAsyncWebRequest实现了AsyncListener接口，所以它自己就是一个监听器，而且在startAsync方法中在创建出AsyncContext后会将自己作为监听器添加进去。监听器实现方法中onStartAsync方法和onError方法是空实现，onTimeout方法和onComplete方法分别调用了封装的两个List类型的属性timeoutHandlers和completionHandlers所保存的Runnable方法，这样在使用时只需要简单地将需要监听超时和处理完成的监听方法添加到这两个属性中就可以了。 WebAsyncManager WebAsyncManager是Spring MVC处理异步请求过程中最核心的类，它管理着整个异步处理的过程。 WebAsyncManager中最重要的两个方法是startCallableProcessing和startDeferredResultProcessing，这两个方法是启动异步处理的人口方法，它们一共做了三件事：①启动异步处理；②给Request设置相应属性（主要包括timeout、timeoutHandler和completionHandler）；③在相应位置调用相应的拦截器。这里的拦截器是Spring MVC自己定义的。 startCallableProcessing方法用于处理Callable和WebAsyncTask类型的异步请求，使用的拦截器类型是CallableProcessingInterceptor，拦截器封装在CallablelnterceptorChain粪型的拦截器链中统一调用。 startDeferredResultProcessing方法用于处理DeferredResult和ListenableFuture类型的异步请求，使用的拦截器是DeferredResultProcessinglnterceptor拦截器，拦截器封装在DeferredResultlnterceptorChain类型的拦截器链中统一调用。 这两个拦截器的定义如下：1234567891011121314151617public interface CallableProcessingInterceptor &#123; static final Object RESULT_NONE = new Object(); static final Object RESPONSE_HANDLED = new Object(); &lt;T&gt; void beforeConcurrentHandling(NativeWebRequest request, Callable&lt;T&gt; task) throws Exception; &lt;T&gt; void preProcess(NativeWebRequest request, Callable&lt;T&gt; task) throws Exception; &lt;T&gt; void postProcess(NativeWebRequest request, Callable&lt;T&gt; task, Object concurrentResult) throws Exception; &lt;T&gt; Object handleTimeout(NativeWebRequest request, Callable&lt;T&gt; task) throws Exception; &lt;T&gt; void afterCompletion(NativeWebRequest request, Callable&lt;T&gt; task) throws Exception;&#125; 拦截器的作用就是在不同的时间点通过执行相应的方法来做一些额外的事情，所以要学习一种拦截器主要就是要理解它里边的各个方法执行的时间点。这两拦截器都定义了5个方法，方法名也都一样，而且从名字就很容易理解它们执行的时间点，就不分别解释了。需要注意的是，beforeConcurrentHandling方法是在并发处理前执行的，也就是会在主线程中执行，其他方法都在具体处理请求的子线程中执行。 CallableInterceptorChain和DeferredResultlnterceptorC hain分别用于封装两个Interceptor，它们都是将多个相应的拦截器封装到一个List类型的属性，然后在相应的方法中调用所封装的Interceptor相应方法进行处理。大家是不是很熟悉？它跟前面多次便用的XXXComposite组件类似，也是责任链模式。不过和XXXComposite组件不同的是，这里的方法名与Interceptor中稍有区别，它们的对应关系如下： applyBe foreConcurrentHandling：对应Interceptor中的beforeConcurrentHandling方法。 applyPreProcess：对应Interceptor中的preProcess方法。 applyPostProcess：对应Interceptor中的postProcess方法。 triggerAfterTimeout:对应Interceptor中的afierTimeout方法。 triggerAfterCompletion：对应Interceptor中的afterCompletion方法。 理解了这些方法就知道Interceptor和InterceptorChain的作用了，它们都是在WebAsyncManager中相应位置调用的。 在正式分析WebAsyncManager前再看一下WebAsyncTask类，只有理解了这个类才能看明白WebAsyncManager中酌stariCallableProcessing方法。WebAsyncTask的作用主要是封装Callable方法，并且提供了一些异步调用相关的属性，理解了其中包含的属性就明白这个类了，其中属性定义如下：12345678910111213private final Callable&lt;V&gt; callable;private Long timeout;private AsyncTaskExecutor executor;private String executorName;private BeanFactory beanFactory;private Callable&lt;V&gt; timeoutCallback;private Runnable completionCallback; callable用来实际处理请求；timeout用来设置超时时间；executor用来调用callable；executorName用来用容器中注册的名字配置executor；beanFactory用于根据名字获取executor; timeoutCallback相completionCallback分别用于执行超时和请求处理完成的回调。 这里的executor可以直接设置到WebAsyncTask中，也可以使用注册在容器中的名字来设置executorName属性，如果是使用名字来设置的WebAsyncTask的getExecutor方法会从beanFactory中根据名字executorName获取AsyncTaskExecutor，代码如下：123456789101112public AsyncTaskExecutor getExecutor() &#123; if (this.executor != null) &#123; return this.executor; &#125; else if (this.executorName != null) &#123; Assert.state(this.beanFactory != null, \"BeanFactory is required to look up an executor bean by name\"); return this.beanFactory.getBean(this.executorName, AsyncTaskExecutor.class); &#125; else &#123; return null; &#125;&#125; 多知道点 如何在Java中使用并发处理 并发处理是通过多线程完成的，在Java中定义一个多线程的任务可以通过实现Runnable或者Callable接口完成，先来看一下Runnable接定义如下：123456789101112131415@FunctionalInterfacepublic interface Runnable &#123; /** * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used * to create a thread, starting the thread causes the object's * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing * thread. * &lt;p&gt; * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may * take any action whatsoever. * * @see java.lang.Thread#run() */ public abstract void run();&#125; Runnable里只有一个run方法，我们只需要将需要执行的代码放到里面即可，行需要新建一个线程来调用，示例如下：12345678Runnable task = new Runnable()&#123; @Override public void run() System.out.println(\"do task\"); &#125; Thread thread = new Thread(task); thread.start();&#125; 这里新建了task的Runnable类型任务，然后使用它创建了Thread并调用start方法执行了任务。需要说明的是，Thread本身也继承了Runnable接口，所以直接使用Thread来创建Runnable类型的任务然后执行，比如，上面的代码可以修改为：1234567new Thread()&#123; @Override public void run() &#123; System.out.println(\"do task\"); &#125;&#125;.start(); 这样一句代码就可以完成了。 在JavaI.5中新增了Callable接口，定义如下：123456789public interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; Callable里面是call方法，而且可以有返回值还可以处理异常。Callable的执行需要有一个Executor容器来调用，就像Runnable任务需要Thread来调用一样，而且Executor也可以调用Runnable类型的任务。ExecutoriB用后会返回一个Future类型的返回值，我们可以调用Future的get方法来获取Callable中call方法的返回值，不过这个方法是阻塞的，只有call方法执行完后才会返回，示例如下：1234567891011121314ExecutorsService = Executors.newCachedThreadPool();Callable callableTask = new Callable&lt;String&gt;() &#123; public String call() throws Exception&#123; Thread.sleep(1000); System.out.println(\"do task\"); return \"ok\"; &#125;&#125;;Future&lt;String&gt; future = executor.submit(callableTask);System.out.println(\"after submit task\");String result = future.get();System.out.println(\"after future.get()\");System.out.println(\"result=\"+result);executor.shudown(); 这里定义了一个Callable类型的callableTask任务，在其call方法中会等待1秒然后输出dotask并返回ok。Executor调用submit方法提交任务后主程序输出aftersubmittask，这个应该在异步任务返回之前输出，因为方法需要等待1秒，输出aftersubmittask后调用future.get()，这时主线程会阻塞,直到call方法返回，然后输出”afterfuture.get()”，最后输出call返回的结果”ok”，程序运行后控制台打印如下： after submit taskdo taskafter future.get()result=ok 下面来看WebAsyncManager，首先介绍它里面的几个重要属性： timeoutCallablelnterceptor：CallableProcessinglnterceptor类型,专门用于Callable和WebAnsyncTask类型超时的拦截器 timeoutDeferredResultlnterceptor：DeferredResultProcessinglnterceptor类型，专门用于DeferredResult和ListenableFuture类型超时的拦截器。 callablelnterceptors: Map类型，用于所有Callable和WebAsyncTask类型的拦截器。 deferredResultlnterceptors：Map类型，用于所有DeferredResult和ListenableFuture类型的拦截器。 asyncWebRequest：为了支持异步处理而封装的request。 taskExecutor：用于执行Callable和WebAsyncTask类型处理，如果WebAsyncTask中没有定义executor则使用WebAsyncManager中的taskExecutor。 下面分析WebAsyncManager里最核心的两个方法startCallableProcessing和startDeferredResultProcessing，这两个方法的逻辑基本一样，选择其中的startCallableProcessing来分析，这个方法用于启动Callable和WebAsyncTask类型的处理，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * Use the given &#123;@link WebAsyncTask&#125; to configure the task executor as well as * the timeout value of the &#123;@code AsyncWebRequest&#125; before delegating to * &#123;@link #startCallableProcessing(Callable, Object...)&#125;. * @param webAsyncTask a WebAsyncTask containing the target &#123;@code Callable&#125; * @param processingContext additional context to save that can be accessed * via &#123;@link #getConcurrentResultContext()&#125; * @throws Exception if concurrent processing failed to start */ public void startCallableProcessing(final WebAsyncTask&lt;?&gt; webAsyncTask, Object... processingContext) throws Exception &#123; Assert.notNull(webAsyncTask, \"WebAsyncTask must not be null\"); Assert.state(this.asyncWebRequest != null, \"AsyncWebRequest must not be null\"); Long timeout = webAsyncTask.getTimeout(); if (timeout != null) &#123; this.asyncWebRequest.setTimeout(timeout); &#125; AsyncTaskExecutor executor = webAsyncTask.getExecutor(); if (executor != null) &#123; this.taskExecutor = executor; &#125; List&lt;CallableProcessingInterceptor&gt; interceptors = new ArrayList&lt;CallableProcessingInterceptor&gt;(); interceptors.add(webAsyncTask.getInterceptor()); interceptors.addAll(this.callableInterceptors.values()); interceptors.add(timeoutCallableInterceptor); final Callable&lt;?&gt; callable = webAsyncTask.getCallable(); final CallableInterceptorChain interceptorChain = new CallableInterceptorChain(interceptors); this.asyncWebRequest.addTimeoutHandler(new Runnable() &#123; @Override public void run() &#123; logger.debug(\"Processing timeout\"); Object result = interceptorChain.triggerAfterTimeout(asyncWebRequest, callable); if (result != CallableProcessingInterceptor.RESULT_NONE) &#123; setConcurrentResultAndDispatch(result); &#125; &#125; &#125;); this.asyncWebRequest.addCompletionHandler(new Runnable() &#123; @Override public void run() &#123; interceptorChain.triggerAfterCompletion(asyncWebRequest, callable); &#125; &#125;); interceptorChain.applyBeforeConcurrentHandling(this.asyncWebRequest, callable); startAsyncProcessing(processingContext); this.taskExecutor.submit(new Runnable() &#123; @Override public void run() &#123; Object result = null; try &#123; interceptorChain.applyPreProcess(asyncWebRequest, callable); result = callable.call(); &#125; catch (Throwable ex) &#123; result = ex; &#125; finally &#123; result = interceptorChain.applyPostProcess(asyncWebRequest, callable, result); &#125; setConcurrentResultAndDispatch(result); &#125; &#125;); &#125; 通过注释可以看到startCallableProcessing方法主要做了5件事：①将webAsyncTask中相关属性取出并设置到对应的地方；②初始化拦截器链；③给asyncWebRequest设置timeoutHandler和completionHandler；④执行处理器链中相应方法；⑤启动异步处理并使用taskExecutor提交任务。 对其中的启动处理和执行处理详细解释一下，启动处理是调用了startAsyncProcessing方法，其中做了三件事：①调用clearConcurrentResult方法清空之前并发处理的结果；②谰用asyncWebRequest的startAsync方法启动异步处理；③将processingContext设置给concurrentResultContext属性。startAsyncProcessing方法的代码如下：123456789101112131415161718192021private void startAsyncProcessing(Object[] processingContext) &#123; clearConcurrentResult(); this.concurrentResultContext = processingContext; this.asyncWebRequest.startAsync(); if (logger.isDebugEnabled()) &#123; HttpServletRequest request = this.asyncWebRequest.getNativeRequest(HttpServletRequest.class); String requestUri = urlPathHelper.getRequestUri(request); logger.debug(\"Concurrent handling starting for \" + request.getMethod() + \" [\" + requestUri + \"]\"); &#125;&#125;/** * Clear &#123;@linkplain #getConcurrentResult() concurrentResult&#125; and * &#123;@linkplain #getConcurrentResultContext() concurrentResultContext&#125;. */public void clearConcurrentResult() &#123; this.concurrentResult = RESULT_NONE; this.concurrentResultContext = null;&#125; processingContext参数传进来的是处理器中使用的ModelAndViewContainer，concurrentResultContext用来在WebAsyncManager中保存ModelAndViewContainer，在请求处理完成后会设置到RequestMappingHandlerAdapter中，具体过程后面再分析。 下面再来说一下执行处理，执行处理使用的是taskExecutor，不过需要注意的是，这里并没直接使用taskExecutor.submit(callable)来提交，而是提交了新建的Runnable，并将Callable的call方法直接放在run方法里调用。代码如下：1234567891011121314151617this.taskExecutor.submit(new Runnable() &#123; @Override public void run() &#123; Object result = null; try &#123; interceptorChain.applyPreProcess(asyncWebRequest, callable); result = callable.call(); &#125; catch (Throwable ex) &#123; result = ex; &#125; finally &#123; result = interceptorChain.applyPostProcess(asyncWebRequest, callable, result); &#125; setConcurrentResultAndDispatch(result); &#125; &#125;); 这么做主要有两个作用：①可以在处理过程中的相应位置调用拦截器链中相应的方法；②在call方法执行完之前不会像Future#get()那样阻塞线程。 不过Runnable是没有返回值的，所以Callable处理的结果需要自己从run方法内部传递出来，WebAsyncManager中专门提供了一个setConcurrentResultAndDispatch方洪来处理返回的结果，这里边会将处理的结果传递出来，代码如下：1234567891011121314151617181920private void setConcurrentResultAndDispatch(Object result) &#123; synchronized (WebAsyncManager.this) &#123; if (hasConcurrentResult()) &#123; return; &#125; this.concurrentResult = result; &#125; if (this.asyncWebRequest.isAsyncComplete()) &#123; logger.error(\"Could not complete async processing due to timeout or network error\"); return; &#125; if (logger.isDebugEnabled()) &#123; logger.debug(\"Concurrent result value [\" + this.concurrentResult + \"] - dispatching request to resume processing\"); &#125; this.asyncWebRequest.dispatch();&#125; concurrentResult是WebAsyncManager中用来保存异步处理结果的属性，hasConcurrentResult方法用来判断concurrentResult是否已经存在返回值。整个方法过程是：如果concurrentResult已经有返回值则直接返回，否则将传人的参数设置到concurrentResult，然后调用asyncWebRequest.isAsyncComplete()检查Request是否已设置为异步处理完成状态（网络中断会造成Request设置为异步处理完成状态），如果是则保存错误日志并返回，否则调用asyncWebRequest.dispatch0发送请求。SpringMVC申异步请求处理完成后会再次发起一个相同的请求，然后在HandlerAdapter中使用一个特殊的HandlerMethod来处理它，具体过程后面再讲解，不过通过Request的dispatch方法发起的请求使用的还是原来的Request，也就是说原来保存在Request中的属性不会丢失。 startDeferredResultProcessing方法和startCallableProcessing方法执行过程类似，只是并没有使用taskExecutor来提交执行，这是因为DeferredResult并不需要执行处理，在后面讲了DeferredResult的用法后大家就明白了。 WebAsyncManager就分析到这里，下面来看WebAsyncUtils。 WebAsyncUtils WebAsyncUtils里面提供了四个静态方法，其中一个是private权限，只供内部调用的，也就是一共提供了三个供外部使用的静态方法。它们定义如下： public static WebAsyncManager getAsyrtcManager (ServletRequest servletRequest) public static WebAsyncManager getAsyncManager (WebRequest webRequest) `public static AsyncWebRequest createAsyncWebRequest (HttpServletRequest request, HttpServletResponse response) 两重载的getAsyncManager方法通过Request获取WebAsyncManager，它们一个使用ServletRequest类型的Request，一个使用WebRequest类型的Request，获取过程都是先判断Request属性里是否有保存的WebAsyncManager对象，如果有则取出后直接返回，如果没有则新建一个设置到Request的相应属性中并返回，下次再获取时直接从Request属性中取出。 createAsyncWebRequest方法用于创建AsyncWebRequest，它使用ClassUtils.hasMethod判断传人的Request是否包含startAsync方法从而判断是否支持异步处理，如果不支持则新建NoSupportAsyncWebRequest类型的Request并返回，如果支持则调用createStandardServletAsyncWebRequest方法创建StandardServletAsync WebRequest类型的Request并返回。 22.2.2 Spring MVC对异步请求的支持Spring MVC对异步请求的处理主要在四个地方进行支持，详述如下：1)FrameworkServlet中给当前请求的WebAsyncManager添加了CallableProcessinglnterceptor类型的拦截器RequestBindinglnterceptor，这是定义在FrameworkServlet内部的一个私有的拦截器，其作用还是跟FrameworkServlet处理正常请求一样，在请求处理前将当前请求的LocaleContext和ServletRequestAttributes设置到了LocaleContextHolder和RequestContextHolder中，并在请求处理完成后恢复，添加过程在processRequest方法中，相关代码如下：123456789101112131415161718192021WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor());private class RequestBindingInterceptor extends CallableProcessingInterceptorAdapter &#123; @Override public &lt;T&gt; void preProcess(NativeWebRequest webRequest, Callable&lt;T&gt; task) &#123; HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class); if (request != null) &#123; HttpServletResponse response = webRequest.getNativeRequest(HttpServletResponse.class); initContextHolders(request, buildLocaleContext(request), buildRequestAttributes(request, response, null)); &#125; &#125; @Override public &lt;T&gt; void postProcess(NativeWebRequest webRequest, Callable&lt;T&gt; task, Object concurrentResult) &#123; HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class); if (request != null) &#123; resetContextHolders(request, null, null); &#125; &#125;&#125; 2) RequestMappingHandlerAdapter酌invokeHandleMethod方法提供了对异步请求的核心支持，其中做了四件跟异步处理相关的事情： 创建AsyncWebRequest并设置超时时间，具体时间可以通过asyncRequestTimeout属性配置到RequestMappingHandlerAdapter申。 对当前请求的WebAsyncManager设置了四个属性：taskExecutor,asyncWebRequest,callablelnterceptors和deferredResultlnterceptors，除了asyncWebRequest的另外三个都可以在RequestMappingHandlerAdapter中配置，taskExecutor如果没配置将默认使用SimpleAsyncTaskExecutor。 如果当前请求是异步请求而且已经处理出了结果，则将异步处理结果与之前保存到WebAsyncManager里的ModeIAnd\\fiewContainer取出来,并将WebAsyncManager里的结果清空，然后调用ServletlnvocableHandlerMethod的wrapConcurrentResult方法创建ConcurrentResultHandlerMethod类型（ServletlnvocableHandlerMethod的内部类）的ServletlnvocableHandlerMethod来替换自己，创建出来的ConcurrentResultHandlerMethod并不执行请求，它的主要功能是判断异步处理的结果是不是异常类型，如果是则抛出，如果不是则使用ReturnValueHandler对其进行解析并返回。 如果requestMappingMethod的invokeAndHandle方法执行完后检查到当前请求已经启动了异步处理，则会直接返回null。 RequestMappingHandlerAdapter中相关代码如下：12345678910111213141516171819202122232425AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);asyncWebRequest.setTimeout(this.asyncRequestTimeout);final WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);asyncManager.setTaskExecutor(this.taskExecutor);asyncManager.setAsyncWebRequest(asyncWebRequest);asyncManager.registerCallableInterceptors(this.callableInterceptors);asyncManager.registerDeferredResultInterceptors(this.deferredResultInterceptors);if (asyncManager.hasConcurrentResult()) &#123; Object result = asyncManager.getConcurrentResult(); mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[0]; asyncManager.clearConcurrentResult(); if (logger.isDebugEnabled()) &#123; logger.debug(\"Found concurrent result value [\" + result + \"]\"); &#125; requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);&#125;requestMappingMethod.invokeAndHandle(webRequest, mavContainer);if (asyncManager.isConcurrentHandlingStarted()) &#123; return null;&#125; 这里的步骤3是调用了ServletInvocableHandlerMethod的wrapConcurrentResult方法创建了新的ServletlnvocableHandlerMethod来处理异步处理的结果，代码如下：123ServletInvocableHandlerMethod wrapConcurrentResult(Object result) &#123; return new ConcurrentResultHandlerMethod(result, new ConcurrentResultMethodParameter(result)); &#125; ConcurrentResultHandlerMethod是在ServletlnvocableHandlerMethod中定义的继承白ServletInvocableHandlerMethod的内部类，代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748private static final Method CALLABLE_METHOD = ClassUtils.getMethod(Callable.class, \"call\");private class ConcurrentResultHandlerMethod extends ServletInvocableHandlerMethod &#123; private final MethodParameter returnType; public ConcurrentResultHandlerMethod(final Object result, ConcurrentResultMethodParameter returnType) &#123; super(new Callable&lt;Object&gt;() &#123; @Override public Object call() throws Exception &#123; if (result instanceof Exception) &#123; throw (Exception) result; &#125; else if (result instanceof Throwable) &#123; throw new NestedServletException(\"Async processing failed\", (Throwable) result); &#125; return result; &#125; &#125;, CALLABLE_METHOD); setHandlerMethodReturnValueHandlers(ServletInvocableHandlerMethod.this.returnValueHandlers); this.returnType = returnType; &#125; /** * Bridge to actual controller type-level annotations. */ @Override public Class&lt;?&gt; getBeanType() &#123; return ServletInvocableHandlerMethod.this.getBeanType(); &#125; /** * Bridge to actual return value or generic type within the declared * async return type, e.g. Foo instead of &#123;@code DeferredResult&lt;Foo&gt;&#125;. */ @Override public MethodParameter getReturnValueType(Object returnValue) &#123; return this.returnType; &#125; /** * Bridge to controller method-level annotations. */ @Override public &lt;A extends Annotation&gt; A getMethodAnnotation(Class&lt;A&gt; annotationType) &#123; return ServletInvocableHandlerMethod.this.getMethodAnnotation(annotationType); &#125;&#125; ConcurrentResultHandlerMethod调用父类的构造方法(super)将HandlerMethod中的Handler和Method都替换掉了，Handler用了新建的匿名Callable，Method使用了ServletInvocableHandlerMethod酌静态属性CALLABLE—METHOD，它代码Callable的call方法。新建的Callable的执行逻辑也非常简单，就是判断异步处理的返回值是不是异常类型，如果是则抛出异常，不是则直接返回，然后使用和原来请求一样的返回值处理器处理返回值（因为在构造方法中将原来ServletjnvocableHandlerMethod的返回值处理器设置给了自己）。 3)返回值处理器：一共有四个处理异步请求的返回值处理器，它们分别是AsyncTaskMethodReturnValueHandler、CallableMethodReturnValueHandler、De ferredResultMethodReturn ValueHandler和ListenableFutureReturnValueHandler，每一个对应一种类型的返回值，它们的作用主要是使用WebAsyncManager启动异步处理，后面依次对每一类返回值进行分析。 4)在DispatcherServlet的doDispatch方法中，当HandlerAdapter使用Handler处理完请求耐，会检查是否已经启动了异步处理，如果启动了则不再往下处理，直接返回，相关代码如下：123456// Actually invoke the handler.mv = ha.handle(processedRequest, response, mappedHandler.getHandler());if (asyncManager.isConcurrentHandlingStarted()) &#123; return;&#125; 检查方法是调用的WebAsyncManager的isConcurrentHandlingStarted方法，其实内部就是调用的request的isAsyncStarted方法，代码如下：1234567891011/** * Whether the selected handler for the current request chose to handle the * request asynchronously. A return value of \"true\" indicates concurrent * handling is under way and the response will remain open. A return value * of \"false\" means concurrent handling was either not started or possibly * that it has completed and the request was dispatched for further * processing of the concurrent result. */public boolean isConcurrentHandlingStarted() &#123; return ((this.asyncWebRequest != null) &amp;&amp; this.asyncWebRequest.isAsyncStarted());&#125; Spring MVC中跟异步请求处理相关的四个位置孰分析完了。主要处理流程是这样的：首先在处理器中返回需要启动异步处理的类型时（四种类型）相应返同值处理器会调用WebAsyncManager的相关方法启动异步处理，然后在DispatcherServlet中将原来请求直接返回，当异步处理完成后会重新发出一个相同的请求，这时在RequestMappingHandlerAdapter中会使用特殊的ServletlnvocableHandlerMethod来处理请求，处理方法是：如果异步处理返回的结果是异常类型则抛出异常，否则直接返回异步处理结果，然后使用返回值处理器处理，接着返回DispatcherServlet中按正常流程往下处理。 异步处理完成后会重新发起一个请求，这时会重新查找HandlerMethod并初始化PathVariable、MatrixVariable等参数，重新初始化Model中的数据并再次执行Handler-Interceptor中相应的方法。这么做主要是可以复用原来的那套组件进行处理而不需要重新定义。不过新请求的HandlerMethod是用的专门的类型，而Model是使用的原来保存在WebAsyncManager的concurrentResultContext届性中的ModelAndViewContainer所保存的Model，所以这里的查找HandlerMethod和初始化Model的过程是没用的，在这里可以进行一些优化，比如，将创建ConcurrentResultHandlerMethod的过程放在HandlerMapping中（这样也更符合组件的功能），然后在调用ModeIFactory的initModel方法前判断是不是异步处理dispatcher过来的请求，如果是则不再初始化了，或者干脆创建新的HandlerAdapter来处理。 除了上述可以优化的地方，这里还有两个漏洞，第一个是相应的拦截器里的方法会被调用两次，这是不合适的，而且有的时候还会出问题，比如，如果用了拦截器来检查Token．那么第一次检查通过后就会将相应内容删除，第二次再检查的时候就检查失败了，这就有问题了。第二个是通过FlashMap传递Redirect参数的情况，在前面分析FlashMapManager获取FlashMap的时候说过，每次获取后就会将相应的FlashMap删除，但异步请求会获取两次，如果异步处理器是Redirect刭的结果处理器，并且使用FlashMap传递了参数，这种情况下如果在第二次获取FlashMap的时候（异步请求处理完了）正好用户又发了一个相同的请求，而且RedirectView已经将FlashMap设置到了Session，在获取之前可能被前面的请求获取删除，导致自己获取不到，这么说不容易理解，下面将两个请求的处理过程列出来大家就容易理解了： 请求1 请求2 saveOutputFlashMap 设置FM1 retrieveAndUpdate 获取到FM1 saveOutputFlashMap 设置FM2 retrieveAndUpdate 获取到FM2 retrieveAndUpdate 获取到null retrieveAndUpdate 获取到null 这样请求2设置的FlashMap就会被请求1的第二次retrieveAndUpdate获取到并从Session中删除，请求2就获取不到了，这样两个请求的值就都出了问题了。 这里的第二个漏洞只是从原理上来说存在，一般不会造成什么影响，因为这种情况发生的概率非常小，但第一个漏洞是比较严重的，如果真正使用了类似判断Token等的拦截器需要在具体方法内部自己处理一下。 异步处理流程就说到这里，下面分析每一类返回值的具体处理过程。 22.2.3 WebAsyncTask和Calla ble类型异步请求的处理过程及用法当处理器方法返回WebAsyncTask或Callable类型时将自动启用异步处理。下面来看一下处理WebAsyncTask类型返回值的处理器AsyncTaskMethodReturnValueH andler．它的handleReturnValue方法如下：12345678910111213@Overridepublic void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; if (returnValue == null) &#123; mavContainer.setRequestHandled(true); return; &#125; WebAsyncTask&lt;?&gt; webAsyncTask = (WebAsyncTask&lt;?&gt;) returnValue; webAsyncTask.setBeanFactory(this.beanFactory); WebAsyncUtils.getAsyncManager(webRequest).startCallableProcessing(webAsyncTask, mavContainer);&#125; 如果返回值为null，就会给mavContainer设置为请求已处理，然后返回。如果返回值不为null，调用WebAsyncManager的startCallableProcessing方法处理请求。WebAsyncManager是使用WebAsyncUtils获取的。下面来看一个例子，首先给配置Spring MVC的Servlet添加异步处理支持，也就是添加async-supported属性，代码如下：123456789&lt;servlet&gt; &lt;servlet-name&gt;let'sGo&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;WEB-INF/let'sGo-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/servlet&gt; 接下来写一个AsyncController，代码如下:123456789101112131415161718192021222324252627package com.excelib.controller;import javax.servlet.*;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@Controllerpublic class AsyncController &#123; @ResponseBody @RequestMapping(value = \"/webasynctask\",produces = \"text/plain; charset=UTF-8\") public WebAsyncTask&lt;String&gt; webAsyncTask()&#123; System.out.println(\"WebAsyncTask处理器主线程进入\"); WebAsyncTask&lt;String&gt; task = new WebAsyncTask&lt;String&gt;(new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; Thread.sleep(5*1000L); System.out.println(\"WebAsyncTask处理执行中。。。\"); return \"久等了\"; &#125; &#125;); System.out.println(\"WebAsyncTask处理器主线程退出\"); return task; &#125;&#125; 这里新建了WebAsyncTask，并使用匿名类建了Callable进行异步处理，实际使用中可以在其中写数据库请求等耗时的业务，这里直接等了5秒来模拟。处理器注释了@ResponseBody，其返回值会直接返回给浏览器。当调用http://localhost:8080/ webasynctask时，会在等待大约5秒后返回给浏览器久等了三个字。 现在再返回去看WebAsyncManager的startCallableProcessing方法就容易理解了，其实就是先添加拦截器，并在相应的地方执行拦截器里的方法，最后使用taskExecutor调用返回WebAsyncTask申的Callable处理。 当然这里只是给WebAsyncTask设置了Callable，除此之外还可以设置executor、timeout、timeoutCallback和completionCallback等属性。 Callable的处理其实是在WebAsyncManager内部封装成WebAsyncTask后再处理的。当处理器中返回Callable类型的返回值时，Spring MVC会使用CallableMethodReturnValueHandler来处理返回值，它的handleReturnValue方法代码如下：123456789101112131415161718192021public class CallableMethodReturnValueHandler implements HandlerMethodReturnValueHandler &#123; @Override public boolean supportsReturnType(MethodParameter returnType) &#123; return Callable.class.isAssignableFrom(returnType.getParameterType()); &#125; @Override public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; if (returnValue == null) &#123; mavContainer.setRequestHandled(true); return; &#125; Callable&lt;?&gt; callable = (Callable&lt;?&gt;) returnValue; WebAsyncUtils.getAsyncManager(webRequest).startCallableProcessing(callable, mavContainer); &#125;&#125; 这里直接调用了WebAsyncManager的startCallableProcessing方法进行处理，不过这是一个重载的第一个参数是Callable类型的startCallableProcessing方法，其代码如下:1234public void startCallableProcessing(Callable&lt;?&gt; callable, Object... processingContext) throws Exception &#123; Assert.notNull(callable, \"Callable must not be null\"); startCallableProcessing(new WebAsyncTask(callable), processingContext);&#125; 它还是将Callable封装成了WebAsyncTask然后处理的。如果WebAsyncTask中只有Callable而没有别的属性的时候可以直接返回Callable，比如前面的处理器可以修改为：1234567891011121314151617181920212223242526package com.excelib.controller;import javax.servlet.*;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;public class AsyncController &#123; @ResponseBody @RequestMapping(value = \"/callable\",produces = \"text/plain; charset=UTF-8\") public Callable&lt;String&gt; callable()&#123; System.out.println(\"Callable处理器主线程进入\"); Callable&lt;String&gt; callable = new Callable&lt;String&gt;() &#123; @Override public String call() throws Exception &#123; Thread.sleep(5 * 1000L); System.out.println(\"Callable处理执行中。。。\"); return \"久等了\"; &#125; &#125;; System.out.println(\"Callable处理器主线程退出\"); return callable; &#125;&#125; 它和前面使用WebAsyncTask执行的效果是一样的。 22.2.4 DeferredResult类型异步请求的处理过程及用法DeferredResult是spring提供的一种用于保存延迟处理结果的类，当一个处理器返回DeferredResult类型的返回值时将启动异步处理。 不过DeferredResult和WebAsyncTask的使用方法完全不同，DeferredResult并不是用于处理请求的，而且也不包含请求的处理过程，它是用来封装处理结果的，有点像Java中的Future，但不完全一样。 使用DeferredResult的难点就在理解其含义，对其含义理解了之后就会觉得非常简单，而且使用起来也很方便。在返回WebAsyncTask时是因为处理的时间过长所以使用了异步处理，但其实还是自己来处理的（因为WebAsyncTask需要提供Callable），而返回DeferredResult表示要将处理交个别人了，什么时候处理完、怎么处理的自己并不需要知道，这就好像在单位经常用到的“妥否，请批示”的请示报告，自己并不知道什么时候能批下来，而且也不需要知道具体批示过程，只需要知道最后的结果就可以了。DeferredResult就是来保存结果的，当处理完之后调用它的setResult方法将结果设置给它就可以了。 DeferredResult还提供了一些别的属性，如resultHandler可以在设置了结果之后对结果进行处理、timeout设置超时时间、timeoutCallback设置超时处理方法、completionCallback设置处理完成后酌处理方法、timeoutResult设置超时后返回的结果等。 下面看一下Spring MVC中处理DeferredResult返回值的DeferredResultMethodReturnValueHandler处理器，它的handleReturnValue方法如下：123456789101112131415161718192021public class DeferredResultMethodReturnValueHandler implements HandlerMethodReturnValueHandler &#123; @Override public boolean supportsReturnType(MethodParameter returnType) &#123; return DeferredResult.class.isAssignableFrom(returnType.getParameterType()); &#125; @Override public void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; if (returnValue == null) &#123; mavContainer.setRequestHandled(true); return; &#125; DeferredResult&lt;?&gt; deferredResult = (DeferredResult&lt;?&gt;) returnValue; WebAsyncUtils.getAsyncManager(webRequest).startDeferredResultProcessing(deferredResult, mavContainer); &#125;&#125; 这里直接凋用了WebAsyncManager的startDeferredResultProcessing方法进行处理。 下面来看一个返回值为DeferredResult的处理器的例子。123456789101112131415161718192021222324252627282930313233package com.excelib.controller;import javax.servlet.*;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@Controllerpublic class AsyncController &#123; @ResponseBody @RequestMapping(value = \"/deferred\",produces = \"text/plain; charset=UTF-8\") public DeferredResult&lt;String&gt; deferredResultExam() &#123; final DeferredResult&lt;String&gt; result = new DeferredResult&lt;String&gt;(7*1000L, \"超时了\"); approve(result); return result; &#125; private void approve(DeferredResult&lt;String&gt; result)&#123; Runnable r = new Runnable() &#123; @Override public void run() &#123; try &#123; Thread.sleep(5 * 1000L); result.setResult(\"同意 \"+new SimpleDateFormat(\"yyyy-MM-dd\").format(new Date())); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125;; new Thread(r).start(); &#125;&#125; 在处理器方法中直接新建了个DeferredResult类型的result代表处理结果，构造方法的两个参数分别表示超时时间和超时后返回的结果，建出来后将其交给approve方法进行处理（审批），当approve方法给result使用setResult方法设置了值后异步处理就完成了。 approve方法启动了一个新线程，然后在里面等待5秒后给result设置值。因为这里的处理器有@ResponseBody注释，所以返回值会直接显示到浏览器，当调用http://localhost:8080/deferred时，浏览器会在过大约5秒后显示同意2015-04-02。 现在大家再返回去看WebAsyncManager酌startDeferredResultProcessing方法就容易理解了，它并没有而且也不需要执行，只需要等待别的线程给设置返回值就可以了。方法中给result设置了处理返回值的处理器，当有返回值返回时会自动调用，代码如下：1234567deferredResult.setResultHandler(new DeferredResultHandler() &#123; @Override public void handleResult(Object result) &#123; result = interceptorChain.applyPostProcess(asyncWebRequest, deferredResult, result); setConcurrentResultAndDispatch(result); &#125;&#125;); 这里的处理器中首先调用了拦截器链中的applyPostProcess方法，然后调用setConcurrentResultAndDispatch万法处理了返回值，setConcurrentResultAndDispatch方法前面已经说过了。 现在大家应该对DeferredResult返回值的异步处理就理解了，DeferredResult是一个用于保存返回值的类，只需要在业务处理完成后调用其setResult方法设置结果就可以了，至于怎么处理的、在哪里处理的它并不关心，这也就给我们带来了很大的自由。 22.2.5 ListenableFuture类型异步请求的处理过程及用法ListenableFuture继承自Future，Future在前面已经介绍过了，它用来保存Callable的处理结果，它提供了get方法来获取返回值，不过Future并不会在处理完成后主动提示。ListenableFuture在Future基础上增加了可以添加处理成功和处理失败回调方法的方法，代码如下：1234567public interface ListenableFuture&lt;T&gt; extends Future&lt;T&gt; &#123; void addCallback(ListenableFutureCallback&lt;? super T&gt; callback); void addCallback(SuccessCallback&lt;? super T&gt; successCallback, FailureCallback failureCallback);&#125; ListenableFutureCallback继承自SuccessCallback和FailureCallback接口，后两个接口分别有一个onSuccess方法和onFailure方法，用于处理异步处理成功的返回值和异步处理失败的返回值，就和DeferredResult中的resultHandler差不多，它们定义如下：12345678910111213141516171819202122public interface ListenableFutureCallback&lt;T&gt; extends SuccessCallback&lt;T&gt;, FailureCallback &#123;&#125;public interface SuccessCallback&lt;T&gt; &#123; /** * Called when the &#123;@link ListenableFuture&#125; successfully completes. * @param result the result */ void onSuccess(T result);&#125;public interface FailureCallback &#123; /** * Called when the &#123;@link ListenableFuture&#125; fails to complete. * @param ex the exception that triggered the failure */ void onFailure(Throwable ex);&#125; ListenableFuture足spring4.0新增的接口，它主要使用在需要调用别的服务的时候，spring还同时提供了AsyncRestTemplate，用它可以方便地发起各种Http请求，不同类型的请求（如Get、Post等）都有不同的方法，而且还可以使用url的模板参数uriVariables（类似于处理器参数中的pathVariables】，它的返回值就是ListenableFuture类型，比如，可以这样使用12ListenableFuture&lt;ResponseEntity&lt;String&gt;&gt; futureEntity = template.getForEntity(\"http://localhost:8080/students/&#123;studentld&#125;/books/&#123;bookldl\" , String.class, \"176\", \"7\"); 这样就可以返回http://localhost:808 0/students/1 7 6/books/7的Get请求结果，而且是非阻塞的异步调用。 下面看一下处理ListenableFuture返回值的处理器ListenableFutureReturnValueHandler，它的handleReturnValue方法代码如下：123456789101112131415161718192021222324@Overridepublic void handleReturnValue(Object returnValue, MethodParameter returnType, ModelAndViewContainer mavContainer, NativeWebRequest webRequest) throws Exception &#123; if (returnValue == null) &#123; mavContainer.setRequestHandled(true); return; &#125; final DeferredResult&lt;Object&gt; deferredResult = new DeferredResult&lt;Object&gt;(); WebAsyncUtils.getAsyncManager(webRequest).startDeferredResultProcessing(deferredResult, mavContainer); ListenableFuture&lt;?&gt; future = (ListenableFuture&lt;?&gt;) returnValue; future.addCallback(new ListenableFutureCallback&lt;Object&gt;() &#123; @Override public void onSuccess(Object result) &#123; deferredResult.setResult(result); &#125; @Override public void onFailure(Throwable ex) &#123; deferredResult.setErrorResult(ex); &#125; &#125;);&#125; 可以看到在ListenableFuture的返回值处理器里实际使用了DeferredResult．首先新建了DeferredResult类型的deferredResult，接着调用了WebAsyncManager的startDeferredResultProcessing方法进行处理，然后给ListenableFuture类型的返回值添加了回调方法，在回调方法中对deferredResult设置了返回值。可以说ListenableFuture类型的返回值只是DeferredResult类型返回值处理器的一种特殊使用方式。大家好好体会这里的处理过程就可以对DeferredResult跟具体处理过程无关这一点理解得更加深入。 下面来看一个ListenableFuture类型返回值处理器的例子。123456789101112131415161718package com.excelib.controller;import javax.servlet.*;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;@Controllerpublic class AsyncController &#123; @RequestMapping(value = \"/listenable\",produces = \"text/plain; charset=UTF-8\") public ListenableFuture&lt;ResponseEntity&lt;String&gt;&gt; listenableFuture() &#123; ListenableFuture&lt;ResponseEntity&lt;String&gt;&gt; future = new AsyncRestTemplate().getForEntity( \"http://localhost:8080/index\", String.class); return future; &#125;&#125; 这里处理器的返回值ListenableFuture的泛型是ResponseEntity类型，所以不需要使用@ResponseBody注释也会将返回值直接显示到浏览器。当调用http://localhost:8080/listenable时，浏览器会显示excelibGoGoGo!，也就是http://localhost:8080/index的返回结果.。 多知道点 ListenableFuture和Future的比较 ListenableFuture在Future的基础上增加了可以添加处理成功和处理失败回调方法的方法，这就从Future的“拉”模式变成了ListenableFuture的“推”模式。 Future只能调用get方法来主动拉数据，而且get方法还是阻塞的，而ListenableFuture可以等待处理完成后自己将结果推过来，而且不会阻塞线程，这么看好像ListenableFuture比Future更好用。其实在很多地方Future中阻塞的get方法才是真正需要的，因为很多时候都需要等到线程处理的结果才可以向下进行，比如，要找四个数中最大的那个，可以将四个数分成两组然后启动两个线程分别选出每组中比较大的数，然后再启动一个线程取出两个结果中比较大的，那就是四个数中最大的数，代码如下：12345678910111213141516171819202122232425262728293031public class ObtainBigger &#123; public static void main(String[] args) throws ExecutionException, InterruptedException &#123; ExecutorService executor = Executors.newCachedThreadPool(); // 需要查找最大数的数组 Double data[] = new Double[]&#123;210.32, 517.96, 986.77, 325.13&#125;; // 获取前两个里较大的 BiggerCallable c1 = new BiggerCallable(data[0],data[1]); Future&lt;Double&gt; bigger1 = executor.submit(c1); // 获取后两个里较大的 BiggerCallable c2 = new BiggerCallable(data[2],data[3]); Future&lt;Double&gt; bigger2 = executor.submit(c2); // 获取两个结果中较大的，这时会阻塞，只有前面两个结果都返回时才会往下进行 BiggerCallable c = new BiggerCallable(bigger1.get(), bigger2.get()); Future&lt;Double&gt; bigger = executor.submit(c); // 输出结果 System.out.println(bigger.get()); executor.shutdown(); &#125; private static class BiggerCallable implements Callable &#123; Double d1, d2; public BiggerCallable(Double d1, Double d2)&#123; this.d1 = d1; this.d2 = d2; &#125; @Override public Object call() throws Exception &#123; return d1&gt;d2?d1:d2; &#125; &#125;&#125; 这里使用了内部类BiggerCallable来比较，第三个BiggerCallable创建时前两个cl）c2必须已经执行完才可以，否则就会出问题，所以在这种情况下阻塞就是必要的，而且这种需要线程返回结果后才能往下进行的情况很多。而ListenableFuture的典型用法就是Web异步请求这种并不需要对线程返回的结果进一步处理，而且线程在返回之前主线程可以继续往下走的情况，这时如果程序阻塞就起不到应有的作用了。 22.3小结本章系统地介绍了Servlet和SpringMVC中异步处理的原理和使用方法，首先介绍了Servlet3.0中对异步请求的支持及其使用方法，然后又分析了SpringMVC中异步处理的执行过程并编写了示例程序。 Servlet中使用异步请求非常方便，只需要调用request的startAsync方法，然后对其返回值AsyncContext进行处理，如果需要还可以为其添加AsyncListener监听器，它可以监听异步请求的启动、超时、处理完成和处理异常四个节点。 Spring MVC为异步请求提供了专门的工具，并对处理器默认提供了四种用于异步处理的返回值： 1. Callable、 2. WebAsyncTask、 3. DeferredResult 4. ListenableFuture。 对异步请求的支持主要在RequestMappingHandlerAdapter中，启动异步处理在各返回值对应的返回值处理器中。","categories":[{"name":"java","slug":"java","permalink":"http://www.wanqing520.cn/categories/java/"}],"tags":[]},{"title":"2016-10-12-ThinkPHP集成万象优图","slug":"php/2016-10-12-thinkphp-combine-tencent-cos","date":"2016-10-12T06:58:14.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201610/12/php/2016-10-12-thinkphp-combine-tencent-cos.html","link":"","permalink":"http://www.wanqing520.cn/201610/12/php/2016-10-12-thinkphp-combine-tencent-cos.html","excerpt":"","text":"项目原因不告诉你，反正需要把腾讯云的万象优图整合进来。 准备下载PHP版的万象优图的SDK下载地址：https://github.com/tencentyun/image-php-sdk 文件层次git clone 后的文件架构如下 这里写图片描述 文件后缀修改Tencentyun文件夹下面的7个文件的文件名为*.class.php. 这里写图片描述 导入将修改好的sdk导入到项目中去，我这里导入到了Application-&gt;Home-&gt;Controller-&gt;PhotoServer中了，如下图。 这里写图片描述 命名空间Tencentyun文件夹下的7个.class.php文件的namespace为正确的namespace 。 namespace Home\\Controller\\PhotoServer\\Tencentyun; 实现参考sdk文件夹下的samplev2.php编写测试Controller。代码如下 ：代码后面有注意事项。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?php/** * Created by PhpStorm. * User: Administrator * Date: 2016/7/3 * Time: 11:44 */namespace Home\\Controller\\PhotoServer;use Home\\Controller\\BaseController;require('include.php');use Home\\Controller\\PhotoServer\\Tencentyun\\ImageV2;use Home\\Controller\\PhotoServer\\Tencentyun\\Auth;use Home\\Controller\\PhotoServer\\Tencentyun\\ImageProcess;class PhotoTestController extends BaseController&#123; /** * @return view */ public function index() &#123; //智能鉴黄 $pornUrl = 'http://b.hiphotos.baidu.com/image/pic/item/8ad4b31c8701a18b1efd50a89a2f07082938fec7.jpg'; $pornRet = ImageProcess::pornDetect($pornUrl); var_dump($pornRet);// V2增强版空间 带有空间和自定义文件名的示例// 上传图片 $bucket = 'zlktest'; // 自定义空间名称，在http://console.qcloud.com/image/bucket创建 $fileid = 'sample' . time(); // 自定义文件名 $uploadRet = ImageV2::upload('D:/123.jpg', $bucket, $fileid); var_dump('upload', $uploadRet);//分片上传 $uploadSliceRet = ImageV2::uploadSlice('D:/123.jpg'); var_dump('upload_slice', $uploadSliceRet); if (0 === $uploadRet['code']) &#123; $fileid = $uploadRet['data']['fileid']; $downloadUrl = $uploadRet['data']['downloadUrl']; // 查询管理信息 $statRet = ImageV2::stat($bucket, $fileid); var_dump('stat', $statRet); // 复制 $copyRet = ImageV2::copy($bucket, $fileid); var_dump('copy', $copyRet); // 生成私密下载url $expired = time() + 999; $sign = Auth::getAppSignV2($bucket, $fileid, $expired); $signedUrl = $downloadUrl . '?sign=' . $sign; var_dump('downloadUrl:', $signedUrl); //生成新的单次签名, 必须绑定资源fileid，复制和删除必须使用，其他不能使用 $fileid = $fileid . time() . rand(); // 自定义文件名 $expired = 0; $sign = Auth::getAppSignV2($bucket, $fileid, $expired); var_dump($sign); //生成新的多次签名, 可以不绑定资源fileid $fileid = ''; $expired = time() + 999; $sign = Auth::getAppSignV2($bucket, $fileid, $expired); var_dump($sign); //$delRet = ImageV2::del($bucket, $fileid); //var_dump($delRet); &#125; &#125;&#125; 注意事项 代码中使用了地址为：http://b.hiphotos.baidu.com/image/pic/item/8ad4b31c8701a18b1efd50a89a2f07082938fec7.jpg 的图片。图片内容如下 ： 这里写图片描述 ImageV2::upload(&#39;D:/123.jpg&#39;, $bucket, $fileid);这里的D:/123.jpg是用来模拟上传测试的。 测试示例会顺带使用万象优图的黄图鉴别功能。 访问访问localhost/项目名/index.php/Home/PhotoServer/PhotoTest/index路径返回结果如下，返回字段的详细信息请参考万象优图的官方文档。 这里写图片描述 测试上传是否成功我的D:/123.jpg的图片内容是步骤4中的Tencentyun的文件结构图。根据上面9中所得到的地址为：http://zlktest-10010932.image.myqcloud.com/786c2e74-4591-42ed-861e-8fe27b356c14.即可严重。","categories":[{"name":"php","slug":"php","permalink":"http://www.wanqing520.cn/categories/php/"}],"tags":[]},{"title":"Neil | RequestToViewNameTranslator","slug":"java/2016-10-12-RequestToViewNameTranslator","date":"2016-10-12T06:45:14.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201610/12/java/2016-10-12-RequestToViewNameTranslator.html","link":"","permalink":"http://www.wanqing520.cn/201610/12/java/2016-10-12-RequestToViewNameTranslator.html","excerpt":"","text":"第15章 RequestToViewNameTranslatorRequestToViewNameTranslator可以在处理器返回的view为空时使用它根据request获取viewName。Spring MVC提供的实现类只有一个DefaultRequestToViewNameTranslator，这个类也非常简单，只是因为有一些getter/setter方法，所以看起来代码比较多，实际执行解析的只有两个，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150public class DefaultRequestToViewNameTranslator implements RequestToViewNameTranslator &#123; private static final String SLASH = \"/\"; private String prefix = \"\"; private String suffix = \"\"; private String separator = SLASH; private boolean stripLeadingSlash = true; private boolean stripTrailingSlash = true; private boolean stripExtension = true; private UrlPathHelper urlPathHelper = new UrlPathHelper(); /** * Set the prefix to prepend to generated view names. * @param prefix the prefix to prepend to generated view names */ public void setPrefix(String prefix) &#123; this.prefix = (prefix != null ? prefix : \"\"); &#125; /** * Set the suffix to append to generated view names. * @param suffix the suffix to append to generated view names */ public void setSuffix(String suffix) &#123; this.suffix = (suffix != null ? suffix : \"\"); &#125; /** * Set the value that will replace '&#123;@code /&#125;' as the separator * in the view name. The default behavior simply leaves '&#123;@code /&#125;' * as the separator. */ public void setSeparator(String separator) &#123; this.separator = separator; &#125; /** * Set whether or not leading slashes should be stripped from the URI when * generating the view name. Default is \"true\". */ public void setStripLeadingSlash(boolean stripLeadingSlash) &#123; this.stripLeadingSlash = stripLeadingSlash; &#125; /** * Set whether or not trailing slashes should be stripped from the URI when * generating the view name. Default is \"true\". */ public void setStripTrailingSlash(boolean stripTrailingSlash) &#123; this.stripTrailingSlash = stripTrailingSlash; &#125; /** * Set whether or not file extensions should be stripped from the URI when * generating the view name. Default is \"true\". */ public void setStripExtension(boolean stripExtension) &#123; this.stripExtension = stripExtension; &#125; /** * Set if URL lookup should always use the full path within the current servlet * context. Else, the path within the current servlet mapping is used * if applicable (i.e. in the case of a \".../*\" servlet mapping in web.xml). * Default is \"false\". * @see org.springframework.web.util.UrlPathHelper#setAlwaysUseFullPath */ public void setAlwaysUseFullPath(boolean alwaysUseFullPath) &#123; this.urlPathHelper.setAlwaysUseFullPath(alwaysUseFullPath); &#125; /** * Set if the context path and request URI should be URL-decoded. * Both are returned &lt;i&gt;undecoded&lt;/i&gt; by the Servlet API, * in contrast to the servlet path. * &lt;p&gt;Uses either the request encoding or the default encoding according * to the Servlet spec (ISO-8859-1). * @see org.springframework.web.util.UrlPathHelper#setUrlDecode */ public void setUrlDecode(boolean urlDecode) &#123; this.urlPathHelper.setUrlDecode(urlDecode); &#125; /** * Set if \";\" (semicolon) content should be stripped from the request URI. * @see org.springframework.web.util.UrlPathHelper#setRemoveSemicolonContent(boolean) */ public void setRemoveSemicolonContent(boolean removeSemicolonContent) &#123; this.urlPathHelper.setRemoveSemicolonContent(removeSemicolonContent); &#125; /** * Set the &#123;@link org.springframework.web.util.UrlPathHelper&#125; to use for * the resolution of lookup paths. * &lt;p&gt;Use this to override the default UrlPathHelper with a custom subclass, * or to share common UrlPathHelper settings across multiple web components. */ public void setUrlPathHelper(UrlPathHelper urlPathHelper) &#123; Assert.notNull(urlPathHelper, \"UrlPathHelper must not be null\"); this.urlPathHelper = urlPathHelper; &#125; /** * Translates the request URI of the incoming &#123;@link HttpServletRequest&#125; * into the view name based on the configured parameters. * @see org.springframework.web.util.UrlPathHelper#getLookupPathForRequest * @see #transformPath */ @Override public String getViewName(HttpServletRequest request) &#123; String lookupPath = this.urlPathHelper.getLookupPathForRequest(request); return (this.prefix + transformPath(lookupPath) + this.suffix); &#125; /** * Transform the request URI (in the context of the webapp) stripping * slashes and extensions, and replacing the separator as required. * @param lookupPath the lookup path for the current request, * as determined by the UrlPathHelper * @return the transformed path, with slashes and extensions stripped * if desired */ protected String transformPath(String lookupPath) &#123; String path = lookupPath; if (this.stripLeadingSlash &amp;&amp; path.startsWith(SLASH)) &#123; path = path.substring(1); &#125; if (this.stripTrailingSlash &amp;&amp; path.endsWith(SLASH)) &#123; path = path.substring(0, path.length() - 1); &#125; if (this.stripExtension) &#123; path = StringUtils.stripFilenameExtension(path); &#125; if (!SLASH.equals(this.separator)) &#123; path = StringUtils.replace(path, SLASH, this.separator); &#125; return path; &#125;&#125; getViewName足接口定义的方法，实际解析时就调用它。在getViewName中首先从request获得lookupPath，然后使用transformPath方法对其进行处理后加土前缀后缀返回。transformPath方法的作用简单来说就是根据配置对lookupPath“掐头去尾换分隔符”，它是根据其中的四个属性的设置来处理的，下面分别解释一下这四个属性，其中用到的Slash是一个静态常量，表示”/“。 stripLeadingSlash:如果最前面的字符为Slash是否将其去掉。 stripTrailingSlash：如果最后一个字符为Slash是否将其去掉。 stripExtension：是否需要去掉扩展名。 separator:如果其值与Slash不同则用于替换原来的分隔符Slash。 getViewName中还使用了可以给返回值添加前缀和后缀的prefix和suffix，这些参数都可以配置。可以配置的参数除了这6个外还有4个：urlDecode、removeSemicolonContent、alwaysUseFullPath和urlPathHelper，前三个参数都是用在urlPathHelper中的，urlDecode用于设置url是否需要编解码，一般默认就行；removeSemicolonContent在前面已经说过了．用于设置是否删除url中与分号相关的内容；alwaysUseFullPath用于设置是否总使用完整路径；urlpathHelper是用于处理url的工具，一般使用spring默认提供的就可以了。RequestToViewNameTranslator组件非常简单，本章就介绍到这里。","categories":[{"name":"java","slug":"java","permalink":"http://www.wanqing520.cn/categories/java/"}],"tags":[]},{"title":"Neil | 牛中超--B507实验室打印机连接","slug":"杂谈/2016-10-12-intranter-printer","date":"2016-10-12T06:13:14.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201610/12/杂谈/2016-10-12-intranter-printer.html","link":"","permalink":"http://www.wanqing520.cn/201610/12/杂谈/2016-10-12-intranter-printer.html","excerpt":"","text":"一、准备工具 实验室打印机内网IP地址：172.16.135.41 ,这个地址要看具体的打印机地址（可能会更换）。 从实验室QQ群（土匪窝）上下载打印机驱动，如下图所示。 图1 3. 非常重要的事情：请链接实验室的有线网络或者是由有线网络共享出来的WIFI，不能连接CS-*这样的WIFI# 二、连接步骤1. WIN+R 输入如下这样的命令\\\\+打印机IP地址 图2 在登录界面输入用户名GUI-YUAN ，密码为空（写完文档发现：下图报错的原因是因为我写成小写的了这里是因为截图有问题，登录之后，下次就不要登录了，所以，这里没放正确的图）。 图3 选中下图圈中的HP LaserJet 1020 图4 打开之后，系统会在更新中查找打印机驱动，一般是找不到的，让我们点击取消吧。 图5 从QQ群文件中下载hplaserjet1020plus.zip文件，并解压。 图6 运行解压后的LJ1018_1020_1022_Full_Solution.exe 图7 经过一小会的准备，看到安装的主界面如下，选择安装(I) 图8 step1 图9 step2 图10 出现上面9中所述的界面时，就表明可以回到3连接打印机了，这里点击取消 图11 回到如下界面，再次连接打印机 图12 打印机连接成功 图13 OK，enjoy it !","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.wanqing520.cn/categories/杂谈/"}],"tags":[]},{"title":"Neil | 牛中超--OutofMemory in Action","slug":"java/2016-10-12-OutofMemory-in-Action","date":"2016-10-12T06:03:14.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201610/12/java/2016-10-12-OutofMemory-in-Action.html","link":"","permalink":"http://www.wanqing520.cn/201610/12/java/2016-10-12-OutofMemory-in-Action.html","excerpt":"","text":"","categories":[{"name":"java","slug":"java","permalink":"http://www.wanqing520.cn/categories/java/"}],"tags":[]},{"title":"Neil | 牛中超--R简介","slug":"bigdata/simple_use_of_R","date":"2016-10-12T06:03:14.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201610/12/bigdata/simple_use_of_R.html","link":"","permalink":"http://www.wanqing520.cn/201610/12/bigdata/simple_use_of_R.html","excerpt":"","text":"第1章 R简介1.2.4 向量化1234&gt; v&lt;-c(4,7,23.5,67.2,80)&gt; x&lt;-sqrt(v)&gt; x[1] 2.000000 2.645751 4.847680 8.197561 8.944272 也可以使用R的这个热性进行向量的算术运算。1234&gt; v1&lt;-c(4,6,87)&gt; v2&lt;-c(34,32.4,12)&gt; v1+v2[1] 38.0 38.4 99.0 如果两个向量的长度不同，R会自动的将较短的向量进行扩充。1234&gt; v1&lt;-c(4,6,8,24)&gt; v2&lt;-c(10,2)&gt; v1+v2[1] 14 8 18 26 如果较长的向量的长度不是较短的向量的长度的整数倍，R将会给出警告，注意是警告而不是错误。1234567&gt; v1&lt;-c(4,6,8,24)&gt; v2&lt;-c(10,2,4)&gt; v1+v2[1] 14 8 12 34Warning message:In v1 + v2 : longer object length is not a multiple of shorter object length 以上的内容是循环规则。 如前所述，单个数字在R中表示长度为1的向量。这种表示在下面的运算中非常方便：123&gt; v1&lt;-c(4,6,8,24)&gt; 2*v1[1] 8 12 16 48 注意，数字2被循环，导致v1的所有元素都被乘以2,。正如我们将看到的，这种循环跪着也适用于其他对象，如数组和矩阵。 1.2.5 因子因子提供了一个简单而又紧凑的形式来处理分类数据（名义）。因子用水平来表示所有可能的取值。如果数据集有取值个数固定的名义变量，因子就特别有用。R中的图形函数和汇总函数就是应用了因子的这种有点。对用户来说，这种使用和显示因子数据的方式显然是易于理解的，而R内部以数值编码的方式来存储因子值，这将大大提高内存的利用效率。 下面举个例子来说明如何在R中创建因子。假设有10个人的性别向量。123&gt; g&lt;-c(\"f\",\"m\",\"m\",\"m\",\"f\",\"m\",\"f\",\"m\",\"f\",\"m\",\"f\",\"f\")&gt; g [1] \"f\" \"m\" \"m\" \"m\" \"f\" \"m\" \"f\" \"m\" \"f\" \"m\" \"f\" \"f\" 你可以把这个因子向量转为一个因子。1234&gt; g&lt;-factor(g)&gt; g [1] f m m m f m f m f m f fLevels: f m 注意，这里得到的因子不再是一个字符向量。上面说到，实际上这些因子在R内部表示为数值向量。在这个例子中，因子有两个水平，f和m，在R内部分别表示1和2.然而，我们不需要关系在内部是如何表示的，因为你可以使用原始的字符值，R在显示因子的时候，也使用这种字符方式。因此，出于效率的考虑，R因子的编码转换对用户是透明的。 假设另外有5个人，需要把他们的性别信息存储在另一个透明的因子对象中。假设他们都是男性。如果都仍然需要这个因子对象与对象g有两个相同的因子水平，则必须使用下面的命令。1234&gt; other.g&lt;-factor(c(\"m\",\"m\",\"m\",\"m\",\"m\"),levels = c(\"f\",\"m\"))&gt; other.g[1] m m m m mLevels: f m 如果没有在输入参数中设定level参数，因子other.g将只有一个水平(‘m’). 在R这样的函数式编程语言中，最常见的函数之一就是像上例中的函数复合。 利用因子类型的数据，可以做的一件事情就是计算每个可能值得发生次数。例如：1234&gt; table(g)gf m6 6 1234&gt; table(other.g)other.gf m0 5 table也可以获取多个因子的交叉表。假设向量a存储10个人的所属的年龄，那么可以得到这两个向量的交叉表。如下：123456789101112&gt; a&lt;-factor(c('adult','adult','juvenile','juvenile','adult','adult','adult','juvenile','adult','juvenile'))&gt; length(a)[1] 10&gt; length(g)[1] 10&gt; g [1] \"f\" \"m\" \"m\" \"f\" \"m\" \"f\" \"m\" \"f\" \"m\" \"f\"&gt; table(a,g) ga f m adult 2 4 juvenile 3 1 如果数据过长的话，可以采用+进行换行输入。12345&gt; a&lt;-factor(c('adult','adult','juvenile','juvenile','adult',+ 'adult','adult','juvenile','adult','juvenile'))&gt; a [1] adult adult juvenile juvenile adult adult adult juvenile adult juvenileLevels: adult juvenile 有时候我们希望计算列联表的边际和相对频率。下面给出了上面数据集的性别和年龄因子的总计。123456789&gt; t&lt;-table(a,g)&gt; margin.table(t,1)a adult juvenile 6 4&gt; margin.table(t,2)gf m5 5 输入参数1和2分别代表列联表的第一和第二个维度，即表示t的行和列。每个维度边际和总计的相对频率如下：123456789101112131415&gt; prop.table(t,1) ga f m adult 0.3333333 0.6666667 juvenile 0.7500000 0.2500000&gt; prop.table(t,2) ga f m adult 0.4 0.8 juvenile 0.6 0.2&gt; prop.table(t) ga f m adult 0.2 0.4 juvenile 0.3 0.1 注意：如果需要的是百分比，可以在调用函数时乘以10012345&gt; 100*prop.table(t) ga f m adult 20 40 juvenile 30 10 1.2.6 生产序列R提供了狠多种生产不同类型序列的方法。比如：创建一个1~1000所有整数的向量，可以简单的输入123&gt; x&lt;-1:1000&gt; length(x)[1] 1000 通过上面的语句就创建了一个名为x的向量，它包含了1000个元素。注意运算符:的优先级，我们通过下面的例子来说明这个问题。1234&gt; 10:15-1[1] 9 10 11 12 13 14&gt; 10:(15-1)[1] 10 11 12 13 14 这里需要理解第一个命令的结果（记住循环规则），:的优先级高于减法-。同样，可以利用seq()生成实数序列。比如：12&gt; seq(-4,1,0.5) [1] -4.0 -3.5 -3.0 -2.5 -2.0 -1.5 -1.0 -0.5 0.0 0.5 1.0 生成了一个从-4到1的步长为0.5的一个实数序列。函数seq还有其他的功能。下面举例说明seq的其他功能。123456seq(from=1,to=5,length=4)[1] 1.000000 2.333333 3.666667 5.000000&gt; seq(from=1,to=5,length=2)[1] 1 5&gt; seq(length=10,from = -2,by = 0.2) [1] -2.0 -1.8 -1.6 -1.4 -1.2 -1.0 -0.8 -0.6 -0.4 -0.2 通过上面的例子，我们可以看到我们可以任意指定参数的顺序：但是要先给出参数名，再给出参数值。因此，当我们使用多个参数且大部分参数都采用默认值的函数时，这将非常方便。一旦这些默认参数能满足我们的要求，我们就可以避免人为的设置这些参数。 另一个产生具有某种模式序列的有用的函数时req()函数。比如：12345678&gt; rep(5,10) [1] 5 5 5 5 5 5 5 5 5 5&gt; rep(\"hi\",3)[1] \"hi\" \"hi\" \"hi\"&gt; rep(1:2,3)[1] 1 2 1 2 1 2&gt; rep(1:2,each=3)[1] 1 1 1 2 2 2 gl()函数可用于生成带有因子的序列。这个函数的语法是gl(k,n)，其中k是因子水平的个数，n是每个每个因子水平的重复数。这里举两字例子：123456&gt; gl(3,5) [1] 1 1 1 1 1 2 2 2 2 2 3 3 3 3 3Levels: 1 2 3&gt; gl(2,5,labels=c('female','male')) [1] female female female female female male male male male male Levels: female male 最后R有多个可以根据不同概率密度函数来生成随机序列的函数。这些函数的通用结果是xfunc(n,par1,par2,...),其中，func是概率分布的名称，n是要生成的随机数的个数，par1,par2,...是概率密度函数所需要的一些参数值。例如，可以产生10个服从均值为0，标准差为1的正态分布的随机数值：12&gt; rnorm(10) [1] 1.29219470 -0.38849339 1.88505193 0.48227844 1.23505790 1.49568939 -1.14704749 -0.41806913 -0.09506815 0.73086971 为了获得5个服从自由度为10的t分布的随机变量，可以输入：12&gt; rt(5, df = 10)[1] 1.4049026 -0.5510834 0.1607854 1.4629028 -0.6332299 R还有很多其他的概率函数，以及其他获取概率密度、累计概率和这些分布的分位数函数。 1.2.7 数据子集前面的例证提到，可以在方括号内放入元素的位置来获取向量的某个元素。R也允许在方括号中使用向量。R有很类型的索引向量。逻辑索引向量可以提取相应于真值的元素。123&gt; x&lt;-c(0,-3,4,-1,45,90,-5)&gt; x&gt;0[1] FALSE FALSE TRUE FALSE TRUE TRUE FALSE 上面显示的第二个命令是逻辑条件。由于x是向量，所以将向量中的所有的元素与0进行比较，产生一个长度与向量x相同的逻辑值向量。如果使用该逻辑值向量对x进行索引，就可以得到相应TRUE值位置的向量x的元素。12&gt; x[x&gt;0][1] 4 45 90 利用R中的逻辑运算符，可以使用更复杂的逻辑索引向量。如下：1234&gt; x[x&lt;=2|x&gt;5][1] 0 -3 -1 45 90 -5&gt; x[x&gt;40&amp;x&lt;100][1] 45 90 上面都是简单的逻辑运算。就不再详细解释了。 R还可以使用整数向量来提取向量中的多个元素，索引向量中的数字表示提取的元素在原向量中的位置。例如：123456789&gt; x[1] 0 -3 4 -1 45 90 -5&gt; x[c(4,6)][1] -1 90&gt; x[1:3][1] 0 -3 4&gt; y&lt;-c(1,4)&gt; x[y][1] 0 -1 另外可以使用一个负值的索引表示哪些元素可以排除。例如：123456&gt; x[-1][1] -3 4 -1 45 90 -5&gt; x[-c(4,6)][1] 0 -3 4 45 -5&gt; x[-(1:3)][1] -1 45 90 -5 这里-1表示删除第一个位置上的元素，其他的类似。 可以通过R函数names()来给向量中的元素命名，对于命名的向量元素，可以通过字符串向量来进行索引。由于命名的元素位置更容易进驻，所以有时候更名元素更受欢迎。例如，在5个不同的地方测量了一个化学参数的测量值向量。可以创建如下的命名空间：123456789&gt; pH&lt;-c(4.5,7,7.3,8.2,6.3)&gt; names(pH)&lt;-c('area1','area2','mud','dam','middle')&gt; pH area1 area2 mud dam middle 4.5 7.0 7.3 8.2 6.3&gt; table(pH)pH4.5 6.3 7 7.3 8.2 1 1 1 1 1 实际上，我们可以使用如下的方法进行创建。1234567&gt; pH&lt;-c(area1=4.5,area2=7, mud = 7.3, dam = 8.2, middle = 6.3)&gt; pH['middle']middle 6.3&gt; pH[c('mud','middle')] mud middle 7.3 6.3 1.2.8 矩阵和数组数据元素可以保存在具有多个维度的对象中。在多种情况下这尤其有用，数组存储的是多维数据。矩阵是数组的特殊情况，它具有两个维度。在R中数组和矩阵都是带有维度这个属性的向量。假设一个数值向量c(45,23,66,77,33,44,56,12,78,23),下面要把这10个数值组织为一个矩阵：12345678&gt; m&lt;- c(45,23,66,77,33,44,56,12,78,23)&gt; m [1] 45 23 66 77 33 44 56 12 78 23&gt; dim(m)&lt;-c(2,5)&gt; m [,1] [,2] [,3] [,4] [,5][1,] 45 66 33 56 78[2,] 23 77 44 12 23 注意，数值如何分配到这2行5列的矩阵中。我们还可以使用更简单的命令：12345&gt; m&lt;-matrix(c(45,23,66,77,33,44,56,12,78,23),2,5)&gt; m [,1] [,2] [,3] [,4] [,5][1,] 45 66 33 56 78[2,] 23 77 44 12 23 通过上面的这两个例子，我们注意到向量中的数据通过矩阵的列进行拓展。我们可以通过指定matrix的参数来指定向量以按行的方式进行拓展。12345&gt; m&lt;-m&lt;-matrix(c(45,23,66,77,33,44,56,12,78,23),2,5,byrow = T)&gt; m [,1] [,2] [,3] [,4] [,5][1,] 45 23 66 77 33[2,] 44 56 12 78 23 如矩阵的显示，我们可以通过类似以向量中的索引的方式来访问矩阵的元素。但是现在需要两个索引，因为矩阵至少是二维的。12&gt; m[2,3][1] 12","categories":[{"name":"bigdata","slug":"bigdata","permalink":"http://www.wanqing520.cn/categories/bigdata/"}],"tags":[]},{"title":"Neil | 牛中超--R使用北京的镜像","slug":"bigdata/2016-10-12-R-Using-China-Source","date":"2016-10-12T06:03:14.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201610/12/bigdata/2016-10-12-R-Using-China-Source.html","link":"","permalink":"http://www.wanqing520.cn/201610/12/bigdata/2016-10-12-R-Using-China-Source.html","excerpt":"","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&gt; chooseCRANmirror()HTTPS CRAN mirror 1: 0-Cloud [https] 2: Algeria [https] 3: Austria [https] 4: Belgium (Ghent) [https] 5: Brazil (SP 1) [https] 6: Canada (MB) [https] 7: Chile [https] 8: China (Beijing 4) [https] 9: Colombia (Cali) [https]10: France (Lyon 1) [https] 11: France (Lyon 2) [https] 12: France (Paris 2) [https]13: Germany (Münster) [https] 14: Iceland [https] 15: Italy (Padua) [https]16: Japan (Tokyo) [https] 17: Malaysia [https] 18: Mexico (Mexico City) [https]19: New Zealand [https] 20: Russia (Moscow) [https] 21: Serbia [https]22: Spain (A Coru&lt;U+00F1&gt;a) [https] 23: Spain (Madrid) [https] 24: Switzerland [https]25: UK (Bristol) [https] 26: UK (Cambridge) [https] 27: USA (CA 1) [https]28: USA (KS) [https] 29: USA (MI 1) [https] 30: USA (TN) [https]31: USA (TX) [https] 32: USA (WA) [https] 33: (HTTP mirrors)Selection: 33HTTP CRAN mirror 1: 0-Cloud 2: Algeria 3: Argentina (La Plata) 4: Australia (Canberra) 5: Australia (Melbourne) 6: Austria 7: Belgium (Antwerp) 8: Belgium (Ghent) 9: Brazil (BA)10: Brazil (PR) 11: Brazil (RJ) 12: Brazil (SP 1)13: Brazil (SP 2) 14: Bulgaria 15: Canada (BC)16: Canada (MB) 17: Canada (NS) 18: Canada (ON)19: Chile 20: China (Beijing 4) 21: China (Xiamen)22: Colombia (Cali) 23: Czech Republic 24: Ecuador25: El Salvador 26: Estonia 27: France (Lyon 2)28: France (Marseille) 29: France (Montpellier) 30: France (Paris 2)31: Germany (G&lt;U+00F6&gt;ttingen) 32: Germany (Münster) 33: Greece34: Hungary 35: Iceland 36: India37: Indonesia (Jakarta) 38: Iran 39: Ireland40: Italy (Milano) 41: Italy (Padua) 42: Italy (Palermo)43: Japan (Tokyo) 44: Korea (Seoul 1) 45: Korea (Seoul 2)46: Korea (Ulsan) 47: Lebanon 48: Malaysia49: Mexico (Mexico City) 50: Mexico (Texcoco) 51: Netherlands (Amsterdam)52: Netherlands (Utrecht) 53: New Zealand 54: Norway55: Philippines 56: Poland 57: Portugal (Lisbon)58: Russia (Moscow) 59: Singapore 60: South Africa (Cape Town)61: South Africa (Johannesburg) 62: Spain (A Coru&lt;U+00F1&gt;a) 63: Spain (Madrid)64: Sweden 65: Switzerland 66: Taiwan (Chungli)67: Taiwan (Taipei) 68: Thailand 69: Turkey (Denizli)70: Turkey (Mersin) 71: UK (Bristol) 72: UK (Cambridge)73: UK (London 1) 74: UK (London 2) 75: UK (St Andrews)76: USA (CA 1) 77: USA (CA 2) 78: USA (IA)79: USA (IN) 80: USA (KS) 81: USA (MI 1)82: USA (MO) 83: USA (NC) 84: USA (OH 1)85: USA (OH 2) 86: USA (OR) 87: USA (PA 1)88: USA (PA 2) 89: USA (TN) 90: USA (TX)91: USA (WA) 92: VenezuelaSelection: 20","categories":[{"name":"bigdata","slug":"bigdata","permalink":"http://www.wanqing520.cn/categories/bigdata/"}],"tags":[]},{"title":"Neil | 牛中超--易企秀如何开启伪静态支持？ 一秀如何开启伪静态","slug":"php/2016-10-12-yiqixiu-use-php-rewrite","date":"2016-10-12T06:03:14.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201610/12/php/2016-10-12-yiqixiu-use-php-rewrite.html","link":"","permalink":"http://www.wanqing520.cn/201610/12/php/2016-10-12-yiqixiu-use-php-rewrite.html","excerpt":"","text":"导读易企秀如何开启伪静态支持？ 一秀如何开启伪静态？ 下载易企秀源码oschina: http://git.oschina.net/jsper/html5Editor Windows下搭建环境 安卓phpstudy 导入数据库数据库文件是：ewesambo.sql 修改html5Editor项目下的配置文件： 这里写图片描述 修改systemConfig.php的内容，数据库地址，数据库库名，用户名和密码 这里写图片描述 在html5Editor根目录下编写重定向文件.htaccess文件，文件内容如下： 12345678&lt;IfModule mod_rewrite.c&gt; Options +FollowSymlinks RewriteEngine On RewriteCond %&#123;REQUEST_FILENAME&#125; !-d RewriteCond %&#123;REQUEST_FILENAME&#125; !-f RewriteRule ^(.*)$ index.php/$1 [QSA,PT,L]&lt;/IfModule&gt; 启动phpstudy的mysql和apache服务器就可访问了 linux下的nginx配置 安装mysql +nginx +mysql-php 等环境，具体的自行百度。 将项目放置在www目录或者html目录下 编辑/usr/local/nginx/conf/nginx.conf文件示例如下：注意，下面的示例是针对外网访问的，如果是本地测试的话，请修改localhost的server配置 1234567891011121314151617181920212223242526272829303132333435363738server &#123; listen 80; server_name wanqi520.cn; # 这里换成你自己的域名 # 下面的if语句是为了支持thinkphp的重定向，URL_MODE使用的是2 if (!-e $request_filename) &#123; rewrite ^(.*)$ /index.php?s=$1 last; break; &#125; #if # 下面的语句制定html5Editor的根目录 root /usr/local/nginx/html; index index.php; charset utf-8; #include /usr/local/nginx/html/.htaccess; location ~ \\.php$ &#123; fastcgi_index index.php;# fastcgi_pass unix:/var/run/php5-fpm.sock; fastcgi_pass 127.0.0.1:9000; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125; location ~ /phpmyadmin &#123; root /data/www/phpmyadmin; index index.php; &#125; location ~ /phpmyadmin/.+\\.php$ &#123; if ($fastcgi_script_name ~ /phpmyadmin/(.+\\.php.*)$) &#123; set $valid_fastcgi_script_name $1; &#125; include fastcgi_params; fastcgi_pass 127.0.0.1:9000; fastcgi_param SCRIPT_FILENAME /data/www/phpmyadmin/$valid_fastcgi_script_name; &#125; &#125; 同样的需要更改systemConfig.php文件，以及导入数据库。 这样就应该可以访问了","categories":[{"name":"php","slug":"php","permalink":"http://www.wanqing520.cn/categories/php/"}],"tags":[]},{"title":"Neil | 牛中超--Pseudo-class（伪类）、Pseudo-Element（伪元素）简要记录","slug":"java/2016-4-29-Pseudo-class-Pseudo-Element","date":"2016-05-03T08:47:14.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201605/03/java/2016-4-29-Pseudo-class-Pseudo-Element.html","link":"","permalink":"http://www.wanqing520.cn/201605/03/java/2016-4-29-Pseudo-class-Pseudo-Element.html","excerpt":"","text":"伪类、伪元素配合CSS3可以完成非常多有意思的效果，为方便个人开发时候的快速查阅，记录了以下常用到的一些伪类伪元素的简要中文说明； 简单区分： :Pseudo-classes 伪类:DOM在不同状态、不同位置下的特殊效果； ::Pseudo-elements 伪元素：DOM按匹配规则伪造出的元素； 注意点： 伪类添加的内容元素或伪类效果通在DOM的源代码中是看不见的，需要借助开发者工具才能看见; 使用屏幕阅读器等设备无法访问和读取伪元素生成的内容。因此不应该使用伪元素来添加正文内容等重要信息到页面上展示，应确保主体内容的完整性。 伪类添加的元素也可以使用CSS样式进行控制,具体查看下面浏览器的兼容性； content方式可以添加的图片、unicode、字符串；其中图片不能调整大小，要选择合适的图片; 伪元素是在DOM内容生成之后添加的，它将被堆积在DOM的父元素的顶上； 伪元素由双冒号和伪元素名称组成，为了兼容使用单冒号的伪类也有效； 伪类添加的内容和元素不能使用任何Javascript的事件处理程序； js获取伪类的值：win.getComputedStyle(doc.querySelector(‘.element’), ‘:before’).getPropertyValue(‘color’) Browser Support 具体浏览器兼容性可以使用 Can I Use 或 MDN CSS Browser Support 常用伪元素、伪类列表::after 在元素的内容之后 ::before 在元素的内容之前 ::first-line 元素的第一行 ::first-letter 元素的第一个字母 ::placeholder 占位符，用于input输入框之类的提醒 ::selection 被选取的元素，用于改变网页被选中部分的效果 :active 当元素被点击的时 :blank 空白的元素 :checked 被选中的元素 :default 默认被选中或默认会被提交的元素 :dir() 匹配特定文字书写方向的元素 :disabled 处于被禁止操作状态的元素 :empty 没有任何内容的元素 :enabled 处于可操作状态的元素 :first 用于打印文档的第一页 :first-child 父级元素下的第一个子元素 :first-of-type 父级元素下的第一个同类子元素 :focus 当元素成为焦点 :fullscreen 当元素被HTML5 API调用RequestFullscreen方式全屏时 :hover 当鼠标移动到链接元素上面时 :in-range 当元素属性值处于其指定的范围内时 :indeterminate 当元素属性值处于不确定状态的 :invalid 当元素属性值不是指定的type属性时 :lang() 匹配有正确lang 属性值的元素，如 lang(zh-Hans) :last-child 元素的最后一个子元素 :last-of-type 元素的最后一个同类子元素 :left 选择打印文档的左侧页 :link 未被访问的链接元素 :not() 否定选择器（不匹配条件则生效） :nth-child() 元素的一个或多个特定的子元素 :nth-last-child() 元素的一个或多个特定的子元素，从该元素的最后一个子元素开始算； :nth-of-type() 选择指定的元素 :nth-last-of-type() 选择指定的元素，从元素的最后一个开始计算 :only-child 元素是它的父元素的唯一子元素 :only-of-type 元素是它的父级元素的唯一一个相同类型的子元素 :optional 未指定required属性的表单元素 :out-of-range 超出规定值范围的元素 :read-only 元素设置了 &apos;readonly&apos; 属性生效 :read-write 元素没有 &quot;readonly&quot; 属性生效 :required 设置了 &quot;required&quot; 属性的元素 :right 选择打印文档的左侧页 :root 文档的根元素 :scope 作用域的伪类，默认为HTML（案例 :scope #mammma {...}） :target 当前活动的元素（匹配页面URI中对应的目标元素） :valid 表示有效的元素 :visited 已被访问过的元素 content 在元素之前或之后添加的内容。 Related Entries Pseudo-elements Fullscreen API :scope","categories":[{"name":"java","slug":"java","permalink":"http://www.wanqing520.cn/categories/java/"}],"tags":[]},{"title":"Neil | 牛中超--Git 简单使用说明","slug":"git/2015-12-14-instruction-Git","date":"2015-12-13T16:47:14.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201512/14/git/2015-12-14-instruction-Git.html","link":"","permalink":"http://www.wanqing520.cn/201512/14/git/2015-12-14-instruction-Git.html","excerpt":"","text":"/* Name: UED Git 简单使用说明 Author:markyun Create Date:2014-10-18 */ 1安装msysgit： msysgit是Windows版的Git，从http://msysgit.github.io/下载，然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 2 配置用户名： git config --global user.name &quot;Your Name&quot; git config --global user.email &quot;email@example.com&quot; 3、创建仓库（或者 克隆一个远程仓库 ）： git init Initialized empty Git repository in /Users/michael/learngit/.git/ （告诉你是一个空的仓库） 请确保目录名（包括父目录）不包含中文 4、添加文件到仓库： 把文件（readme.txt）放在创建的仓库内 git add readme.txt //可反复多次使用， 添加多个文件； git add . （.）点表示当前目录下的所有内容，交给git管理，也就是提交到了git的本地仓库。用命令git commit告诉Git，把文件提交到仓库： git commit -m &quot;Update README.md, add the front-end interview questions &quot; [master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 5、修改文件后，更新仓库 git status 查看仓库当前的状态， 告诉我们，什么文件被修改过了，但还没有准备提交的修改。 git diff 文件名， 查看具体修改了什么内容 git add 文件名 更新和添加一样 git commit 6、版本回退： 先 git log 添加的注释 也可以：git reflog 记录你的每一次添加命令和注释 和commit_id： 只回到上一个版本就是HEAD^， git reset --hard HEAD^ 上上一个版本就是HEAD^^ git reset –hard HEAD^^ git reset --hard commit_id。 7、暂存区 Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。第一次修改 -&gt; add -&gt; 第二次修改 -&gt; add -&gt; commit 只会提交第一次的修改内容到主分支 8、撤销提交操作（add） git checkout -- readme.txt //（--很重要，没有--，就变成了“创建一个新分支”的命令） 把readme.txt文件在工作区的修改全部撤销，这里有两种情况：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令 git checkout -- file 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步， 第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作 二是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到【最近一次git commit后】 或【git add之前】的状态； 假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？ 可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。 9、删除文件 git rm test.txt rm &apos;test.txt&apos; m &quot;remove test.txt&quot; git commit - //如果删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： git checkout -- test.txt 10、设置SSH Key 由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要SSH Key 默认存放在 C:\\Users\\Administrator.ssh id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 ssh-keygen -t rsa -C “mygood@126.com&quot; 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 11、绑定到远程仓库 （注意格式的gitlab，不支持ssh，请使用http） 关联一个远程库 git remote add origin git@github.com:markyun/beilibao.git 远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 12、推送到远程仓库 git remote -v //查看你当前项目远程连接的是哪个仓库地址。 git push -u origin master //将本地的项目提交到远程仓库中。 正常情况下这样显示： git push -u origin master Counting objects: 19, done. o 4 threads. Compressing objects: 100% ( Delta compression using up t19/19), done. Writing objects: 100% (19/19), 13.73 KiB, done. lliao/learngit.git * [new branch] Total 23 (delta 6), reused 0 (delta 0) To git@github.com:micha e master -&gt; master to track remote branch master from origin. Branch master set u p 如果提示： ssh:connect to host github.com port 22:bad file number could not read from remote repository （说不能读取远端库，请确保有正确的访问权限并且仓库存在。看看你本机22端口有没有打开） ssh github.com 测试是否能正常使用SSH 当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established. RSA key fingerprint is xx.xx.xx.xx.xx. cting (yes/no)? Are you sure you want to continue conn e 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 13、从服务器上把一个远程仓库中的工程完全的拷贝下来 git clone git@github.com:china-UED/test.git 假如本地已经存在了这个项目，而仓库中又有一新的更新，如何把更的合并到本地的项目中？ git fetch origin //取得远程更新，这里可以看做是准备要取了 git merge origin/master //把更新的内容合并到本地分支/master —————-待补充————– 14、创建与合并分支 15、冲突的处理 16、多人协作 17、其他 git config --list 查看配置 git config --global core.autocrlf false 关闭 github的换行符自动转换”功能 补充 Git 命令快速查询表 命令 简要说明 git add 添加至暂存区 git add–interactive 交互式添加 git apply 应用补丁 git am 应用邮件格式补丁 git annotate 同义词，等同于 git blame git archive 文件归档打包 git bisect 二分查找 git blame 文件逐行追溯 git branch 分支管理 git cat-file 版本库对象研究工具 git checkout 检出到工作区、切换或创建分支 git cherry-pick 提交拣选 git citool 图形化提交，相当于 git gui 命令 git clean 清除工作区未跟踪文件 git clone 克隆版本库 git commit 提交 git config 查询和修改配置 git describe 通过里程碑直观地显示提交ID git diff 差异比较 git difftool 调用图形化差异比较工具 git fetch 获取远程版本库的提交 git format-patch 创建邮件格式的补丁文件。参见 git am 命令 git grep 文件内容搜索定位工具 git gui 基于Tcl/Tk的图形化工具，侧重提交等操作 git help 帮助 git init 版本库初始化 git init-db* 同义词，等同于 git init git log 显示提交日志 git merge 分支合并 git mergetool 图形化冲突解决 git mv 重命名 git pull 拉回远程版本库的提交 git push 推送至远程版本库 git reBase 分支变基 git rebase–interactive 交互式分支变基 git reflog 分支等引用变更记录管理 git remote 远程版本库管理 git repo-config* 同义词，等同于 git config git reset 重置改变分支“游标”指向 git rev-parse 将各种引用表示法转换为哈希值等 git revert 反转提交 git rm 删除文件 git show 显示各种类型的对象 git stage* 同义词，等同于 git add git stash 保存和恢复进度 git status 显示工作区文件状态 git tag 里程碑管理 2、对象库操作相关命令 命令 简要说明 git commit-tree 从树对象创建提交 git hash-object 从标准输入或文件计算哈希值或创建对象 git ls-files 显示工作区和暂存区文件 git ls-tree 显示树对象包含的文件 git mktag 读取标准输入创建一个里程碑对象 git mktree 读取标准输入创建一个树对象 git read-tree 读取树对象到暂存区 git update-index 工作区内容注册到暂存区及暂存区管理 git unpack-file 创建临时文件包含指定 blob 的内容 git write-tree 从暂存区创建一个树对象 3、引用操作相关命令 命令 简要说明 git check-ref-format 检查引用名称是否符合规范 git for-each-ref 引用迭代器，用于shell编程 git ls-remote 显示远程版本库的引用 git name-rev 将提交ID显示为友好名称 git peek-remote* 过时命令，请使用 git ls-remote git rev-list 显示版本范围 git show-branch 显示分支列表及拓扑关系 git show-ref 显示本地引用 git symbolic-ref 显示或者设置符号引用 git update-ref 更新引用的指向 git verify-tag 校验 GPG 签名的Tag 4、版本库管理相关命令 命令 简要说明 git count-objects 显示松散对象的数量和磁盘占用 git filter-branch 版本库重构 git fsck 对象库完整性检查 git fsck-objects* 同义词，等同于 git fsck git gc 版本库存储优化 git index-pack 从打包文件创建对应的索引文件 git lost-found* 过时，请使用 git fsck –lost-found 命令 git pack-objects 从标准输入读入对象ID，打包到文件 git pack-redundant 查找多余的 pack 文件 git pack-refs 将引用打包到 .git/packed-refs 文件中 git prune 从对象库删除过期对象 git prune-packed 将已经打包的松散对象删除 git relink 为本地版本库中相同的对象建立硬连接 git repack 将版本库未打包的松散对象打包 git show-index 读取包的索引文件，显示打包文件中的内容 git unpack-objects 从打包文件释放文件 git verify-pack 校验对象库打包文件 5、数据传输相关命令 命令 简要说明 git fetch-pack 执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象 git receive-pack 执行 git push 命令时在远程执行的命令，用于接受推送的数据 git send-pack 执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据 git upload-archive 执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档 git upload-pack 执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传 6、邮件相关命令 命令 简要说明 git imap-send 将补丁通过 IMAP 发送 git mailinfo 从邮件导出提交说明和补丁 git mailsplit 将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件 git request-pull 创建包含提交间差异和执行PULL操作地址的信息 git send-email 发送邮件 7、协议相关命令 命令 简要说明 git daemon 实现Git协议 git http-backend 实现HTTP协议的CGI程序，支持智能HTTP协议 git instaweb 即时启动浏览器通过 gitweb 浏览当前版本库 git shell 受限制的shell，提供仅执行Git命令的SSH访问 git update-server-info 更新哑协议需要的辅助文件 git http-fetch 通过HTTP协议获取版本库 git http-push 通过HTTP/DAV协议推送 git remote-ext 由Git命令调用，通过外部命令提供扩展协议支持 git remote-fd 由Git命令调用，使用文件描述符作为协议接口 git remote-ftp 由Git命令调用，提供对FTP协议的支持 git remote-ftps 由Git命令调用，提供对FTPS协议的支持 git remote-http 由Git命令调用，提供对HTTP协议的支持 git remote-https 由Git命令调用，提供对HTTPS协议的支持 git remote-testgit 协议扩展示例脚本 8、版本库转换和交互相关命令 命令 简要说明 git archimport 导入Arch版本库到Git git bundle 提交打包和解包，以便在不同版本库间传递 git cvsexportcommit 将Git的一个提交作为一个CVS检出 git cvsimport 导入CVS版本库到Git。或者使用 cvs2git git cvsserver Git的CVS协议模拟器，可供CVS命令访问Git版本库 git fast-export 将提交导出为 git-fast-import 格式 git fast-import 其他版本库迁移至Git的通用工具 git svn Git 作为前端操作 Subversion 9、合并相关的辅助命令 命令 简要说明 git merge-base 供其他脚本调用，找到两个或多个提交最近的共同祖先 git merge-file 针对文件的两个不同版本执行三向文件合并 git merge-index 对index中的冲突文件调用指定的冲突解决工具 git merge-octopus 合并两个以上分支。参见 git merge 的octopus合并策略 git merge-one-file 由 git merge-index 调用的标准辅助程序 git merge-ours 合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略 git merge-recursive 针对两个分支的三向合并。参见 git merge 的recursive合并策略 git merge-resolve 针对两个分支的三向合并。参见 git merge 的resolve合并策略 git merge-subtree 子树合并。参见 git merge 的 subtree 合并策略 git merge-tree 显式三向合并结果，不改变暂存区 git fmt-merge-msg 供执行合并操作的脚本调用，用于创建一个合并提交说明 git rerere 重用所记录的冲突解决方案 10、 杂项 命令 简要说明 git bisect–helper 由 git bisect 命令调用，确认二分查找进度 git check-attr 显示某个文件是否设置了某个属性 git checkout-index 从暂存区拷贝文件至工作区 git cherry 查找没有合并到上游的提交 git diff-files 比较暂存区和工作区，相当于 git diff –raw git diff-index 比较暂存区和版本库，相当于 git diff –cached –raw git diff-tree 比较两个树对象，相当于 git diff –raw A B git difftool–helper 由 git difftool 命令调用，默认要使用的差异比较工具 git get-tar-commit-id 从 git archive 创建的 tar 包中提取提交ID git gui–askpass 命令 git gui 的获取用户口令输入界面 git notes 提交评论管理 git patch-id 补丁过滤行号和空白字符后生成补丁唯一ID git quiltimport 将Quilt补丁列表应用到当前分支 git replace 提交替换 git shortlog 对 git log 的汇总输出，适合于产品发布说明 git stripspace 删除空行，供其他脚本调用 git submodule 子模组管理 git tar-tree 过时命令，请使用 git archive git var 显示 Git 环境变量 git web–browse 启动浏览器以查看目录或文件 git whatchanged 显示提交历史及每次提交的改动 git-mergetool–lib 包含于其他脚本中，提供合并/差异比较工具的选择和执行 git-parse-remote 包含于其他脚本中，提供操作远程版本库的函数 git-sh-setup 包含于其他脚本中，提供 shell 编程的函数库 git-guide 南京","categories":[{"name":"git","slug":"git","permalink":"http://www.wanqing520.cn/categories/git/"}],"tags":[]},{"title":"Neil | 牛中超--UED团队前端自动化构建环境的搭建","slug":"fontend/2015-12-18-The-front-end-code-build-automated-build-environment","date":"2015-12-09T16:00:00.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201512/10/fontend/2015-12-18-The-front-end-code-build-automated-build-environment.html","link":"","permalink":"http://www.wanqing520.cn/201512/10/fontend/2015-12-18-The-front-end-code-build-automated-build-environment.html","excerpt":"","text":"为了UED前端团队更好的协作开发同时提高项目编码质量，我们需要将Web前端使用工程化方式构建； 目前需要一些简单的功能： 1. 版本控制 6. 编译SASS 2. 检查JS 3. 图片合并 4. 压缩CSS 5. 压缩JS 这些都是每个Web项目在构建、开发阶段需要做的事情。前端自动化构建环境可以把这些重复工作一次配置，多次重复执行，极大的提高开发效率。 目前最知名的构建工具： Gulp、Grunt、NPM + Webpack； grunt是前端工程化的先驱 gulp更自然基于流的方式连接任务 Webpack最年轻，擅长用于依赖管理，配置稍较复杂 推荐使用Gulp，Gulp基于nodejs中stream，效率更好语法更自然,不需要编写复杂的配置文件 Use Gulp to automate front-end build tasksGulp是基于 Node.js的，需要要安装 Node.js 1、为了确保依赖环境正确，我们先执行几个简单的命令检查。 node -v Node是一个基于Chrome JavaScript V8引擎建立的一个解释器 检测Node是否已经安装，如果正确安装的话你会看到所安装的Node的版本号 2、接下来看看npm，它是 node 的包管理工具，可以利用它安装 gulp 所需的包 npm -v 这同样能得到npm的版本号，装 Node 时已经自动安装了npm 3、开始安装Gulp npm install -g gulp 全局安装 gulp gulp -v 得到gulp的版本号，确认安装成功 基础安装结束- 4、切换到你的在项目根文件夹下，运行 npm install gulp --save-dev //将具体的gulp功能插件局部安装项目下 5、安装gulp功能插件依赖包 npm install gulp-jshint gulp-sass gulp-concat gulp-uglify gulp-rename--save-dev gulp功能模块的文件会放在项目所在的目录的./node_modules 下 6、我们目前先使用一些简单的功能： - 检查Javascript - 编译Sass文件 - 合并Javascript - 压缩合并并重命名Javascript 新建gulpfile.js 配置文件放在项目根目录下 演示项目目录结构 testProject (项目名称) |–.git 通过git进行版本控制,项目自动生成这个文件 |–node_modules 组件包目录 |–dist **发布环境**（编译自动生成的） |–css 样式文件(style.css style.min.css) |–images 图片文件(压缩图片\\合并后的图片) |–js js文件(main.js main.min.js) |–index.html 静态页面文件(压缩html) |–src **开发环境** |–sass sass文件 |–images 图片文件 |–js js文件 |–index.html 静态文件 |–gulpfile.js gulp配置文件 |–package.json 依赖模块json文件,在项目目录下npm install会安装项目所有的依赖模块，简化项目的安装程序 现在，项目文件夹都建好，组件也安装完毕了，我们需要编写gulpfile.js文件以指定gulp需要为我们完成什么任务。 gulpfile.js内容如下： // 引入gulp var gulp = require(&apos;gulp&apos;); // 引入组件 var jshint = require(&apos;gulp-jshint&apos;);//检查js var sass = require(&apos;gulp-sass&apos;); //编译Sass var concat = require(&apos;gulp-concat&apos;);//合并 var uglify = require(&apos;gulp-uglify&apos;);//uglify 组件（用于压缩 JS） var rename = require(&apos;gulp-rename&apos;);//重命名 // 检查js脚本的任务 gulp.task(&apos;lint&apos;, function() { gulp.src(&apos;./js/*.js&apos;) //可配置你需要检查脚本的具体名字。 .pipe(jshint()) .pipe(jshint.reporter(&apos;default&apos;)); }); // 编译Sass gulp.task(&apos;sass&apos;, function() { gulp.src(&apos;./scss/*.scss&apos;) .pipe(sass()) .pipe(gulp.dest(&apos;./css&apos;));//dest()写入文件 }); // 合并，压缩js文件 // 找到 js/ 目录下的所有 js 文件，压缩，重命名，最后将处理完成的js存放在 dist/js/ 目录下 gulp.task(&apos;scripts&apos;, function() { gulp.src(&apos;./js/*.js&apos;) .pipe(concat(&apos;all.js&apos;)) .pipe(gulp.dest(&apos;./dist&apos;)) .pipe(rename(&apos;all.min.js&apos;)) .pipe(uglify()) .pipe(gulp.dest(&apos;./dist&apos;)); console.log(&apos;gulp task is done&apos;);//自定义提醒信息 }); .... // 其他任务类似 // 定义默认任务,执行gulp会自动执行的任务 gulp.task(&apos;default&apos;, function(){ gulp.run(&apos;lint&apos;, &apos;sass&apos;, &apos;scripts&apos;); // 监听js文件变化，当文件发生变化后会自动执行任务 gulp.watch(&apos;./js/*.js&apos;, function(){ gulp.run(&apos;lint&apos;,&apos;scripts&apos;); }); }); 7、现在，回到命令行窗口，可以直接运行gulp任务了。 gulp 这将执行定义的default任务，就和以下的命令式同一个意思 gulp default 当然，我们可以运行在gulpfile.js中定义的任意任务，比如，现在单独运行sass任务： gulp sass 8、编译会显示Finished,如果你的JS有什么不好的地方它会提醒，避免一些不必要的错误，十分贴心 常见提醒： 1.禁止在同一行声明多个变量。 2.请使用 ===/!==来比较true/false或者数值 3.使用对象字面量替代new Array这种形式 4.不要使用全局函数。 5.Switch语句必须带有default分支 6.函数不应该有时候有返回值，有时候没有返回值。 7.For循环必须使用大括号 8.If语句必须使用大括号 9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。 9、gulp的插件数量很多，后面还可以根据自己的需要进行添加任务 常用的gulp插件参考 gulp-imagemin: 压缩图片 gulp-ruby-sass: 支持sass，安装此版本需要安装ruby gulp-minify-css: 压缩css gulp-jshint: 检查js gulp-uglify: 压缩js gulp-concat: 合并文件 gulp-rename: 重命名文件 gulp-htmlmin: 压缩html gulp-clean: 清空文件夹 gulp-livereload: 服务器控制客户端同步刷新（需配合chrome插件LiveReload及tiny-lr） Use Git as a project management tool安装git， 下载安装包会安装好 Git Shell 和可视化环境 http://git-scm.com/download/win 配置用户名： git config --global user.name &quot;Your Name&quot; git config --global user.email &quot;email@example.com&quot; 关联一个到团队的库 git remote add origin git@github.com:markyun/My-blog.git 添加文件到仓库，添加全部文件用 . 表示 git add . 把文件提交到仓库 git commit -m &quot; first add project file&quot; 提交文件到团队仓库 git push -u origin master //将本地的项目提交到远程仓库中。 以上就完成了前端团队最基本的开发环境搭建和代码提交工作流程。 补充：ZSmart UED Team 的前端开发软件环境 (Windows, Linux, Mac OS X) 安装Node.Js、NPM、Ruby、Java 基础环境 Sublime Text3 + 插件 用于编写前端代码 Google chrome 、Mozilla Firefox + Firebug Internet Explorer 进行兼容测试和预览页面UI、动画效果和交互功能 Node.js+Gulp 进行前端自动化构建、JS语法验证、CSS压缩，图片压缩等； Koala 实时编译Less、Sass、Compass、CoffeeScript; Github 存储自己的代码库 、git或SVN用于版本控制和团队Code Review Tomcat、DedeAMPZ、MAMP 进行简单运行环境演示 Photoshop CC 切图 + Sprites 合并小图标 XMind 画出清晰的工作或业务逻辑思维图 （待补充…）","categories":[{"name":"frontend","slug":"frontend","permalink":"http://www.wanqing520.cn/categories/frontend/"}],"tags":[]},{"title":"Neil | 牛中超--Front End Developer Questions","slug":"fontend/2015-9-9-Front-end-Developer-Questions","date":"2015-09-10T11:18:00.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201509/10/fontend/2015-9-9-Front-end-Developer-Questions.html","link":"","permalink":"http://www.wanqing520.cn/201509/10/fontend/2015-9-9-Front-end-Developer-Questions.html","excerpt":"","text":"目录 前言 HTML部分 CSS部分 JavaScript部分 其他问题 前端学习网站推荐 前言 前言 HTML Doctype作用？严格模式与混杂模式如何区分？它们有何意义? HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 页面导入样式时，使用link和@import有什么区别？ 介绍一下你对浏览器内核的理解？ 常见的浏览器内核有哪些？ html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和HTML5？ 简述一下你对HTML语义化的理解？ HTML5的离线储存怎么使用，工作原理能不能解释一下？ 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？ 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ iframe有那些缺点？ Label的作用是什么？是怎么用的？（加 for 或 包裹） HTML5的form如何关闭自动完成功能？ 如何实现浏览器内多个标签页之间的通信? (阿里) webSocket如何兼容低浏览器？(阿里) 页面可见性（Page Visibility）API 可以有哪些用途？ 如何在页面上实现一个圆形的可点击区域？ 实现不使用 border 画出1px高的线，在不同浏览器的Quirksmode和CSSCompat模式下都能保持同一效果。 网页验证码是干嘛的，是为了解决什么安全问题？ tite与h1的区别、b与strong的区别、i与em的区别？ CSS 介绍一下标准的CSS的盒子模型？与低版本IE的盒子模型有什么不同的？ CSS选择符有哪些？哪些属性可以继承？ CSS优先级算法如何计算？ CSS3新增伪类有那些？ 如何居中div？如何居中一个浮动元素？如何让绝对定位的div居中？ display有哪些值？说明他们的作用。 position的值relative和absolute定位原点是？ CSS3有哪些新特性？ 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？ 用纯CSS创建一个三角形的原理是什么？ 一个满屏 品 字布局 如何设计? 常见兼容性问题？ li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？ 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？ 为什么要初始化CSS样式。 absolute的containing block计算方式跟正常流有什么不同？ CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？ position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？ 对BFC规范(块级格式化上下文：block formatting context)的理解？ CSS权重优先级是如何计算的？ 请解释一下为什么会出现浮动和什么时候需要清除浮动？清除浮动的方式 移动端的布局用过媒体查询吗？ 使用 CSS 预处理器吗？喜欢那个？ CSS优化、提高性能的方法有哪些？ 浏览器是怎样解析CSS选择器的？ 在网页中的应该使用奇数还是偶数的字体？为什么呢？ margin和padding分别适合什么场景使用？ 抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题] 元素竖向的百分比设定是相对于容器的高度吗？ 全屏滚动的原理是什么？用到了CSS的那些属性？ 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？ 视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？） ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。 如何修改chrome记住密码后自动填充表单的黄色背景 ？ 你对line-height是如何理解的？ 设置元素浮动后，该元素的display值是多少？（自动变成display:block） 怎么让Chrome支持小于12px 的文字？ 让页面里的字体变清晰，变细用CSS怎么做？（-webkit-font-smoothing: antialiased;） font-style属性可以让它赋值为“oblique” oblique是什么意思？ position:fixed;在android下无效怎么处理？ 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） display:inline-block 什么时候会显示间隙？(携程) overflow: scroll时不能平滑滚动的问题怎么处理？ 有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。 png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？ 什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做） style标签写在body后与body前有什么区别？ JavaScript 介绍JavaScript的基本数据类型。 说说写JavaScript的基本规范？ JavaScript原型，原型链 ? 有什么特点？ JavaScript有几种类型的值？（堆：原始数据类型和 栈：引用数据类型），你能画一下他们的内存图吗？ Javascript如何实现继承？ Javascript创建对象的几种方式？ Javascript作用链域? 谈谈This对象的理解。 eval是做什么的？ 什么是window对象? 什么是document对象? null，undefined的区别？ 写一个通用的事件侦听器函数(机试题)。 [“1”, “2”, “3”].map(parseInt) 答案是多少？ 关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 什么是闭包（closure），为什么要用它？ javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ 如何判断一个对象是否属于某个类？ new操作符具体干了什么呢? 用原生JavaScript的实现过什么功能吗？ Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？ 对JSON的了解？ [].forEach.call($$(&quot;*&quot;),function(a){ a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16) }) 能解释一下这段代码的意思吗？ js延迟加载的方式有哪些？ Ajax 是什么? 如何创建一个Ajax？ 同步和异步的区别? 如何解决跨域问题? 页面编码和被请求的资源编码如果不一致如何处理？ 模块化开发怎么做？ AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？ requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？） 让你自己设计实现一个requireJS，你会怎么做？ 谈一谈你对ECMAScript6的了解？ ECMAScript6 怎么写class么，为什么会出现class这种东西? 异步加载的方式有哪些？ documen.write和 innerHTML的区别? DOM操作——怎样添加、移除、移动、复制、创建和查找节点? .call() 和 .apply() 的含义和区别？ 数组和对象有哪些原生方法，列举一下？ JS 怎么实现一个类。怎么实例化这个类 JavaScript中的作用域与变量声明提升？ 如何编写高性能的Javascript？ 那些操作会造成内存泄漏？ JQuery的源码看过吗？能不能简单概况一下它的实现原理？ jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？ jquery中如何将数组转化为json字符串，然后再转化回来？ jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？ jquery.extend 与 jquery.fn.extend的区别？ jQuery 的队列是如何实现的？队列可以用在哪些地方？ 谈一下Jquery中的bind(),live(),delegate(),on()的区别？ JQuery一个对象可以同时绑定多个事件，这是如何实现的？ 是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？ jQuery 是通过哪个方法和 Sizzle 选择器结合的？（jQuery.fn.find()进入Sizzle） 针对 jQuery性能的优化方法？ Jquery与jQuery UI有啥区别？ JQuery的源码看过吗？能不能简单说一下它的实现原理？ jquery 中如何将数组转化为json字符串，然后再转化回来？ jQuery和Zepto的区别？各自的使用场景？ 针对 jQuery 的优化方法？ Zepto的点透问题如何解决？ jQueryUI如何自定义组件? 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？ 如何判断当前脚本运行在浏览器还是node环境中？（阿里） 移动端最小触控区域是多大？ jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢? 把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？ 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。） 知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么? Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？ 解释JavaScript中的作用域与变量声明提升？ 那些操作会造成内存泄漏？ JQuery一个对象可以同时绑定多个事件，这是如何实现的？ Node.js的适用场景？ (如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么? 解释一下 Backbone 的 MVC 实现方式？ 什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点? 知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么? 如何测试前端代码么? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)? 前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用? 简述一下 Handlebars 的基本用法？ 简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？ 用js实现千位分隔符?(来源：前端农民工，提示：正则+replace) 检测浏览器版本版本有哪些方式？ 我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡，你来说下会执行几次事件，然后会先执行冒泡还是捕获 其他问题 原来公司工作流程是怎么样的，如何与其他人协作的？如何夸部门合作的？ 你遇到过比较难的技术问题是？你是如何解决的？ 设计模式 知道什么是singleton, factory, strategy, decrator么? 常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？ 页面重构怎么操作？ 列举IE与其他浏览器不一样的特性？ 99%的网站都需要被重构是那本书上写的？ 什么叫优雅降级和渐进增强？ 是否了解公钥加密和私钥加密。 WEB应用从服务器主动推送Data到客户端有那些方式？ 对Node的优点和缺点提出了自己的看法？ 你有用过哪些前端性能优化的方法？ http状态码有那些？分别代表是什么意思？ 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好） 部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？ 从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决? 除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？ 你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？ 对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？ 你怎么看待Web App 、hybrid App、Native App？ 你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？） 你对加班的看法？ 平时如何管理你的项目？ 说说最近最流行的一些东西吧？常去哪些网站？ 如何设计突发大规模并发架构？ 说说最近最流行的一些东西吧？常去哪些网站？ 是否了解开源的工具 bower、npm、yeoman、grunt、gulp，一个 npm 的包里的 package.json 具备的必要的字段都有哪些？（名称、版本号，依赖） 每个模块的代码结构都应该比较简单，且每个模块之间的关系也应该非常清晰，随着功能和迭代次数越来越多，你会如何去保持这个状态的？ Git知道branch, diff, merge么? 如何设计突发大规模并发架构？ 当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？ 说说最近最流行的一些东西吧？平时常去哪些网站？ 知道什么是SEO并且怎么优化么? 知道各种meta data的含义么? 移动端（Android IOS）怎么做好用户体验? 简单描述一下你做过的移动APP项目研发流程？ 你在现在的团队处于什么样的角色，起到了什么明显的作用？ 你认为怎样才是全端工程师（Full Stack developer）？ 介绍一个你最得意的作品吧？ 你有自己的技术博客吗，用了哪些技术？ 对前端安全有什么看法？ 是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？ 项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。 最近在学什么东西？ 你的优点是什么？缺点是什么？ 如何管理前端团队? 最近在学什么？能谈谈你未来3，5年给自己的规划吗？ 有趣的问题 .A、B两人分别在两座岛上。B生病了，A有B所需要的药。C有一艘小船和一个可以上锁的箱子。C愿意在A和B之间运东西，但东西只能放在箱子里。只要箱子没被上锁，C都会偷走箱子里的东西，不管箱子里有什么。如果A和B各自有一把锁和只能开自己那把锁的钥匙，A应该如何把东西安全递交给B？ 答案：A把药放进箱子，用自己的锁把箱子锁上。B拿到箱子后，再在箱子上加一把自己的锁。 箱子运回A后，A取下自己的锁。箱子再运到B手中时，B取下自己的锁，获得药物。 Amazon主页的左上角有一个商品分类浏览的下拉菜单 没有延迟，而且子菜单也不会在不应该的时候消失。它是怎样做到这一点的呢？ 答案是通过探测鼠标移动的方向和轨迹，具体查看Khan Academy工程师 Ben Kamens 写的 jQuery插件 这是 Khan Academy工程师 Ben Kamens 写的 jQuery插件 前端学习网站推荐1. 极客标签： http://www.gbtags.com/ 2. 码农周刊： http://weekly.manong.io/issues/ 3. 前端周刊： http://www.feweekly.com/issues 4. 慕课网： http://www.imooc.com/ 5. div.io： http://div.io 6. Hacker News： https://news.ycombinator.com/news 7. InfoQ： http://www.infoq.com/ 8. w3cplus： http://www.w3cplus.com/ 9. Stack Overflow： http://stackoverflow.com/ 10.w3school： http://www.w3school.com.cn/ 11.mozilla： https://developer.mozilla.org/zh-CN/docs/Web/ 文档推荐 jQuery 基本原理 JavaScript 秘密花园 CSS参考手册 JavaScript 标准参考教程 ECMAScript 6入门 ###更新时间: 2015-12-29 资料答案不够正确和全面，欢迎欢迎Star和提交issues。我的微博：http://weibo.com/920802999","categories":[{"name":"frontend","slug":"frontend","permalink":"http://www.wanqing520.cn/categories/frontend/"}],"tags":[]},{"title":"Neil | 牛中超--Welcome!","slug":"杂谈/2015-9-9-welcome-to-jekyll","date":"2015-09-09T02:18:00.000Z","updated":"2017-12-13T11:08:20.000Z","comments":true,"path":"201509/09/杂谈/2015-9-9-welcome-to-jekyll.html","link":"","permalink":"http://www.wanqing520.cn/201509/09/杂谈/2015-9-9-welcome-to-jekyll.html","excerpt":"","text":"博客使用 Github + Jekyll 实现并托管整个网站， 优点是无需关注数据库、版本更新等问题，只需关心博客内容； 修改了JQuery由默认的Google引用修改为百度的Jquery CDN； 增加了多说的评论功能。 参考文献： jekyll官方版 http://jekyllrb.com jekyll中文版 http://jekyll.bootcss.com/ 南京 南京","categories":[{"name":"杂谈","slug":"杂谈","permalink":"http://www.wanqing520.cn/categories/杂谈/"}],"tags":[]}]}