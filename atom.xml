<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shugenniu&#39;s blogger</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.wanqing520.cn/"/>
  <updated>2018-05-22T14:25:51.490Z</updated>
  <id>http://www.wanqing520.cn/</id>
  
  <author>
    <name>sixtrees</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>乐享开发指南</title>
    <link href="http://www.wanqing520.cn/201805/22/%E6%9D%82%E8%B0%88/%E4%B9%90%E4%BA%AB%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97.html"/>
    <id>http://www.wanqing520.cn/201805/22/杂谈/乐享开发指南.html</id>
    <published>2018-05-22T14:11:28.426Z</published>
    <updated>2018-05-22T14:25:51.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拷贝集成环境"><a href="#拷贝集成环境" class="headerlink" title="拷贝集成环境"></a>拷贝集成环境</h1><p>找乐享开发组同事拷贝虚拟机镜像， 导入到虚拟机中。</p><h2 id="拷贝镜像"><a href="#拷贝镜像" class="headerlink" title="拷贝镜像"></a>拷贝镜像</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;拷贝集成环境&quot;&gt;&lt;a href=&quot;#拷贝集成环境&quot; class=&quot;headerlink&quot; title=&quot;拷贝集成环境&quot;&gt;&lt;/a&gt;拷贝集成环境&lt;/h1&gt;&lt;p&gt;找乐享开发组同事拷贝虚拟机镜像， 导入到虚拟机中。&lt;/p&gt;
&lt;h2 id=&quot;拷贝镜像&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="更新说明" scheme="http://www.wanqing520.cn/tags/%E6%9B%B4%E6%96%B0%E8%AF%B4%E6%98%8E/"/>
    
      <category term="小书匠" scheme="http://www.wanqing520.cn/tags/%E5%B0%8F%E4%B9%A6%E5%8C%A0/"/>
    
  </entry>
  
  <entry>
    <title>blog-migration</title>
    <link href="http://www.wanqing520.cn/201805/22/blog-migration.html"/>
    <id>http://www.wanqing520.cn/201805/22/blog-migration.html</id>
    <published>2018-05-22T13:26:53.000Z</published>
    <updated>2018-05-22T13:35:40.840Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="你好;博客迁移;hexo" scheme="http://www.wanqing520.cn/tags/%E4%BD%A0%E5%A5%BD-%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB-hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.wanqing520.cn/201805/22/hello-world.html"/>
    <id>http://www.wanqing520.cn/201805/22/hello-world.html</id>
    <published>2018-05-22T13:15:39.091Z</published>
    <updated>2018-05-22T13:34:56.308Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
      <category term="你好" scheme="http://www.wanqing520.cn/tags/%E4%BD%A0%E5%A5%BD/"/>
    
  </entry>
  
  <entry>
    <title>nodejs下利用parallel从redis中pop多个数据</title>
    <link href="http://www.wanqing520.cn/201804/23/fontend/nodejs/nodejs-redis-popall.html"/>
    <id>http://www.wanqing520.cn/201804/23/fontend/nodejs/nodejs-redis-popall.html</id>
    <published>2018-04-23T08:45:41.000Z</published>
    <updated>2018-05-24T06:06:43.242Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><ul><li><p>redis nodejs的api没有提供pop多个元素的指令</p></li><li><p>redis的smember函数没有办法移除要pop出去的元素，且高并发下可能存在问题</p></li><li><p>使用 async.parallel来实现多个任务并列执行，最终可以一次性得到所有结果</p></li><li><p>避免了nodejs异步编程中无法实现<code>for循环+异步的问题</code></p></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">router.post(<span class="string">'/pictures_list'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(req, res, next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> app_id = req.body.app_id; <span class="comment"># 获取redis的key</span></span><br><span class="line">    client.scard(app_id, <span class="function"><span class="keyword">function</span> <span class="params">(error, data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/json'</span>);</span><br><span class="line">            res.json(JSON.stringify(&#123;<span class="string">'url'</span>: datas&#125;))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//得到redis中appid对应的Set集合中的元素数量，将其全部pop出来</span></span><br><span class="line">            <span class="keyword">var</span> tasks = create_task(data, app_id);</span><br><span class="line">            <span class="comment">// 创建num个pop任务，将num个任务parallel执行，result中的结果是</span></span><br><span class="line">            <span class="comment">//num个pop任务得到的结果</span></span><br><span class="line">            async.parallel(tasks, <span class="function"><span class="keyword">function</span> <span class="params">(error, result)</span> </span>&#123;</span><br><span class="line">                res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'text/json'</span>);</span><br><span class="line">                res.json(JSON.stringify(&#123;<span class="string">'url'</span>: result&#125;));</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* count是要pop出来的数量</span></span><br><span class="line"><span class="comment">* app_id是redis的Set的key</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create_task</span><span class="params">(count, app_id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tasks = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        tasks[i] = <span class="function"><span class="keyword">function</span> <span class="params">(num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span> </span>&#123;</span><br><span class="line">                client.spop(app_id, <span class="function"><span class="keyword">function</span> <span class="params">(error, datas)</span> </span>&#123;</span><br><span class="line">                    callback(<span class="keyword">null</span>, datas);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;场景描述&quot;&gt;&lt;a href=&quot;#场景描述&quot; class=&quot;headerlink&quot; title=&quot;场景描述&quot;&gt;&lt;/a&gt;场景描述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;redis nodejs的api没有提供pop多个元素的指令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;redis
      
    
    </summary>
    
      <category term="frontend" scheme="http://www.wanqing520.cn/categories/frontend/"/>
    
    
      <category term="nodejs" scheme="http://www.wanqing520.cn/tags/nodejs/"/>
    
      <category term="redis" scheme="http://www.wanqing520.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>java爬取80s电影网站的视频信息</title>
    <link href="http://www.wanqing520.cn/201610/31/java/2016-10-31-use-java-spide-80movies-information.html"/>
    <id>http://www.wanqing520.cn/201610/31/java/2016-10-31-use-java-spide-80movies-information.html</id>
    <published>2016-10-30T16:58:14.000Z</published>
    <updated>2017-12-13T11:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><a href="https://git.oschina.net/jsper/MovieDownload.git" target="_blank" rel="noopener">https://git.oschina.net/jsper/MovieDownload.git</a></p><h1 id="项目参考链接"><a href="#项目参考链接" class="headerlink" title="项目参考链接"></a>项目参考链接</h1><ol><li><a href="http://www.open-open.com/jsoup" target="_blank" rel="noopener">jsoup的使用</a></li><li><a href="http://mvnrepository.com/" target="_blank" rel="noopener">maven依赖查找</a></li><li><a href="http://rainbowdesert.iteye.com/blog/603327" target="_blank" rel="noopener">使用httpclient获取相应字符串</a></li></ol><h1 id="网页分析"><a href="#网页分析" class="headerlink" title="网页分析"></a>网页分析</h1><p>我们使用正在播出的电视剧<a href="http://www.80s.la/ju/18920" target="_blank" rel="noopener">《暗战危城》</a>的页面来说明如何获取页面信息<br>如下图所示，在浏览器的<code>开发者工具</code>中，我们审查<code>《暗战危城》</code>页面的元素的时候，可以看到其head标签中含有大量的<code>meta</code>元素，我们只要能够提出出<code>meta</code>的信息就可以获取到电视剧的剧名、简介、海报等信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://git.oschina.net/uploads/images/2016/1031/130059_e54547b3_461425.png" alt="输入图片说明" title="在这里输入图片标题">                </div>                <div class="image-caption">在这里输入图片标题</div>            </figure><p>如下图所示，页面中还包含了<code>最近更新：</code>,<code>更新周期：</code>,<code>演员：</code>等信息。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://git.oschina.net/uploads/images/2016/1031/130324_b1386c7b_461425.png" alt="输入图片说明" title="在这里输入图片标题">                </div>                <div class="image-caption">在这里输入图片标题</div>            </figure><p>下图红色箭头的部分都是可以点击，调用浏览器或者迅雷进行下载的UI按钮。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://git.oschina.net/uploads/images/2016/1031/130503_ca5d272d_461425.png" alt="输入图片说明" title="在这里输入图片标题">                </div>                <div class="image-caption">在这里输入图片标题</div>            </figure><p>审查上面图中的<code>第18集的所在的li的元素</code>，截图如下<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://git.oschina.net/uploads/images/2016/1031/130616_af397d28_461425.png" alt="输入图片说明" title="在这里输入图片标题">                </div>                <div class="image-caption">在这里输入图片标题</div>            </figure></p><p>可以看到，只要我们根据li提取出第一个span标签下的input标签和后面两个span标签的a标签就可以获取到http下载路径和迅雷下载路径</p><h1 id="关于多线程的使用"><a href="#关于多线程的使用" class="headerlink" title="关于多线程的使用"></a>关于多线程的使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService pool = Executors.newFixedThreadPool(<span class="number">100</span>);</span><br><span class="line">Runnable runnable = () -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程要进行的操作</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//线程池调度线程</span></span><br><span class="line">pool.execute(runnable);</span><br></pre></td></tr></table></figure><p>上面的代码创建了一个大小为100的线程池，线程池自动调用线程，并维持线程的声明周期。</p><h1 id="项目对应的POM"><a href="#项目对应的POM" class="headerlink" title="项目对应的POM"></a>项目对应的POM</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.jsoup/jsoup --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.jsoup<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsoup<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>4.5.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="程序运行结果"><a href="#程序运行结果" class="headerlink" title="程序运行结果"></a>程序运行结果</h1><p>爬取电视剧页面<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://git.oschina.net/uploads/images/2016/1031/131340_f290bb56_461425.png" alt="输入图片说明" title="在这里输入图片标题">                </div>                <div class="image-caption">在这里输入图片标题</div>            </figure></p><p>爬取电影页面<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://git.oschina.net/uploads/images/2016/1031/131422_1b2004cc_461425.png" alt="输入图片说明" title="在这里输入图片标题">                </div>                <div class="image-caption">在这里输入图片标题</div>            </figure></p>]]></content>
    
    <summary type="html">
    
      java使用多线程在线程池中爬取并解析80s电影网站的视频信息
    
    </summary>
    
      <category term="java" scheme="http://www.wanqing520.cn/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>博客由github迁移到gitosc</title>
    <link href="http://www.wanqing520.cn/201610/17/git/2016-10-17-migration_gitpages_to_giteepages.html"/>
    <id>http://www.wanqing520.cn/201610/17/git/2016-10-17-migration_gitpages_to_giteepages.html</id>
    <published>2016-10-17T09:47:00.000Z</published>
    <updated>2017-12-13T11:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在git-oschina-net上新建项目"><a href="#在git-oschina-net上新建项目" class="headerlink" title="在git.oschina.net上新建项目"></a>在git.oschina.net上新建项目</h1><p>如下图所示，创建一个项目，项目名为自己的开源中国的个性域名的名字（我的是<code>jsper</code>）,我这里的项目已经存在了<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://git.oschina.net/uploads/images/2016/1018/141339_de545004_461425.png" alt="输入图片说明" title="在这里输入图片标题">                </div>                <div class="image-caption">在这里输入图片标题</div>            </figure></p><h1 id="从空的项目拉取到本地"><a href="#从空的项目拉取到本地" class="headerlink" title="从空的项目拉取到本地"></a>从空的项目拉取到本地</h1><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Administrator<span class="meta">@XB</span><span class="number">-201606171743</span> MINGW64 <span class="regexp">/d/</span>牛中超个人文件<span class="regexp">/nodejs/</span>gitpages/backup</span><br><span class="line">$ pwd</span><br><span class="line"><span class="regexp">/d/</span>牛中超个人文件<span class="regexp">/nodejs/</span>gitpages/backup</span><br><span class="line"></span><br><span class="line">Administrator<span class="meta">@XB</span><span class="number">-201606171743</span> MINGW64 <span class="regexp">/d/</span>牛中超个人文件<span class="regexp">/nodejs/</span>gitpages/backup</span><br><span class="line">$ git clone <span class="string">https:</span><span class="comment">//git.oschina.net/jsper/jsper.git</span></span><br></pre></td></tr></table></figure><h1 id="拷贝文件文件"><a href="#拷贝文件文件" class="headerlink" title="拷贝文件文件"></a>拷贝文件文件</h1><p>将github的<code>https://github.com/sixtrees/sixtrees.github.com.git</code>项目拷贝到本地</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://git.oschina.net/uploads/images/2016/1018/142231_61307442_461425.png" alt="输入图片说明" title="在这里输入图片标题">                </div>                <div class="image-caption">在这里输入图片标题</div>            </figure><p>复制除<code>.git</code>文件夹外的所有内容，到刚才从<code>OSC GIT</code>上拷贝下来的空项目目录中<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://git.oschina.net/uploads/images/2016/1018/142325_440dce29_461425.png" alt="输入图片说明" title="在这里输入图片标题">                </div>                <div class="image-caption">在这里输入图片标题</div>            </figure></p><h1 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改<code>_config.yml</code></h1><p>修改<code>_config.yml</code>要做的工作很少，项目在github上能够很好的运行的话，这里只需要添加一项配置</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gems: <span class="string">[jekyll-paginate]</span></span><br></pre></td></tr></table></figure><h1 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h1><h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">add</span><span class="bash"> .</span></span><br></pre></td></tr></table></figure><h2 id="commit"><a href="#commit" class="headerlink" title="commit"></a>commit</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git</span> commit -m <span class="string">"迁移"</span></span><br></pre></td></tr></table></figure><h2 id="push"><a href="#push" class="headerlink" title="push"></a>push</h2><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">push</span></span><br></pre></td></tr></table></figure><p>#开启pages<br>如下图所示，在项目主页，选择<code>Pages</code>选项卡，<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://git.oschina.net/uploads/images/2016/1018/142819_63c55c06_461425.png" alt="输入图片说明" title="在这里输入图片标题">                </div>                <div class="image-caption">在这里输入图片标题</div>            </figure></p><p>如下图所示，这里可以选择master分支，方便提交<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://git.oschina.net/uploads/images/2016/1018/142905_d996628b_461425.png" alt="输入图片说明" title="在这里输入图片标题">                </div>                <div class="image-caption">在这里输入图片标题</div>            </figure></p><p>点击<code>启动</code>按钮，最后的内容如下：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://git.oschina.net/uploads/images/2016/1018/142953_493b61b1_461425.png" alt="输入图片说明" title="在这里输入图片标题">                </div>                <div class="image-caption">在这里输入图片标题</div>            </figure><p>访问<code>http://jsper.oschina.io</code></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://git.oschina.net/uploads/images/2016/1018/143028_44ff32a8_461425.png" alt="输入图片说明" title="在这里输入图片标题">                </div>                <div class="image-caption">在这里输入图片标题</div>            </figure><h1 id="几点说明"><a href="#几点说明" class="headerlink" title="几点说明"></a>几点说明</h1><ol><li>如果想使用<code>http://username.oschina.io/</code>来访问自己的博客，那个项目名就必须是自己<code>username</code></li><li><code>_config.yml</code>必须添加<code>gems: [jekyll-paginate]</code>配置，否则将找不到<code>_post</code>文件夹下的<code>md</code>文章</li><li>pages采用<code>jekyll</code>支持，想了解更多内容，看这里：<a href="http://jekyll.com.cn/" target="_blank" rel="noopener">jekyll中文站点</a></li></ol><h1 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h1><p>感谢开源中国的开源精神，想迁移博客到osc上的目的，就是osc的md文件可以直接复制图片，不需要考虑图片的上传问题，很方便有木有。在博客的迁移过程中，非常感谢 <strong>温家成</strong> （<code>http://git.oschina.net/wenjiachengy</code>）的帮助。下面是<code>issue</code>的路径<br><a href="http://git.oschina.net/oschina/git-osc/issues/5277#note_483947" target="_blank" rel="noopener">http://git.oschina.net/oschina/git-osc/issues/5277#note_483947</a></p>]]></content>
    
    <summary type="html">
    
      博客由github迁移到gitosc
    
    </summary>
    
      <category term="git" scheme="http://www.wanqing520.cn/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>Java FAQ</title>
    <link href="http://www.wanqing520.cn/201610/15/java/2016-10-15-some-java-problems.html"/>
    <id>http://www.wanqing520.cn/201610/15/java/2016-10-15-some-java-problems.html</id>
    <published>2016-10-15T03:46:00.000Z</published>
    <updated>2017-12-13T11:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-String、StringBuffer-和-StringBuilder-的区别："><a href="#1-String、StringBuffer-和-StringBuilder-的区别：" class="headerlink" title="1.String、StringBuffer 和 StringBuilder 的区别："></a>1.String、StringBuffer 和 StringBuilder 的区别：</h2><p>String：不可变字符串； String 字符串的 + 法实际是生成了新的 String 对象，如果频繁滴有 + 操作，那么效率可能会很差；<br>StringBuffer：线程安全的可变字符串； 使用 append 来进行连接 + 操作， 如果频繁有字符串 + 操作，应该采用；<br>StringBuilder：非线程安全的可变字符串；如果频繁有字符串 +，那么可以采用，效率比 StringBuffer 会高那么一点，但注意是非线程安全的；<br>String.intern()方法： 将字符串对应值放到常量区。</p><h2 id="2-将构造函数声明为-private-有哪些用途-？"><a href="#2-将构造函数声明为-private-有哪些用途-？" class="headerlink" title="2. 将构造函数声明为 private 有哪些用途 ？"></a>2. 将构造函数声明为 private 有哪些用途 ？</h2><p>类外不能直接构造对象(实例化这个类)，如果要获取对象那么只有通过 static 的 public 方法，单例模式和工厂模式常如此用；<br>该类不能继承。</p><h2 id="3-try-catch-finally-的-try-块中如果有-return-语句，-finally-块是否还会执行？"><a href="#3-try-catch-finally-的-try-块中如果有-return-语句，-finally-块是否还会执行？" class="headerlink" title="3. try-catch-finally 的 try 块中如果有 return 语句， finally 块是否还会执行？"></a>3. try-catch-finally 的 try 块中如果有 return 语句， finally 块是否还会执行？</h2><p>会。 finally 语句会在 return 之前执行，但是会在 return expression 的 expression 求值之后。</p><p>随之一个问题：try 块中 return 1 而 finally 块中 return 2 ，那么函数是返回 1 还是 2 呢？ —— 答案是 2 。这也说明，如果 try/catch 块中 throw Exception ，而 finally 中 return 值，那么异常也不会真 throw 到外层。</p><h2 id="4-在哪些情况下-try-catch-finally-结构中的-finally-语句块不会执行？"><a href="#4-在哪些情况下-try-catch-finally-结构中的-finally-语句块不会执行？" class="headerlink" title="4. 在哪些情况下 try-catch-finally 结构中的 finally 语句块不会执行？"></a>4. 在哪些情况下 try-catch-finally 结构中的 finally 语句块不会执行？</h2><p>如果虚拟机在 try/catch 语句块执行期间退出；除了 power off 或是 reset 这些外部不可抗拒的因素外，System.exit(1) 也会造成 JVM 异常退出，这时候 finally 块可能还来不及执行；<br>如果执行 try/catch 语句块的线程被杀死终止了。</p><h2 id="5-final、finally-和-finalize-的使用场景-？"><a href="#5-final、finally-和-finalize-的使用场景-？" class="headerlink" title="5. final、finally 和 finalize 的使用场景 ？"></a>5. final、finally 和 finalize 的使用场景 ？</h2><p>final 用在不同的地方含义也不同：</p><p>修饰变量，表明变量初始化之后不可修改，也就是不能重新赋值；如果 final 来修饰对象，只表明不能重新赋值，但可以修改对象的值；<br>修饰方法，表明方法不能重写；<br>修饰类，表明类不能继承；final 和 abstract 不能同时修饰一个类，因为前者说明不能继承，后者则必须继承才能实例化；<br>finally 是 try-catch-finally 块的一部分， 可选。 try/catch 块执行之后一定会执行的一部分，一般用于资源回收或是垃圾清理。 (当然在某些极端情况下， finally 不会执行。)</p><p>finalize() 方法： 当 gc 要回收一个对象之前会执行 finalize() 方法。</p><h2 id="6-Java-泛型-和-c-泛型的区别。"><a href="#6-Java-泛型-和-c-泛型的区别。" class="headerlink" title="6. Java 泛型 和 c++ 泛型的区别。"></a>6. Java 泛型 和 c++ 泛型的区别。</h2><p>最核心区别： c++ 中泛型中的类型是泛型类的一部分， java 中不是。</p><h2 id="7-java-的-major-minor-版本"><a href="#7-java-的-major-minor-版本" class="headerlink" title="7. java 的 major.minor 版本"></a>7. java 的 major.minor 版本</h2><p>运行java程序有时候会遇到的一个问题：Exception in thread “main” java.lang.UnsupportedClassVersionError: org/apache/catalina/util/ServerInfo : Unsupported major.minor version 51.0 ，这说明当前的 JRE 版本和 class 要求的版本不一致， 51.0 表明需要 JRE7。</p><p>Java major.minor 会存在字节码中，具体 major 版本对应的 JDK：</p><p>J2SE 8 = 52<br>J2SE 7 = 51<br>J2SE 6.0 = 50<br>J2SE 5.0 = 49<br>JDK 1.4 = 48<br>JDK 1.3 = 47<br>JDK 1.2 = 46<br>JDK 1.1 = 45</p><h2 id="8-JRE-的-rt-jar-中包的结构，或是有哪些包？"><a href="#8-JRE-的-rt-jar-中包的结构，或是有哪些包？" class="headerlink" title="8. JRE 的 rt.jar 中包的结构，或是有哪些包？"></a>8. JRE 的 rt.jar 中包的结构，或是有哪些包？</h2><p>rt.jar 有 java.<em>, javax.</em>, com.<em>, org.</em>, sun.<em>, sunw.</em> 六个包，其中前四个为 public 包，api 一般保持兼容； 后两个为非 public 包，不同系统上的实现可能不同，也不保证兼容性。</p><h2 id="9-switch-可以跟的类型有哪些？"><a href="#9-switch-可以跟的类型有哪些？" class="headerlink" title="9. switch() 可以跟的类型有哪些？"></a>9. switch() 可以跟的类型有哪些？</h2><p>jdk7 之前只能支持 char, byte, short, int 四种整型， jdk7 开始支持 String 类型。long 是不支持的呀！</p><h2 id="10-和-equals-的区别？"><a href="#10-和-equals-的区别？" class="headerlink" title="10. == 和 equals() 的区别？"></a>10. == 和 equals() 的区别？</h2><p>== 用来比较相等，可以用于基本类型和引用类型；equals() 是对象(引用)来比较相等。 == 用于对象的时候，比较的是“是否引用的同一个对象”，而非“内容是否相等”； equals() 往往是比较“内容是否相等”。需要注意的是 String 和 Long(包括 Integer 等)：</p><p>String s1=”hello”, s2=”hello”, s3=new String(“hello”), s4=new String(“hello”) ： s1 == s2 true，其他 == 比较都是 false 。 任意一个 equals() 比较都是 true ！<br>Integer i = 10; Long l = 10L; i == l 和 i.equls(l) 都是 false，后者是因为 Integer/Long.equals() 首先比较类型是否相同其次比较 value 是否 == ！</p><h2 id="11-Object-类以及常用方法？"><a href="#11-Object-类以及常用方法？" class="headerlink" title="11. Object 类以及常用方法？"></a>11. Object 类以及常用方法？</h2><p>Object 是 Java 中所有类的祖先类：一个类要么直接继承要么间接继承自 Object。一个类如果没有显式地继承一个类，那么默认 extends Object 。</p><p>Object 的几个方法： toString()，equals()，hashCode()，以及 getClass()，clone() 和finalize()。另外几个用于线程类： wait() 、notify() 和 notifyAll() 。</p><p>toString() ： 对象字符串化的格式， 除了直接调用之外，在字符串拼接 + ，或是 print 的时候会调用之；<br>equals()： 定制对象相等比较的逻辑，集合类的 contains() 方法会调用之；<br>hashCode() ： 哈希值，一个 int 值； (同一个进程中)同一个对象的 hashCode() 相等， equals() 相等的对象的 hashCode() 也应该相等，除此之外可以相等也可以不相等；<br>getClass() ： 获取类对应的 Class&lt;?&gt; 类对象；<br>clone() ： 拷贝逻辑；<br>finalize() ： gc 之前的处理逻辑；</p><h2 id="12-换行符是神马？"><a href="#12-换行符是神马？" class="headerlink" title="12. 换行符是神马？"></a>12. 换行符是神马？</h2><p>跟换行符有关的两个字符<code>\r (CR: carriage return)</code> 和 <code>\n (LF: line feed)</code>。 windows 下换行符是 <code>\r\n</code>， <code>*unix</code>是 <code>\n</code>， mac 下最初是 \r (直到 Mac OS Version 9)后来是 \n (Mac OS X)。╮(╯▽╰)╭ 有没有一种错乱的感觉！ 所以 System.out.println() 和 <code>System.out.print(&#39;\n&#39;)</code> 是有差异的！<code>System.out.println()</code> 和 <code>System.out.printf(&quot;%n&quot;)</code>是一致的。</p><p>获取换行符： System.lineSeparator(); 或是 System.getProperty(“line.separator”);</p><h2 id="13-java-的-system-properties-有哪些？"><a href="#13-java-的-system-properties-有哪些？" class="headerlink" title="13. java 的 system properties 有哪些？"></a>13. java 的 system properties 有哪些？</h2><p>具体有哪些可以通过 System.getProperties() 查看。有一些是系统定义的，有一些是应用程序定义的，不过我们主要系统定义的一部分。</p><p>Java相关：”java.home”, “java.library.path”, “java.class.path”, “java.ext.dirs”,”java.version”, “java.runtime.version” 分别是： JRE目录、native库目录、load库目录、扩展库目录，java版本，jre版本；<br>分隔符相关： “file.separator”, “path.separator”, “line.separator” 分别是文件分隔符、路径分隔符和换行分隔符；<br>用户相关：”user.home”, “user.name”, “user.dir” 分别是用户主目录、用户名以及用户当前目录；<br>os相关：”os.name”, “os.version”, “os.arch” 分别是操作系统名称、版本、平台；</p><h2 id="14-三元表达式"><a href="#14-三元表达式" class="headerlink" title="14. 三元表达式"></a>14. 三元表达式</h2><p>三元表达式 a ? b : c 在某些场景下是 if…else… 很好的替代品。语义就是如果 a 为 true 则 b 的值作为表达式的值， 否则 c 的值作为表达式的值。很好理解。不过需要注意的是 boolen f = true; f ? 10 : 12.5 的结果的值是 10.0 而非 10，原因是表达式 b 和 c 部分的类型需要保持一致，如果不一致会进行默认的类型转换，这里 int 的 10 会转换为 double 的 10.0 。</p><h2 id="15-求余运算-和整数除法"><a href="#15-求余运算-和整数除法" class="headerlink" title="15. 求余运算 % 和整数除法 /"></a>15. 求余运算 % 和整数除法 /</h2><p>求余运算通常能得到预期的结果，譬如 13 % 3 == 1 。但是 <code>-13 % 3 == ? 13 % -3 == ? -13 % -3 == ?</code></p><p>上面答案分别是：<code>-1</code> 、<code>1</code>和 <code>-1</code> 。记忆方式也挺简单，就是余数的符号和被除数的符号一致。</p><p>对应的需要注意：<code>13/3 == 4</code>， <code>-13/3 == -4</code>， <code>13%-3 == -4</code>， <code>-13/-4 == 3</code> 。总之符合： <code>a = (a/b)*b + (a%b)</code> 。</p><h2 id="16-volatile-关键字"><a href="#16-volatile-关键字" class="headerlink" title="16. volatile 关键字"></a>16. volatile 关键字</h2><p><code>volatile</code>修饰变量 v 的话，表明变量 v 的值对外具有一致性。也就是说即使在多线程环境下，如果 v 的值修改了，那么去读 v 的值能取到新的 v 值，否则不一定。</p><p>v 可以用来修饰基本类型的变量，譬如 int 型， 或是对象。对于后者只是保证引用的对外一致性，而引用的对象的修改不在“一致”范围内。</p><p>so，<code>volatile</code> 具有部分线程同步功能，特别是“一写多读”的情形。</p><h2 id="17-synchronized-关键字"><a href="#17-synchronized-关键字" class="headerlink" title="17. synchronized 关键字"></a>17. synchronized 关键字</h2><p><code>synchronized</code> 可以用来修饰普通方法、类方法或是对象，来控制对方法或是对象的互斥访问。</p><h2 id="18-SimpleDateFormat"><a href="#18-SimpleDateFormat" class="headerlink" title="18. SimpleDateFormat"></a>18. SimpleDateFormat</h2><p><code>java doc</code>上有云“Date formats are not synchronized. It is recommended to create separate format instances for each thread. If multiple threads access a format concurrently, it must be synchronized externally.”。</p><p>所以，<code>SimpleDateFormat</code>作为 <code>static</code> 变量共享的时候需要显式同步，譬如用 <code>synchronized</code>。另外一种处理是借助 <code>ThreadLocal</code> ，这样同一个线程内是安全的，又不需要每一次进行同步。如果将 <code>SimpleDateFormat</code> 作为 <code>local</code> 变量，当然也是线程安全的，只不过每次使用都需要进行重新构造。</p><p>转载自:<a href="http://www.lrj.name/post-show/id/555486b80da7d80000000001" target="_blank" rel="noopener">文琼</a></p>]]></content>
    
    <summary type="html">
    
      转载自：http://www.lrj.name/post-show/id/555486b80da7d80000000001
    
    </summary>
    
      <category term="java" scheme="http://www.wanqing520.cn/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>使用https://www.processon.com来分享创作的图片</title>
    <link href="http://www.wanqing520.cn/201610/14/git/2016-10-14-share_photo_on_processon.html"/>
    <id>http://www.wanqing520.cn/201610/14/git/2016-10-14-share_photo_on_processon.html</id>
    <published>2016-10-14T09:47:00.000Z</published>
    <updated>2017-12-13T11:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="问题的提出"><a href="#问题的提出" class="headerlink" title="问题的提出"></a>问题的提出</h1><p>因为在搭建我的<code>git pages</code>时，无意中，看到有文章说，<code>git pages</code>服务器只提供给用户<code>300M</code>的存储空间，因此，我们需要考虑博客的图片的存放。</p><h1 id="问题的解决方法"><a href="#问题的解决方法" class="headerlink" title="问题的解决方法"></a>问题的解决方法</h1><h2 id="使用csdn来同步存储博客内容"><a href="#使用csdn来同步存储博客内容" class="headerlink" title="使用csdn来同步存储博客内容"></a>使用csdn来同步存储博客内容</h2><p>由于，我之前都是在<code>CSDN</code>使用<code>MARKDOWN</code>编辑器来书写博客，而<code>CSDN</code>的<code>MARKDOWN</code>编辑器支持<code>.md</code>的上传和下载，因此，我之前都是将博客内容写在<code>CSDN</code>上，复制或者下载编写好的<code>markdown文</code>件，再上传到<code>git pages</code>上。这是，比较方法的一种方法。</p><h2 id="使用在线图片编辑软件来自己动手画图"><a href="#使用在线图片编辑软件来自己动手画图" class="headerlink" title="使用在线图片编辑软件来自己动手画图"></a>使用在线图片编辑软件来自己动手画图</h2><p><a href="https://www.processon.com" target="_blank" rel="noopener">https://www.processon.com</a>这种网站有很多，随意地打开了这个网站，发现打开速度挺快的，就使用了这个网站。</p><h1 id="如何分享在processon上创建的图片"><a href="#如何分享在processon上创建的图片" class="headerlink" title="如何分享在processon上创建的图片"></a>如何分享在<code>processon</code>上创建的图片</h1><h3 id="1-注册，登录。"><a href="#1-注册，登录。" class="headerlink" title="1.注册，登录。"></a>1.注册，登录。</h3><p>自己来；</p><h3 id="2-在线创作文件"><a href="#2-在线创作文件" class="headerlink" title="2.在线创作文件"></a>2.在线创作文件</h3><p>这里给出一个我创建的文件的编辑链接：<code>https://www.processon.com/diagraming/5800a208e4b02e1122423a42</code></p><h3 id="3-获取分享连接"><a href="#3-获取分享连接" class="headerlink" title="3.获取分享连接"></a>3.获取分享连接</h3><p>然后，该网站提供分享该文件的连接，上面的文件对应的分享查看的连接是<code>https://www.processon.com/view/link/5800a353e4b0cff94f9d577e</code><br>但是，这个路径不是图片，因此，并不是很好的复合我们将其放在<code>markdown</code>中作为图片来展示。</p><h3 id="4-下载jpg格式的文件"><a href="#4-下载jpg格式的文件" class="headerlink" title="4.下载jpg格式的文件"></a>4.下载jpg格式的文件</h3><p>值得高兴的事情，该网站提供文件的下载，并且支持将文件下载为<code>.jpg</code>格式的文件，上面的文件的对应的下载链接为：<code>https://www.processon.com/diagram_export?type=image&amp;title=JMM&amp;chartId=5800a208e4b02e1122423a42&amp;ignore=definition</code></p><h3 id="5-重要的东西来了"><a href="#5-重要的东西来了" class="headerlink" title="5.重要的东西来了"></a>5.重要的东西来了</h3><p>通过上面的几个步骤，相信你应该可以看到了一个<code>5800a208e4b02e1122423a42</code>的<code>chartId</code>，这个就是我们创建的文件对应的<code>ID</code>，根据<code>4</code>中的下载的下载链接，我们可以构造出一个文件下载链接的模板<code>https://www.processon.com/diagram_export?type=image&amp;title=JMM&amp;chartId=yourChartID&amp;ignore=definition</code></p><h3 id="6-测试"><a href="#6-测试" class="headerlink" title="6.测试"></a>6.测试</h3><p>下面，我用<code>markdown</code>格式加载我们创建的图片</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://www.processon.com/diagram_export?type=image&title=JMM&chartId=5800a208e4b02e1122423a42&ignore=definition" alt="测试图片" title="">                </div>                <div class="image-caption">测试图片</div>            </figure><p>上面图片的<code>markdown</code>代码为：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">测试图片</span>](<span class="link">https://www.processon.com/diagram_export?type=image&amp;title=JMM&amp;chartId=5800a208e4b02e1122423a42&amp;ignore=definition</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      使用https://www.processon.com来分享创作的图片
    
    </summary>
    
      <category term="git" scheme="http://www.wanqing520.cn/categories/git/"/>
    
    
  </entry>
  
  <entry>
    <title>总线锁和缓存锁</title>
    <link href="http://www.wanqing520.cn/201610/14/java/2016-10-14-java-lock.html"/>
    <id>http://www.wanqing520.cn/201610/14/java/2016-10-14-java-lock.html</id>
    <published>2016-10-14T04:03:14.000Z</published>
    <updated>2017-12-13T11:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h1><p>现在的处理器能够自动保证每个处理器对同一个缓存行里进行<code>16/32/64</code>位的操作是原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供总线锁定和缓存锁定两个机制来保证复杂的内存操作的原子性。</p><h1 id="总线锁"><a href="#总线锁" class="headerlink" title="总线锁"></a>总线锁</h1><p>总线索就是使用处理器提供的一个<code>LOCK#</code>信号，当一个处理器在总线上输出此信号，其他处理器的请求将被阻塞，那么该处理器就可以独占共享锁。</p><h1 id="缓存锁"><a href="#缓存锁" class="headerlink" title="缓存锁"></a>缓存锁</h1><p>由于，我们只需要保证对某个内存地址的操作是原子的即可，但是总线锁把CPU和内存之间的通信锁住了，这使得在锁定期间，其他处理器也不能操作其他内存地址的数据，所以总线锁的开销比较大。目前，处理器在某些场合下使用缓存锁来代替总线索进行优化。</p><p><code>缓存锁</code>就是指内存区域如果被缓存在处理器的缓存行中，并且在<code>LOCK#</code>操作期间，那么当它执行操作回写到内存时，处理器不在总线上声言<code>LOCK#</code>信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，其他处理器回写已被锁定的缓存行的数据时，就会使缓存无效。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>如上面所说，在多数情况下，处理器还是使用缓存锁来代替总线锁，但是在下面两种情况下，我们还是使用总线锁来完成相应保证一致性。</p><ol><li>情况1：当操作的数据不能被缓存在处理器内部，或者操作的数据跨多个缓存行时，则处理器会字调用总线锁锁定。</li><li>情况2：有些处理器不支持缓存行锁定。</li></ol>]]></content>
    
    <summary type="html">
    
      JAVA并发编程的艺术之总线锁和缓存锁
    
    </summary>
    
      <category term="java" scheme="http://www.wanqing520.cn/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>2016-10-13-如果打印机不能连接</title>
    <link href="http://www.wanqing520.cn/201610/13/%E6%9D%82%E8%B0%88/2016-10-13-intranet-printer.html"/>
    <id>http://www.wanqing520.cn/201610/13/杂谈/2016-10-13-intranet-printer.html</id>
    <published>2016-10-13T08:57:14.000Z</published>
    <updated>2017-12-13T11:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>如果使用<code>WIN+R</code>,输入<code>\\172.16.135.41</code>,需要输入用户名和密码才能访问打印机或者直接提示用户被禁止，无法登陆的情况。请参考下面的设置方法。</p><h2 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h2><p>这个问题，是由那台打印机附属的电脑升级成win10系统之后，才出现的这个问题。出现上面描述的问题，是因为<code>Guest</code>用户被禁用，需要关闭该用户的禁用。</p><ol><li>在桌面，右键<code>计算机</code>，选择<code>管理</code>；</li><li>进入<code>计算机管理（本地）</code>之后，选择<code>本地用户和组</code>;</li><li>进入<code>本地用户和组</code>后，选择<code>用户</code>；</li><li>计入<code>用户</code>后，查看<code>Guest</code>用户</li><li>如果<code>Guest</code>用户图标有一个<code>向下的箭头</code>，则表示该用户被禁用；</li><li><code>guest</code>取消禁用的方法：双击<code>guest</code>，修改<code>Guest</code>用户的属性；</li><li>该属性中的<code>账户已禁用</code><strong>取消</strong></li></ol>]]></content>
    
    <summary type="html">
    
      如果打印机不能连接，需要怎么办呢？
    
    </summary>
    
      <category term="杂谈" scheme="http://www.wanqing520.cn/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>2016-10-12-Spring MV异步请求</title>
    <link href="http://www.wanqing520.cn/201610/12/java/2016-10-12-SpringMVC-async-reuest.html"/>
    <id>http://www.wanqing520.cn/201610/12/java/2016-10-12-SpringMVC-async-reuest.html</id>
    <published>2016-10-12T08:58:14.000Z</published>
    <updated>2017-12-13T11:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第22章-异步请求"><a href="#第22章-异步请求" class="headerlink" title="第22章 异步请求"></a>第22章 异步请求</h1><p>Servlet3.0规范新增了对异步请求的支持，Spring MVC也在此基础上对异步请求提供了方便。异步请求是在处理比较耗时的业务时先将request返回，然后另起线程处理耗时的业务，处理完后再返回给用户。</p><p>异步请求可以给我们带来很多方便，最直接的用法就是处理耗时的业务，比如，需要查询数据库、需要调用别的服务器来处理等情况下可以先将请求返回给客户端，然后启用新线程处理耗时业务，等处理完成后再将结果返回给用户。稍微扩展一下还可以实现订阅者模式的消息订阅功能，比如，当有异常情况发生时可以主动将相关信息发给运维人员，还有现在很多邮箱系统中收到新邮件的自动提示功能也是这种技术。甚至更进一步的使用方式是在浏览器上做即时通信的程序！</p><p>HTTP协议是单向的，只能客户端自己拉不能服务器主动推，Servlet对异步请求的支持并没有修改HTTP协议，而是对Http的巧妙利用。异步请求的核心原理主要分为两大类，一类是轮询，另一类是长连接。轮询就是定时自动发起请求检查有没有需要返回的数据，这种方式对资源的浪费是比较大的；长连接的原理是在客户端发起请求，服务端处理并返回后并不结束连接，这样就可以在后面再次运回给客户端数据。Servlet对异步请求的支持其实采用的是长连接的方式，也就是说，异步请求中在原始的请求返回的时候并没有关闭连接，关闭的只是处理请求的那个线程（一般是回收的线程池里了），只有在异步请求全部处理完之后才会关闭连接。</p><h2 id="22-1-Servlet3．O对异步请求的支持"><a href="#22-1-Servlet3．O对异步请求的支持" class="headerlink" title="22.1  Servlet3．O对异步请求的支持"></a>22.1  Servlet3．O对异步请求的支持</h2><p>在Servlet3.0规范巾使用异步处理请求非常简单，只需要在请求处理过程中调用request的startAsync方法即可，其返回值是AsyncContext类型。</p><p>AsyncContext在异步请求中充当着非常重要的角色，可以称为异步请求上下文也可以称为异步请求容器，无论叫什么其实就是个名字，它的作用是保存与异步请求相关的所有信息，类似于Servlet中的ServletContext。异步请求主要是使用AsyncContext进行操作，它是在请求处理的过程中调用Request的startAsync方法返回的，需要注意的是多次调用startAsync方法返回的是同一个AsyncContext。AsyncContext接口定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ASYNC_REQUEST_URI = <span class="string">"javax.servlet.async.request_uri"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ASYNC_CONTEXT_PATH = <span class="string">"javax.servlet.async.context_path"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ASYNC_PATH_INFO = <span class="string">"javax.servlet.async.path_info"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ASYNC_SERVLET_PATH = <span class="string">"javax.servlet.async.servlet_path"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String ASYNC_QUERY_STRING = <span class="string">"javax.servlet.async.query_string"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletRequest <span class="title">getRequest</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ServletResponse <span class="title">getResponse</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasOriginalRequestAndResponse</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(String path)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">complete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(Runnable run)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(AsyncListener listener)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addListener</span><span class="params">(AsyncListener listener,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ServletRequest servletRequest,</span></span></span><br><span class="line"><span class="function"><span class="params">                            ServletResponse servletResponse)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends AsyncListener&gt; <span class="function">T <span class="title">createListener</span><span class="params">(Class&lt;T&gt; clazz)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(<span class="keyword">long</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getTimeout</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，getResponse方法用得非常多，它可以获取到response，然后就可以对response进行各种操作了；dispatch方法用于将请求发送到一个新地址，有三个重载实现方法，其中没有参数dispatch方法的会发送到request原来的地址（如果有forward则使用forward后的最后一个地址）．一个path参数的dispatch方法直接将path作为地址，两个参数的dispatch方法可以发送给别的应用指定的地址；complete方法用于通知容器请求已经处理完了；start方法用于启动实际处理线程．不过也可以自己创建线程在其中使用AsyncContext保存的信息(如response)进行处理；addListener用于添加监听器；setTimeout方法用于修改超时时间，因为异步请求一般耗时比较长，而正常的请求设置的有效时长一般比较短，所以在异步请求中很多时候都需要修改超时的时间。</p><h3 id="22-1-1-Servlet-3-0处理异步请求实例"><a href="#22-1-1-Servlet-3-0处理异步请求实例" class="headerlink" title="22.1.1 Servlet 3.0处理异步请求实例"></a>22.1.1 Servlet 3.0处理异步请求实例</h3><p>使用Servlet 3.0处理异步请求需要三步：①配置Servlet时将async-supported设置为true；②在Servlet处理方法中调用Request的startAsync方法启动异步处理；③使用第2步中返同的<br>AsyncContext处理异步请求。</p><p>要想使用Servlet 3.0异步请求的功能需要在配置Servlet时将async-supported设置为true，比如，配置一个叫WorkServlet的可以处理异步请求的Servlet。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;WorkServlet&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">com</span>.<span class="title">excelib</span>.<span class="title">servlet</span>.<span class="title">WorkServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">async</span>-<span class="title">supported</span>&gt;<span class="title">true</span>&lt;/<span class="title">async</span>-<span class="title">supported</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">WorkServlet</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">work</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后新建一个叫WorkServlet的Servlet，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.excelib.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse res)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 设置contentType、关闭缓存</span></span><br><span class="line">        res.setContentType(<span class="string">"text/plain;charset=UTF-8"</span>);</span><br><span class="line">        res.setHeader(<span class="string">"Cache-Control"</span>, <span class="string">"private"</span>);</span><br><span class="line">        res.setHeader(<span class="string">"Pragma"</span>, <span class="string">"no-cache"</span>);</span><br><span class="line">        <span class="comment">// 原始请求可以做一些简单业务的处理</span></span><br><span class="line">        <span class="keyword">final</span> PrintWriter writer = res.getWriter();</span><br><span class="line">        writer.println(<span class="string">"老板检查当前需要做的工作"</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">        <span class="comment">// jobs表示需要做的工作，使用循环模拟初始化</span></span><br><span class="line">        List&lt;String&gt; jobs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            jobs.add(<span class="string">"job"</span>+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用request的startAsync方法开启异步处理</span></span><br><span class="line">        <span class="keyword">final</span> AsyncContext ac = req.startAsync();</span><br><span class="line">        <span class="comment">// 具体处理请求，内部处理启用了新线程，不会阻塞当前线程</span></span><br><span class="line">        doWork(ac, jobs);</span><br><span class="line">        writer.println(<span class="string">"老板布置完工作就走了"</span>);</span><br><span class="line">        writer.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">(AsyncContext ac, List&lt;String&gt; jobs)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 设置超时时间1小时</span></span><br><span class="line">        ac.setTimeout(<span class="number">1</span>*<span class="number">60</span>*<span class="number">60</span>*<span class="number">1000L</span>);</span><br><span class="line">        <span class="comment">// 使用新线程具体处理请求</span></span><br><span class="line">        ac.start(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 从AsyncContext获取到Response进而获取到Writer</span></span><br><span class="line">                    PrintWriter w = ac.getResponse().getWriter();</span><br><span class="line">                    <span class="keyword">for</span>(String job:jobs)&#123;</span><br><span class="line">                        w.println(<span class="string">"\""</span>+job+<span class="string">"\"请求处理中。。。"</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">1</span> * <span class="number">1000L</span>);</span><br><span class="line">                        w.flush();</span><br><span class="line">                    &#125;</span><br><span class="line">                  <span class="comment">// 发出请求处理完成通知</span></span><br><span class="line">                    ac.complete();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的异步处理过程是在doWork方法中，它使用req．startAsync()返回的AsyncContext来处理的请求，处理完成后调用complete方法发出完成通知告诉容器请求已经处理完。doPost中除了startAsync和doWork外都是正常的操作，而且都有注释，就不解析了。当调用诸求时，返回页面结果如图22-1所示。</p><p>一个通过异步请求完成工作的示例程序就写完了。</p><h3 id="22-1-2异步请求监听器AsyncListener"><a href="#22-1-2异步请求监听器AsyncListener" class="headerlink" title="22.1.2异步请求监听器AsyncListener"></a>22.1.2异步请求监听器AsyncListener</h3><p>上面的程序已经可以完成工作了，不过还不够完善。老板这个职业是需要思考宏观问题的，它需要宏观的数据，所以在干完活后最好给领导汇报一下什么时候干完的、干的怎么样、有没有出什么问题等综合性的数据，不过这些事情按照分工并不应该由实际干活的人来做，如果非让它们做就可能会影响效率，而且它们汇报的数据也有可能不真实，所以老板应该找专人来做这件事，这就有了二线人员。在Servlet异步请求中干这个活的二线人员就是AsyncListener监听器，AsyncListener定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimeout</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartAsync</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException</span>;     </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>onComplete方法在请求处理完成后调用，onTimeout方法在超时后调用，onError方法在出错时调用，onStartAsync方法在Request调用startAsync方法启动异步处理时调用。</p><p>这里需要注意的是只有在调用request.startAsync前将监听器添加到AsyncContext，监听器的onStartAsync方法才会起作用，而调用startAsync前AsyncContext还不存在，所以第一次调用startAsync是不会被监听器中的onStartAsync方法捕获的，只有在超时后又重新开始的情况下onStartAsync方法才会起作用。这一般也没有什么太大的问题，就像上面的例子中开始的时候是老板安排的任务，他自己当然知道，所以不汇报也没关系，不过如果到了时间节点任务没完成又重新开始了那还是要汇报的。</p><p>我们给前面的WorkServlet添加两个AsyncListener监听器BossListener和LeaderListener．一个用来给老板汇报，另一个用来给项目负责人汇报，它们都是定义在WorkServlet中的私有类，而且代码也都一样，其中BossListener的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BossListener</span> <span class="keyword">implements</span> <span class="title">AsyncListener</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> SimpleDateFormat formatter = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在"</span> + formatter.format(<span class="keyword">new</span> Date()) + <span class="string">"工作处理完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在"</span> + formatter.format(<span class="keyword">new</span> Date()) + <span class="string">"工作处理出错，详情如下：\t"</span></span><br><span class="line">            +event.getThrowable().getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartAsync</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在"</span> + formatter.format(<span class="keyword">new</span> Date()) + <span class="string">"工作处理开始"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimeout</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"在"</span> + formatter.format(<span class="keyword">new</span> Date()) + <span class="string">"工作处理超时"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后将监听器注册到WorkServlet中，注册方法是在获取到AsyncContext后将监听器添加进去，相关代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用request的startAsync方法开启异步处理</span></span><br><span class="line"><span class="keyword">final</span> AsyncContext ac = req.startAsync();</span><br><span class="line"><span class="comment">// 添加两个监听器</span></span><br><span class="line">ac.addListener(<span class="keyword">new</span> BossListener());</span><br><span class="line">ac.addListener(<span class="keyword">new</span> LeaderListener(), req, res);</span><br><span class="line"><span class="comment">// 具体处理请求，内部处理启用了新线程，不会阻塞当前线程</span></span><br><span class="line">doWork(ac, jobs);</span><br><span class="line">writer.println(<span class="string">"老板布置完工作就走了"</span>);</span><br><span class="line">writer.flush();</span><br></pre></td></tr></table></figure></p><p>这样就将两个监听器注册完了。这里之所以添加了两个监听器，是要告诉大家一个AsyncContext可以添加多个监听器，而且有两个重载的添加方法。在监听器中可以使用AsyncEvent事件获取Request、Response以及在有异常的时候获取Throwable，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">event.getSuppliedRequest();</span><br><span class="line">event.getSuppliedReponse();</span><br><span class="line">event.getThrowable();</span><br></pre></td></tr></table></figure></p><h2 id="22-2-Spring-MVC中的异步请求"><a href="#22-2-Spring-MVC中的异步请求" class="headerlink" title="22.2  Spring MVC中的异步请求"></a>22.2  Spring MVC中的异步请求</h2><p>Spring MVC为了方便使用异步请求专门提供了AsyncWebRequest类型的request，并且提供了处理异步请求的管理器WebAsyncManager和工具WebAsyncUtils。    </p><p>Spring MVC将异步请求细分为了Callable、WebAsyncTask、DeferredResult和ListenableFuture四种类型。前两种是一类，它们的核心是Callable，这一类很容易理解，因为大家对Callable应该都比较熟悉；DeferredResult类可能不是很容易理解，因为它是Spring MVC自己定义的类型，我们平时可能没使用过，而且相关资料也不多，所以刚接触的时候会觉得不知道从哪里人手，不过弄明白后其实是非常简单的；ListenableFuture足Spring MVC4.0新增的，它在Java的Future基础上增加了设置回调方法的功能，主要用于需要在处理器中调用别的资源（如别的url）的情况，Spring MVC专门提供了AsyncRestTemplate方法调用别的资源，并返回ListenableFuture类型。</p><p>本章先分析Spring MVC中异步请求使用到的组件，然后分析Spring MVC是怎么使用这些组件处理异步请求的，最后再分别对每一类返回值进行介绍。</p><h3 id="22-2-1-Spring-MVC中异步请求相关组件"><a href="#22-2-1-Spring-MVC中异步请求相关组件" class="headerlink" title="22.2.1 Spring MVC中异步请求相关组件"></a>22.2.1 Spring MVC中异步请求相关组件</h3><p>这里主要分析AsyncWebRequest、WebAsyncManager和WebAsyncUtils组件。WebAsyncManager里面还包含了一些别的组件，在分析的过程中也一起分析。<br><strong>AsyncWebRequest</strong><br>首先来看AsyncWebRequest，它是专门用来处理异步请求的request，定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AsyncWebRequest</span> <span class="keyword">extends</span> <span class="title">NativeWebRequest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(Long timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addTimeoutHandler</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addCompletionHandler</span><span class="params">(Runnable runnable)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startAsync</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAsyncStarted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isAsyncComplete</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中，addTimeoutHandler方法和addCompletionHandler方法分别用于添加请求超时和请求处理完成的处理器，其作用相当于AsyncListener监听器中的onTimeout和onComplete方法；isAsyncStarted方法用于判断是否启动了异步处理；isAsyncComplete方法用于判断异步处理是否已经处理完了。别的方法都与AsyncContext中的同名方法作用一样，就不一一解释了。它的实现类有两个，一个是NoSupportAsyncWebRequest，另一个是StandardServletAsyncWebRequest，前者不支持异步请求，所以在Spring MVC中实际用作异步请求的request是StandardServletAsync WebRequest.</p><p>StandardServletAsyncWebRequest除了实现了AsyncWebRequest接口，还实现了AsyncListener接口，另外还继承了ServletWebRequest，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardServletAsyncWebRequest</span> <span class="keyword">extends</span> <span class="title">ServletWebRequest</span> <span class="keyword">implements</span> <span class="title">AsyncWebRequest</span>, <span class="title">AsyncListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Long timeout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AsyncContext asyncContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AtomicBoolean asyncCompleted = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Runnable&gt; timeoutHandlers = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> List&lt;Runnable&gt; completionHandlers = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create a new instance for the given request/response pair.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> request current HTTP request</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> response current HTTP response</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StandardServletAsyncWebRequest</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;In Servlet 3 async processing, the timeout period begins after the</span></span><br><span class="line"><span class="comment"> * container processing thread has exited.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTimeout</span><span class="params">(Long timeout)</span> </span>&#123;</span><br><span class="line">Assert.state(!isAsyncStarted(), <span class="string">"Cannot change the timeout with concurrent handling in progress"</span>);</span><br><span class="line"><span class="keyword">this</span>.timeout = timeout;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTimeoutHandler</span><span class="params">(Runnable timeoutHandler)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.timeoutHandlers.add(timeoutHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCompletionHandler</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.completionHandlers.add(runnable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAsyncStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((<span class="keyword">this</span>.asyncContext != <span class="keyword">null</span>) &amp;&amp; getRequest().isAsyncStarted());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Whether async request processing has completed.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;It is important to avoid use of request and response objects after async</span></span><br><span class="line"><span class="comment"> * processing has completed. Servlet containers often re-use them.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAsyncComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.asyncCompleted.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startAsync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Assert.state(getRequest().isAsyncSupported(),</span><br><span class="line"><span class="string">"Async support must be enabled on a servlet and for all filters involved "</span> +</span><br><span class="line"><span class="string">"in async request processing. This is done in Java code using the Servlet API "</span> +</span><br><span class="line"><span class="string">"or by adding \"&lt;async-supported&gt;true&lt;/async-supported&gt;\" to servlet and "</span> +</span><br><span class="line"><span class="string">"filter declarations in web.xml."</span>);</span><br><span class="line">Assert.state(!isAsyncComplete(), <span class="string">"Async processing has already completed"</span>);</span><br><span class="line"><span class="keyword">if</span> (isAsyncStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.asyncContext = getRequest().startAsync(getRequest(), getResponse());</span><br><span class="line"><span class="keyword">this</span>.asyncContext.addListener(<span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.timeout != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.asyncContext.setTimeout(<span class="keyword">this</span>.timeout);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Assert.notNull(<span class="keyword">this</span>.asyncContext, <span class="string">"Cannot dispatch without an AsyncContext"</span>);</span><br><span class="line"><span class="keyword">this</span>.asyncContext.dispatch();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">// Implementation of AsyncListener methods</span></span><br><span class="line"><span class="comment">// ---------------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStartAsync</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onTimeout</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Runnable handler : <span class="keyword">this</span>.timeoutHandlers) &#123;</span><br><span class="line">handler.run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">(AsyncEvent event)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (Runnable handler : <span class="keyword">this</span>.completionHandlers) &#123;</span><br><span class="line">handler.run();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.asyncContext = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">this</span>.asyncCompleted.set(<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的代码比较长，不过很容易理解，它里面封装了个AsyncContext类型的属性asyncContext，在startAsync方法中会将Request#startAsync返回的AsyncContext设置给它，然后在别的地方主要使用它来完成各种功能。</p><p>另外，南于StandardServletAsyncWebRequest实现了AsyncListener接口，所以它自己就是一个监听器，而且在startAsync方法中在创建出AsyncContext后会将自己作为监听器添加进去。监听器实现方法中onStartAsync方法和onError方法是空实现，onTimeout方法和onComplete方法分别调用了封装的两个List类型的属性timeoutHandlers和completionHandlers所保存的Runnable方法，这样在使用时只需要简单地将需要监听超时和处理完成的监听方法添加到这两个属性中就可以了。</p><p><strong>WebAsyncManager</strong></p><p>WebAsyncManager是Spring MVC处理异步请求过程中最核心的类，它管理着整个异步处理的过程。</p><p>WebAsyncManager中最重要的两个方法是startCallableProcessing和startDeferredResultProcessing，这两个方法是启动异步处理的人口方法，它们一共做了三件事：①启动异步处理；②给Request设置相应属性（主要包括timeout、timeoutHandler和completionHandler）；③在相应位置调用相应的拦截器。这里的拦截器是Spring MVC自己定义的。</p><p>startCallableProcessing方法用于处理Callable和WebAsyncTask类型的异步请求，使用的拦截器类型是CallableProcessingInterceptor，拦截器封装在CallablelnterceptorChain粪型的拦截器链中统一调用。</p><p>startDeferredResultProcessing方法用于处理DeferredResult和ListenableFuture类型的异步请求，使用的拦截器是DeferredResultProcessinglnterceptor拦截器，拦截器封装在DeferredResultlnterceptorChain类型的拦截器链中统一调用。</p><p>这两个拦截器的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CallableProcessingInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object RESULT_NONE = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Object RESPONSE_HANDLED = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span>  <span class="title">beforeConcurrentHandling</span><span class="params">(NativeWebRequest request, Callable&lt;T&gt; task)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">preProcess</span><span class="params">(NativeWebRequest request, Callable&lt;T&gt; task)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">postProcess</span><span class="params">(NativeWebRequest request, Callable&lt;T&gt; task, Object concurrentResult)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function">Object <span class="title">handleTimeout</span><span class="params">(NativeWebRequest request, Callable&lt;T&gt; task)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(NativeWebRequest request, Callable&lt;T&gt; task)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>拦截器的作用就是在不同的时间点通过执行相应的方法来做一些额外的事情，所以要学习一种拦截器主要就是要理解它里边的各个方法执行的时间点。这两拦截器都定义了5个方法，方法名也都一样，而且从名字就很容易理解它们执行的时间点，就不分别解释了。需要注意的是，beforeConcurrentHandling方法是在并发处理前执行的，也就是会在主线程中执行，其他方法都在具体处理请求的子线程中执行。</p><p>CallableInterceptorChain和DeferredResultlnterceptorC hain分别用于封装两个Interceptor，它们都是将多个相应的拦截器封装到一个List类型的属性，然后在相应的方法中调用所封装的Interceptor相应方法进行处理。大家是不是很熟悉？它跟前面多次便用的XXXComposite组件类似，也是责任链模式。不过和XXXComposite组件不同的是，这里的方法名与Interceptor中稍有区别，它们的对应关系如下：</p><ol><li>applyBe foreConcurrentHandling：对应Interceptor中的beforeConcurrentHandling方法。</li><li>applyPreProcess：对应Interceptor中的preProcess方法。</li><li>applyPostProcess：对应Interceptor中的postProcess方法。</li><li>triggerAfterTimeout:对应Interceptor中的afierTimeout方法。</li><li>triggerAfterCompletion：对应Interceptor中的afterCompletion方法。</li></ol><p>理解了这些方法就知道Interceptor和InterceptorChain的作用了，它们都是在WebAsyncManager中相应位置调用的。</p><p>在正式分析WebAsyncManager前再看一下WebAsyncTask类，只有理解了这个类才能看明白WebAsyncManager中酌stariCallableProcessing方法。WebAsyncTask的作用主要是封装Callable方法，并且提供了一些异步调用相关的属性，理解了其中包含的属性就明白这个类了，其中属性定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;V&gt; callable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Long timeout;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> AsyncTaskExecutor executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String executorName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Callable&lt;V&gt; timeoutCallback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Runnable completionCallback;</span><br></pre></td></tr></table></figure></p><p>callable用来实际处理请求；timeout用来设置超时时间；executor用来调用callable；executorName用来用容器中注册的名字配置executor；beanFactory用于根据名字获取executor; timeoutCallback相completionCallback分别用于执行超时和请求处理完成的回调。</p><p>这里的executor可以直接设置到WebAsyncTask中，也可以使用注册在容器中的名字来设置executorName属性，如果是使用名字来设置的WebAsyncTask的getExecutor方法会从beanFactory中根据名字executorName获取AsyncTaskExecutor，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AsyncTaskExecutor <span class="title">getExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.executor != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.executor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.executorName != <span class="keyword">null</span>) &#123;</span><br><span class="line">Assert.state(<span class="keyword">this</span>.beanFactory != <span class="keyword">null</span>, <span class="string">"BeanFactory is required to look up an executor bean by name"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.beanFactory.getBean(<span class="keyword">this</span>.executorName, AsyncTaskExecutor.class);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>多知道点</strong></p><center>如何在Java中使用并发处理</center><hr><p>并发处理是通过多线程完成的，在Java中定义一个多线程的任务可以通过实现Runnable或者Callable接口完成，先来看一下Runnable接定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When an object implementing interface &lt;code&gt;Runnable&lt;/code&gt; is used</span></span><br><span class="line"><span class="comment">     * to create a thread, starting the thread causes the object's</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;run&lt;/code&gt; method to be called in that separately executing</span></span><br><span class="line"><span class="comment">     * thread.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * The general contract of the method &lt;code&gt;run&lt;/code&gt; is that it may</span></span><br><span class="line"><span class="comment">     * take any action whatsoever.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     java.lang.Thread#run()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Runnable里只有一个run方法，我们只需要将需要执行的代码放到里面即可，行需要新建一个线程来调用，示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Runnable task = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        System.out.<span class="title">println</span><span class="params">(<span class="string">"do task"</span>)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(task);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里新建了task的Runnable类型任务，然后使用它创建了Thread并调用start方法执行了任务。需要说明的是，Thread本身也继承了Runnable接口，所以直接使用Thread来创建Runnable类型的任务然后执行，比如，上面的代码可以修改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"do task"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;.start();</span><br></pre></td></tr></table></figure></p><p>这样一句代码就可以完成了。</p><p>在JavaI.5中新增了Callable接口，定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Callable里面是call方法，而且可以有返回值还可以处理异常。Callable的执行需要有一个Executor容器来调用，就像Runnable任务需要Thread来调用一样，而且Executor也可以调用Runnable类型的任务。ExecutoriB用后会返回一个Future类型的返回值，我们可以调用Future的get方法来获取Callable中call方法的返回值，不过这个方法是阻塞的，只有call方法执行完后才会返回，示例如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ExecutorsService = Executors.newCachedThreadPool();</span><br><span class="line">Callable callableTask = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"do task"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Future&lt;String&gt; future = executor.submit(callableTask);</span><br><span class="line">System.out.println(<span class="string">"after submit task"</span>);</span><br><span class="line">String result = future.get();</span><br><span class="line">System.out.println(<span class="string">"after future.get()"</span>);</span><br><span class="line">System.out.println(<span class="string">"result="</span>+result);</span><br><span class="line">executor.shudown();</span><br></pre></td></tr></table></figure></p><p>这里定义了一个Callable类型的callableTask任务，在其call方法中会等待1秒然后输出<code>dotask</code>并返回<code>ok</code>。Executor调用submit方法提交任务后主程序输出<code>aftersubmittask</code>，这个应该在异步任务返回之前输出，因为方法需要等待1秒，输出<code>aftersubmittask</code>后调用future.get()，这时主线程会阻塞,直到call方法返回，然后输出”afterfuture.get()”，最后输出call返回的结果”ok”，程序运行后控制台打印如下：</p><blockquote><p>after submit task<br>do task<br>after future.get()<br>result=ok</p></blockquote><p>下面来看WebAsyncManager，首先介绍它里面的几个重要属性：</p><ol><li>timeoutCallablelnterceptor：CallableProcessinglnterceptor类型,专门用于Callable和WebAnsyncTask类型超时的拦截器</li><li>timeoutDeferredResultlnterceptor：DeferredResultProcessinglnterceptor类型，专门用于DeferredResult和ListenableFuture类型超时的拦截器。</li><li>callablelnterceptors: Map类型，用于所有Callable和WebAsyncTask类型的拦截器。</li><li>deferredResultlnterceptors：Map类型，用于所有DeferredResult和ListenableFuture类型的拦截器。</li><li>asyncWebRequest：为了支持异步处理而封装的request。</li><li>taskExecutor：用于执行Callable和WebAsyncTask类型处理，如果WebAsyncTask中没有定义executor则使用WebAsyncManager中的taskExecutor。</li></ol><p>下面分析WebAsyncManager里最核心的两个方法startCallableProcessing和startDeferredResultProcessing，这两个方法的逻辑基本一样，选择其中的startCallableProcessing来分析，这个方法用于启动Callable和WebAsyncTask类型的处理，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Use the given &#123;<span class="doctag">@link</span> WebAsyncTask&#125; to configure the task executor as well as</span></span><br><span class="line"><span class="comment"> * the timeout value of the &#123;<span class="doctag">@code</span> AsyncWebRequest&#125; before delegating to</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@link</span> #startCallableProcessing(Callable, Object...)&#125;.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webAsyncTask a WebAsyncTask containing the target &#123;<span class="doctag">@code</span> Callable&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> processingContext additional context to save that can be accessed</span></span><br><span class="line"><span class="comment"> * via &#123;<span class="doctag">@link</span> #getConcurrentResultContext()&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception if concurrent processing failed to start</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startCallableProcessing</span><span class="params">(<span class="keyword">final</span> WebAsyncTask&lt;?&gt; webAsyncTask, Object... processingContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Assert.notNull(webAsyncTask, <span class="string">"WebAsyncTask must not be null"</span>);</span><br><span class="line">Assert.state(<span class="keyword">this</span>.asyncWebRequest != <span class="keyword">null</span>, <span class="string">"AsyncWebRequest must not be null"</span>);</span><br><span class="line"></span><br><span class="line">Long timeout = webAsyncTask.getTimeout();</span><br><span class="line"><span class="keyword">if</span> (timeout != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.asyncWebRequest.setTimeout(timeout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AsyncTaskExecutor executor = webAsyncTask.getExecutor();</span><br><span class="line"><span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.taskExecutor = executor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;CallableProcessingInterceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;CallableProcessingInterceptor&gt;();</span><br><span class="line">interceptors.add(webAsyncTask.getInterceptor());</span><br><span class="line">interceptors.addAll(<span class="keyword">this</span>.callableInterceptors.values());</span><br><span class="line">interceptors.add(timeoutCallableInterceptor);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Callable&lt;?&gt; callable = webAsyncTask.getCallable();</span><br><span class="line"><span class="keyword">final</span> CallableInterceptorChain interceptorChain = <span class="keyword">new</span> CallableInterceptorChain(interceptors);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.asyncWebRequest.addTimeoutHandler(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">logger.debug(<span class="string">"Processing timeout"</span>);</span><br><span class="line">Object result = interceptorChain.triggerAfterTimeout(asyncWebRequest, callable);</span><br><span class="line"><span class="keyword">if</span> (result != CallableProcessingInterceptor.RESULT_NONE) &#123;</span><br><span class="line">setConcurrentResultAndDispatch(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.asyncWebRequest.addCompletionHandler(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">interceptorChain.triggerAfterCompletion(asyncWebRequest, callable);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">interceptorChain.applyBeforeConcurrentHandling(<span class="keyword">this</span>.asyncWebRequest, callable);</span><br><span class="line">startAsyncProcessing(processingContext);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.taskExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Object result = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">interceptorChain.applyPreProcess(asyncWebRequest, callable);</span><br><span class="line">result = callable.call();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">result = ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">result = interceptorChain.applyPostProcess(asyncWebRequest, callable, result);</span><br><span class="line">&#125;</span><br><span class="line">setConcurrentResultAndDispatch(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过注释可以看到startCallableProcessing方法主要做了5件事：①将webAsyncTask中相关属性取出并设置到对应的地方；②初始化拦截器链；③给asyncWebRequest设置timeoutHandler和completionHandler；④执行处理器链中相应方法；⑤启动异步处理并使用taskExecutor提交任务。</p><p>对其中的启动处理和执行处理详细解释一下，启动处理是调用了startAsyncProcessing方法，其中做了三件事：①调用clearConcurrentResult方法清空之前并发处理的结果；②谰用asyncWebRequest的startAsync方法启动异步处理；③将processingContext设置给concurrentResultContext属性。startAsyncProcessing方法的代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAsyncProcessing</span><span class="params">(Object[] processingContext)</span> </span>&#123;</span><br><span class="line">clearConcurrentResult();</span><br><span class="line"><span class="keyword">this</span>.concurrentResultContext = processingContext;</span><br><span class="line"><span class="keyword">this</span>.asyncWebRequest.startAsync();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">HttpServletRequest request = <span class="keyword">this</span>.asyncWebRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line">String requestUri = urlPathHelper.getRequestUri(request);</span><br><span class="line">logger.debug(<span class="string">"Concurrent handling starting for "</span> + request.getMethod() + <span class="string">" ["</span> + requestUri + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Clear &#123;<span class="doctag">@linkplain</span> #getConcurrentResult() concurrentResult&#125; and</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #getConcurrentResultContext() concurrentResultContext&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearConcurrentResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.concurrentResult = RESULT_NONE;</span><br><span class="line"><span class="keyword">this</span>.concurrentResultContext = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>processingContext参数传进来的是处理器中使用的ModelAndViewContainer，concurrentResultContext用来在WebAsyncManager中保存ModelAndViewContainer，在请求处理完成后会设置到RequestMappingHandlerAdapter中，具体过程后面再分析。</p><p>下面再来说一下执行处理，执行处理使用的是taskExecutor，不过需要注意的是，这里并没直接使用taskExecutor.submit(callable)来提交，而是提交了新建的Runnable，并将Callable的call方法直接放在run方法里调用。代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.taskExecutor.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Object result = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    interceptorChain.applyPreProcess(asyncWebRequest, callable);</span><br><span class="line">    result = callable.call();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    result = ex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">    result = interceptorChain.applyPostProcess(asyncWebRequest, callable, result);</span><br><span class="line">    &#125;</span><br><span class="line">    setConcurrentResultAndDispatch(result);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure></p><p>这么做主要有两个作用：①可以在处理过程中的相应位置调用拦截器链中相应的方法；②在call方法执行完之前不会像Future#get()那样阻塞线程。</p><p>不过Runnable是没有返回值的，所以Callable处理的结果需要自己从run方法内部传递出来，WebAsyncManager中专门提供了一个setConcurrentResultAndDispatch方洪来处理返回的结果，这里边会将处理的结果传递出来，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setConcurrentResultAndDispatch</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (WebAsyncManager.<span class="keyword">this</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (hasConcurrentResult()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.concurrentResult = result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.asyncWebRequest.isAsyncComplete()) &#123;</span><br><span class="line">logger.error(<span class="string">"Could not complete async processing due to timeout or network error"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Concurrent result value ["</span> + <span class="keyword">this</span>.concurrentResult +</span><br><span class="line"><span class="string">"] - dispatching request to resume processing"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.asyncWebRequest.dispatch();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>concurrentResult是WebAsyncManager中用来保存异步处理结果的属性，hasConcurrentResult方法用来判断concurrentResult是否已经存在返回值。整个方法过程是：如果concurrentResult已经有返回值则直接返回，否则将传人的参数设置到concurrentResult，然后调用asyncWebRequest.isAsyncComplete()检查Request是否已设置为异步处理完成状态（网络中断会造成Request设置为异步处理完成状态），如果是则保存错误日志并返回，否则调用asyncWebRequest.dispatch0发送请求。SpringMVC申异步请求处理完成后会再次发起一个相同的请求，然后在HandlerAdapter中使用一个特殊的HandlerMethod来处理它，具体过程后面再讲解，不过通过Request的dispatch方法发起的请求使用的还是原来的Request，也就是说原来保存在Request中的属性不会丢失。</p><p>startDeferredResultProcessing方法和startCallableProcessing方法执行过程类似，只是并没有使用taskExecutor来提交执行，这是因为DeferredResult并不需要执行处理，在后面讲了DeferredResult的用法后大家就明白了。</p><p>WebAsyncManager就分析到这里，下面来看WebAsyncUtils。</p><p><strong>WebAsyncUtils</strong></p><p>WebAsyncUtils里面提供了四个静态方法，其中一个是private权限，只供内部调用的，也就是一共提供了三个供外部使用的静态方法。它们定义如下：</p><ol><li><code>public static WebAsyncManager getAsyrtcManager (ServletRequest servletRequest)</code></li><li><code>public static WebAsyncManager getAsyncManager (WebRequest webRequest)</code></li><li>`public  static  AsyncWebRequest  createAsyncWebRequest (HttpServletRequest request, HttpServletResponse response)</li></ol><p>两重载的getAsyncManager方法通过Request获取WebAsyncManager，它们一个使用ServletRequest类型的Request，一个使用WebRequest类型的Request，获取过程都是先判断Request属性里是否有保存的WebAsyncManager对象，如果有则取出后直接返回，如果没有则新建一个设置到Request的相应属性中并返回，下次再获取时直接从Request属性中取出。</p><p>createAsyncWebRequest方法用于创建AsyncWebRequest，它使用ClassUtils.hasMethod判断传人的Request是否包含startAsync方法从而判断是否支持异步处理，如果不支持则新建NoSupportAsyncWebRequest类型的Request并返回，如果支持则调用createStandardServletAsyncWebRequest方法创建StandardServletAsync WebRequest类型的Request并返回。</p><h3 id="22-2-2-Spring-MVC对异步请求的支持"><a href="#22-2-2-Spring-MVC对异步请求的支持" class="headerlink" title="22.2.2 Spring MVC对异步请求的支持"></a>22.2.2 Spring MVC对异步请求的支持</h3><p>Spring MVC对异步请求的处理主要在四个地方进行支持，详述如下：<br>1)FrameworkServlet中给当前请求的WebAsyncManager添加了CallableProcessinglnterceptor类型的拦截器RequestBindinglnterceptor，这是定义在FrameworkServlet内部的一个私有的拦截器，其作用还是跟FrameworkServlet处理正常请求一样，在请求处理前将当前请求的LocaleContext和ServletRequestAttributes设置到了LocaleContextHolder和RequestContextHolder中，并在请求处理完成后恢复，添加过程在processRequest方法中，相关代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), <span class="keyword">new</span> RequestBindingInterceptor());</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestBindingInterceptor</span> <span class="keyword">extends</span> <span class="title">CallableProcessingInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">preProcess</span><span class="params">(NativeWebRequest webRequest, Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"><span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">HttpServletResponse response = webRequest.getNativeRequest(HttpServletResponse.class);</span><br><span class="line">initContextHolders(request, buildLocaleContext(request), buildRequestAttributes(request, response, <span class="keyword">null</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">postProcess</span><span class="params">(NativeWebRequest webRequest, Callable&lt;T&gt; task, Object concurrentResult)</span> </span>&#123;</span><br><span class="line">HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);</span><br><span class="line"><span class="keyword">if</span> (request != <span class="keyword">null</span>) &#123;</span><br><span class="line">resetContextHolders(request, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>2) RequestMappingHandlerAdapter酌invokeHandleMethod方法提供了对异步请求的核心<br>支持，其中做了四件跟异步处理相关的事情：    </p><ol><li>创建AsyncWebRequest并设置超时时间，具体时间可以通过asyncRequestTimeout属性配置到RequestMappingHandlerAdapter申。</li><li>对当前请求的WebAsyncManager设置了四个属性：taskExecutor,asyncWebRequest,callablelnterceptors和deferredResultlnterceptors，除了asyncWebRequest的另外三个都可以在RequestMappingHandlerAdapter中配置，taskExecutor如果没配置将默认使用SimpleAsyncTaskExecutor。</li><li>如果当前请求是异步请求而且已经处理出了结果，则将异步处理结果与之前保存到WebAsyncManager里的ModeIAnd\fiewContainer取出来,并将WebAsyncManager里的结果清空，然后调用ServletlnvocableHandlerMethod的wrapConcurrentResult方法创建ConcurrentResultHandlerMethod类型（ServletlnvocableHandlerMethod的内部类）的ServletlnvocableHandlerMethod来替换自己，创建出来的ConcurrentResultHandlerMethod并不执行请求，它的主要功能是判断异步处理的结果是不是异常类型，如果是则抛出，如果不是则使用ReturnValueHandler对其进行解析并返回。</li><li>如果requestMappingMethod的invokeAndHandle方法执行完后检查到当前请求已经启动了异步处理，则会直接返回null。</li></ol><p>RequestMappingHandlerAdapter中相关代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">AsyncWebRequest asyncWebRequest = WebAsyncUtils.createAsyncWebRequest(request, response);</span><br><span class="line">asyncWebRequest.setTimeout(<span class="keyword">this</span>.asyncRequestTimeout);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line">asyncManager.setTaskExecutor(<span class="keyword">this</span>.taskExecutor);</span><br><span class="line">asyncManager.setAsyncWebRequest(asyncWebRequest);</span><br><span class="line">asyncManager.registerCallableInterceptors(<span class="keyword">this</span>.callableInterceptors);</span><br><span class="line">asyncManager.registerDeferredResultInterceptors(<span class="keyword">this</span>.deferredResultInterceptors);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.hasConcurrentResult()) &#123;</span><br><span class="line">Object result = asyncManager.getConcurrentResult();</span><br><span class="line">mavContainer = (ModelAndViewContainer) asyncManager.getConcurrentResultContext()[<span class="number">0</span>];</span><br><span class="line">asyncManager.clearConcurrentResult();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">"Found concurrent result value ["</span> + result + <span class="string">"]"</span>);</span><br><span class="line">&#125;</span><br><span class="line">requestMappingMethod = requestMappingMethod.wrapConcurrentResult(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requestMappingMethod.invokeAndHandle(webRequest, mavContainer);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的步骤3是调用了ServletInvocableHandlerMethod的wrapConcurrentResult方法创建了新的ServletlnvocableHandlerMethod来处理异步处理的结果，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ServletInvocableHandlerMethod <span class="title">wrapConcurrentResult</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ConcurrentResultHandlerMethod(result, <span class="keyword">new</span> ConcurrentResultMethodParameter(result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ConcurrentResultHandlerMethod是在ServletlnvocableHandlerMethod中定义的继承白ServletInvocableHandlerMethod的内部类，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Method CALLABLE_METHOD = ClassUtils.getMethod(Callable.class, <span class="string">"call"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentResultHandlerMethod</span> <span class="keyword">extends</span> <span class="title">ServletInvocableHandlerMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MethodParameter returnType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentResultHandlerMethod</span><span class="params">(<span class="keyword">final</span> Object result, ConcurrentResultMethodParameter returnType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(<span class="keyword">new</span> Callable&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (result <span class="keyword">instanceof</span> Exception) &#123;</span><br><span class="line"><span class="keyword">throw</span> (Exception) result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (result <span class="keyword">instanceof</span> Throwable) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NestedServletException(<span class="string">"Async processing failed"</span>, (Throwable) result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, CALLABLE_METHOD);</span><br><span class="line">setHandlerMethodReturnValueHandlers(ServletInvocableHandlerMethod.<span class="keyword">this</span>.returnValueHandlers);</span><br><span class="line"><span class="keyword">this</span>.returnType = returnType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bridge to actual controller type-level annotations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getBeanType() &#123;</span><br><span class="line"><span class="keyword">return</span> ServletInvocableHandlerMethod.<span class="keyword">this</span>.getBeanType();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bridge to actual return value or generic type within the declared</span></span><br><span class="line"><span class="comment"> * async return type, e.g. Foo instead of &#123;<span class="doctag">@code</span> DeferredResult&lt;Foo&gt;&#125;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> MethodParameter <span class="title">getReturnValueType</span><span class="params">(Object returnValue)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.returnType;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Bridge to controller method-level annotations.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;A extends Annotation&gt; <span class="function">A <span class="title">getMethodAnnotation</span><span class="params">(Class&lt;A&gt; annotationType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ServletInvocableHandlerMethod.<span class="keyword">this</span>.getMethodAnnotation(annotationType);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ConcurrentResultHandlerMethod调用父类的构造方法(super)将HandlerMethod中的Handler和Method都替换掉了，Handler用了新建的匿名Callable，Method使用了ServletInvocableHandlerMethod酌静态属性CALLABLE—METHOD，它代码Callable的call方法。新建的Callable的执行逻辑也非常简单，就是判断异步处理的返回值是不是异常类型，如果是则抛出异常，不是则直接返回，然后使用和原来请求一样的返回值处理器处理返回值（因为在构造方法中将原来ServletjnvocableHandlerMethod的返回值处理器设置给了自己）。</p><p>3)返回值处理器：一共有四个处理异步请求的返回值处理器，它们分别是AsyncTaskMethodReturnValueHandler、CallableMethodReturnValueHandler、De ferredResultMethodReturn ValueHandler和ListenableFutureReturnValueHandler，每一个对应一种类型的返回值，它们的作用主要是使用WebAsyncManager启动异步处理，后面依次对每一类返回值进行分析。</p><p>4)在DispatcherServlet的doDispatch方法中，当HandlerAdapter使用Handler处理完请求耐，会检查是否已经启动了异步处理，如果启动了则不再往下处理，直接返回，相关代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Actually invoke the handler.</span></span><br><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>检查方法是调用的WebAsyncManager的isConcurrentHandlingStarted方法，其实内部就是调用的request的isAsyncStarted方法，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Whether the selected handler for the current request chose to handle the</span></span><br><span class="line"><span class="comment"> * request asynchronously. A return value of "true" indicates concurrent</span></span><br><span class="line"><span class="comment"> * handling is under way and the response will remain open. A return value</span></span><br><span class="line"><span class="comment"> * of "false" means concurrent handling was either not started or possibly</span></span><br><span class="line"><span class="comment"> * that it has completed and the request was dispatched for further</span></span><br><span class="line"><span class="comment"> * processing of the concurrent result.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isConcurrentHandlingStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((<span class="keyword">this</span>.asyncWebRequest != <span class="keyword">null</span>) &amp;&amp; <span class="keyword">this</span>.asyncWebRequest.isAsyncStarted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Spring MVC中跟异步请求处理相关的四个位置孰分析完了。主要处理流程是这样的：首先在处理器中返回需要启动异步处理的类型时（四种类型）相应返同值处理器会调用WebAsyncManager的相关方法启动异步处理，然后在DispatcherServlet中将原来请求直接返回，当异步处理完成后会重新发出一个相同的请求，这时在RequestMappingHandlerAdapter中会使用特殊的ServletlnvocableHandlerMethod来处理请求，处理方法是：如果异步处理返回的结果是异常类型则抛出异常，否则直接返回异步处理结果，然后使用返回值处理器处理，接着返回DispatcherServlet中按正常流程往下处理。</p><p>异步处理完成后会重新发起一个请求，这时会重新查找HandlerMethod并初始化PathVariable、MatrixVariable等参数，重新初始化Model中的数据并再次执行Handler-Interceptor中相应的方法。这么做主要是可以复用原来的那套组件进行处理而不需要重新定义。不过新请求的HandlerMethod是用的专门的类型，而Model是使用的原来保存在WebAsyncManager的concurrentResultContext届性中的ModelAndViewContainer所保存的Model，所以这里的查找HandlerMethod和初始化Model的过程是没用的，在这里可以进行一些优化，比如，将创建ConcurrentResultHandlerMethod的过程放在HandlerMapping中（这样也更符合组件的功能），然后在调用ModeIFactory的initModel方法前判断是不是异步处理dispatcher过来的请求，如果是<br>则不再初始化了，或者干脆创建新的HandlerAdapter来处理。</p><p>除了上述可以优化的地方，这里还有两个漏洞，第一个是相应的拦截器里的方法会被调用两次，这是不合适的，而且有的时候还会出问题，比如，如果用了拦截器来检查Token．那么第一次检查通过后就会将相应内容删除，第二次再检查的时候就检查失败了，这就有问题了。第二个是通过FlashMap传递Redirect参数的情况，在前面分析FlashMapManager获取FlashMap的时候说过，每次获取后就会将相应的FlashMap删除，但异步请求会获取两次，如果异步处理器是Redirect刭的结果处理器，并且使用FlashMap传递了参数，这种情况下如果在第二次获取FlashMap的时候（异步请求处理完了）正好用户又发了一个相同的请求，而且RedirectView已经将FlashMap设置到了Session，在获取之前可能被前面的请求获取删除，导致自己获取不到，这么说不容易理解，下面将两个请求的处理过程列出来大家就容易理解了：</p><table><thead><tr><th>请求1</th><th>请求2</th></tr></thead><tbody><tr><td>saveOutputFlashMap</td><td>设置FM1</td></tr><tr><td>retrieveAndUpdate</td><td>获取到FM1</td></tr><tr><td>saveOutputFlashMap</td><td>设置FM2</td></tr><tr><td>retrieveAndUpdate</td><td>获取到FM2</td></tr><tr><td>retrieveAndUpdate</td><td>获取到null</td></tr><tr><td>retrieveAndUpdate</td><td>获取到null</td></tr></tbody></table><p>这样请求2设置的FlashMap就会被请求1的第二次retrieveAndUpdate获取到并从Session中删除，请求2就获取不到了，这样两个请求的值就都出了问题了。</p><p>这里的第二个漏洞只是从原理上来说存在，一般不会造成什么影响，因为这种情况发生的概率非常小，但第一个漏洞是比较严重的，如果真正使用了类似判断Token等的拦截器需要在具体方法内部自己处理一下。</p><p>异步处理流程就说到这里，下面分析每一类返回值的具体处理过程。</p><h3 id="22-2-3-WebAsyncTask和Calla-ble类型异步请求的处理过程及用法"><a href="#22-2-3-WebAsyncTask和Calla-ble类型异步请求的处理过程及用法" class="headerlink" title="22.2.3 WebAsyncTask和Calla ble类型异步请求的处理过程及用法"></a>22.2.3 WebAsyncTask和Calla ble类型异步请求的处理过程及用法</h3><p>当处理器方法返回WebAsyncTask或Callable类型时将自动启用异步处理。下面来看一下处理WebAsyncTask类型返回值的处理器AsyncTaskMethodReturnValueH andler．它的handleReturnValue方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WebAsyncTask&lt;?&gt; webAsyncTask = (WebAsyncTask&lt;?&gt;) returnValue;</span><br><span class="line">webAsyncTask.setBeanFactory(<span class="keyword">this</span>.beanFactory);</span><br><span class="line">WebAsyncUtils.getAsyncManager(webRequest).startCallableProcessing(webAsyncTask, mavContainer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果返回值为null，就会给mavContainer设置为请求已处理，然后返回。如果返回值不为null，调用WebAsyncManager的startCallableProcessing方法处理请求。WebAsyncManager是使用WebAsyncUtils获取的。下面来看一个例子，首先给配置Spring MVC的Servlet添加异步处理支持，也就是添加async-supported属性，代码如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>let'sGo<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>WEB-INF/let'sGo-servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">async-supported</span>&gt;</span>true<span class="tag">&lt;/<span class="name">async-supported</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>接下来写一个AsyncController，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.excelib.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/webasynctask"</span>,produces = <span class="string">"text/plain; charset=UTF-8"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> WebAsyncTask&lt;String&gt; <span class="title">webAsyncTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"WebAsyncTask处理器主线程进入"</span>);</span><br><span class="line">        WebAsyncTask&lt;String&gt; task = <span class="keyword">new</span> WebAsyncTask&lt;String&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>*<span class="number">1000L</span>);</span><br><span class="line">                System.out.println(<span class="string">"WebAsyncTask处理执行中。。。"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"久等了"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"WebAsyncTask处理器主线程退出"</span>);</span><br><span class="line">        <span class="keyword">return</span> task;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里新建了WebAsyncTask，并使用匿名类建了Callable进行异步处理，实际使用中可以在其中写数据库请求等耗时的业务，这里直接等了5秒来模拟。处理器注释了@ResponseBody，其返回值会直接返回给浏览器。当调用<code>http://localhost:8080/ webasynctask</code>时，会在等待大约5秒后返回给浏览器<code>久等了</code>三个字。</p><p>现在再返回去看WebAsyncManager的startCallableProcessing方法就容易理解了，其实就是先添加拦截器，并在相应的地方执行拦截器里的方法，最后使用taskExecutor调用返回WebAsyncTask申的Callable处理。</p><p>当然这里只是给WebAsyncTask设置了Callable，除此之外还可以设置executor、timeout、timeoutCallback和completionCallback等属性。</p><p>Callable的处理其实是在WebAsyncManager内部封装成WebAsyncTask后再处理的。当处理器中返回Callable类型的返回值时，Spring MVC会使用CallableMethodReturnValueHandler来处理返回值，它的handleReturnValue方法代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CallableMethodReturnValueHandler</span> <span class="keyword">implements</span> <span class="title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> Callable.class.isAssignableFrom(returnType.getParameterType());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Callable&lt;?&gt; callable = (Callable&lt;?&gt;) returnValue;</span><br><span class="line">WebAsyncUtils.getAsyncManager(webRequest).startCallableProcessing(callable, mavContainer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里直接调用了WebAsyncManager的startCallableProcessing方法进行处理，不过这是一个重载的第一个参数是Callable类型的startCallableProcessing方法，其代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startCallableProcessing</span><span class="params">(Callable&lt;?&gt; callable, Object... processingContext)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Assert.notNull(callable, <span class="string">"Callable must not be null"</span>);</span><br><span class="line">startCallableProcessing(<span class="keyword">new</span> WebAsyncTask(callable), processingContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它还是将Callable封装成了WebAsyncTask然后处理的。如果WebAsyncTask中只有Callable而没有别的属性的时候可以直接返回Callable，比如前面的处理器可以修改为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.excelib.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/callable"</span>,produces = <span class="string">"text/plain; charset=UTF-8"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Callable&lt;String&gt; <span class="title">callable</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Callable处理器主线程进入"</span>);</span><br><span class="line">        Callable&lt;String&gt; callable = <span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span> * <span class="number">1000L</span>);</span><br><span class="line">                System.out.println(<span class="string">"Callable处理执行中。。。"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"久等了"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">"Callable处理器主线程退出"</span>);</span><br><span class="line">        <span class="keyword">return</span> callable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>它和前面使用WebAsyncTask执行的效果是一样的。</p><h3 id="22-2-4-DeferredResult类型异步请求的处理过程及用法"><a href="#22-2-4-DeferredResult类型异步请求的处理过程及用法" class="headerlink" title="22.2.4 DeferredResult类型异步请求的处理过程及用法"></a>22.2.4 DeferredResult类型异步请求的处理过程及用法</h3><p>DeferredResult是spring提供的一种用于保存延迟处理结果的类，当一个处理器返回DeferredResult类型的返回值时将启动异步处理。</p><p>不过DeferredResult和WebAsyncTask的使用方法完全不同，DeferredResult并不是用于处理请求的，而且也不包含请求的处理过程，它是用来封装处理结果的，有点像Java中的Future，但不完全一样。</p><p>使用DeferredResult的难点就在理解其含义，对其含义理解了之后就会觉得非常简单，而且使用起来也很方便。在返回WebAsyncTask时是因为处理的时间过长所以使用了异步处理，但其实还是自己来处理的（因为WebAsyncTask需要提供Callable），而返回DeferredResult表示要将处理交个别人了，什么时候处理完、怎么处理的自己并不需要知道，这就好像在单位经常用到的“妥否，请批示”的请示报告，自己并不知道什么时候能批下来，而且也不需要知道具体批示过程，只需要知道最后的结果就可以了。DeferredResult就是来保存结果的，当处理完之后调用它的setResult方法将结果设置给它就可以了。</p><p>DeferredResult还提供了一些别的属性，如resultHandler可以在设置了结果之后对结果进行处理、timeout设置超时时间、timeoutCallback设置超时处理方法、completionCallback设置处理完成后酌处理方法、timeoutResult设置超时后返回的结果等。</p><p>下面看一下Spring MVC中处理DeferredResult返回值的DeferredResultMethodReturnValueHandler处理器，它的handleReturnValue方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeferredResultMethodReturnValueHandler</span> <span class="keyword">implements</span> <span class="title">HandlerMethodReturnValueHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supportsReturnType</span><span class="params">(MethodParameter returnType)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> DeferredResult.class.isAssignableFrom(returnType.getParameterType());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DeferredResult&lt;?&gt; deferredResult = (DeferredResult&lt;?&gt;) returnValue;</span><br><span class="line">WebAsyncUtils.getAsyncManager(webRequest).startDeferredResultProcessing(deferredResult, mavContainer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里直接凋用了WebAsyncManager的startDeferredResultProcessing方法进行处理。</p><p>下面来看一个返回值为DeferredResult的处理器的例子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.excelib.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/deferred"</span>,produces = <span class="string">"text/plain; charset=UTF-8"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DeferredResult&lt;String&gt; <span class="title">deferredResultExam</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> DeferredResult&lt;String&gt; result = <span class="keyword">new</span> DeferredResult&lt;String&gt;(<span class="number">7</span>*<span class="number">1000L</span>, <span class="string">"超时了"</span>);</span><br><span class="line">        approve(result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">approve</span><span class="params">(DeferredResult&lt;String&gt; result)</span></span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5</span> * <span class="number">1000L</span>);</span><br><span class="line">                    result.setResult(<span class="string">"同意 "</span>+<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在处理器方法中直接新建了个DeferredResult类型的result代表处理结果，构造方法的两个参数分别表示超时时间和超时后返回的结果，建出来后将其交给approve方法进行处理（审批），当approve方法给result使用setResult方法设置了值后异步处理就完成了。</p><p>approve方法启动了一个新线程，然后在里面等待5秒后给result设置值。因为这里的处理器有@ResponseBody注释，所以返回值会直接显示到浏览器，当调用<code>http://localhost:8080/deferred</code>时，浏览器会在过大约5秒后显示<code>同意2015-04-02</code>。</p><p>现在大家再返回去看WebAsyncManager酌startDeferredResultProcessing方法就容易理解了，它并没有而且也不需要执行，只需要等待别的线程给设置返回值就可以了。方法中给result设置了处理返回值的处理器，当有返回值返回时会自动调用，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deferredResult.setResultHandler(<span class="keyword">new</span> DeferredResultHandler() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResult</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">result = interceptorChain.applyPostProcess(asyncWebRequest, deferredResult, result);</span><br><span class="line">setConcurrentResultAndDispatch(result);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这里的处理器中首先调用了拦截器链中的applyPostProcess方法，然后调用setConcurrentResultAndDispatch万法处理了返回值，setConcurrentResultAndDispatch方法前面已经说过了。</p><p>现在大家应该对DeferredResult返回值的异步处理就理解了，DeferredResult是一个用于保存返回值的类，只需要在业务处理完成后调用其setResult方法设置结果就可以了，至于怎么处理的、在哪里处理的它并不关心，这也就给我们带来了很大的自由。</p><h3 id="22-2-5-ListenableFuture类型异步请求的处理过程及用法"><a href="#22-2-5-ListenableFuture类型异步请求的处理过程及用法" class="headerlink" title="22.2.5 ListenableFuture类型异步请求的处理过程及用法"></a>22.2.5 ListenableFuture类型异步请求的处理过程及用法</h3><p>ListenableFuture继承自Future，Future在前面已经介绍过了，它用来保存Callable的处理结果，它提供了get方法来获取返回值，不过Future并不会在处理完成后主动提示。ListenableFuture在Future基础上增加了可以添加处理成功和处理失败回调方法的方法，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListenableFuture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addCallback</span><span class="params">(ListenableFutureCallback&lt;? <span class="keyword">super</span> T&gt; callback)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addCallback</span><span class="params">(SuccessCallback&lt;? <span class="keyword">super</span> T&gt; successCallback, FailureCallback failureCallback)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ListenableFutureCallback继承自SuccessCallback和FailureCallback接口，后两个接口分别有一个onSuccess方法和onFailure方法，用于处理异步处理成功的返回值和异步处理失败的返回值，就和DeferredResult中的resultHandler差不多，它们定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ListenableFutureCallback</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">SuccessCallback</span>&lt;<span class="title">T</span>&gt;, <span class="title">FailureCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SuccessCallback</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called when the &#123;<span class="doctag">@link</span> ListenableFuture&#125; successfully completes.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result the result</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(T result)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FailureCallback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Called when the &#123;<span class="doctag">@link</span> ListenableFuture&#125; fails to complete.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> ex the exception that triggered the failure</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable ex)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ListenableFuture足spring4.0新增的接口，它主要使用在需要调用别的服务的时候，spring还同时提供了AsyncRestTemplate，用它可以方便地发起各种Http请求，不同类型的请求（如Get、Post等）都有不同的方法，而且还可以使用url的模板参数uriVariables（类似于处理器参数中的pathVariables】，它的返回值就是ListenableFuture类型，比如，可以这样使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ListenableFuture&lt;ResponseEntity&lt;String&gt;&gt; futureEntity = template.getForEntity(</span><br><span class="line"><span class="string">"http://localhost:8080/students/&#123;studentld&#125;/books/&#123;bookldl"</span> , String.class, <span class="string">"176"</span>, <span class="string">"7"</span>);</span><br></pre></td></tr></table></figure></p><p>这样就可以返回<a href="http://localhost:808" target="_blank" rel="noopener">http://localhost:808</a> 0/students/1 7 6/books/7的Get请求结果，而且是非阻塞的异步调用。</p><p>下面看一下处理ListenableFuture返回值的处理器ListenableFutureReturnValueHandler，它的handleReturnValue方法代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleReturnValue</span><span class="params">(Object returnValue, MethodParameter returnType,</span></span></span><br><span class="line"><span class="function"><span class="params">ModelAndViewContainer mavContainer, NativeWebRequest webRequest)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (returnValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">mavContainer.setRequestHandled(<span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> DeferredResult&lt;Object&gt; deferredResult = <span class="keyword">new</span> DeferredResult&lt;Object&gt;();</span><br><span class="line">WebAsyncUtils.getAsyncManager(webRequest).startDeferredResultProcessing(deferredResult, mavContainer);</span><br><span class="line"></span><br><span class="line">ListenableFuture&lt;?&gt; future = (ListenableFuture&lt;?&gt;) returnValue;</span><br><span class="line">future.addCallback(<span class="keyword">new</span> ListenableFutureCallback&lt;Object&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(Object result)</span> </span>&#123;</span><br><span class="line">deferredResult.setResult(result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Throwable ex)</span> </span>&#123;</span><br><span class="line">deferredResult.setErrorResult(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到在ListenableFuture的返回值处理器里实际使用了DeferredResult．首先新建了DeferredResult类型的deferredResult，接着调用了WebAsyncManager的startDeferredResultProcessing方法进行处理，然后给ListenableFuture类型的返回值添加了回调方法，在回调方法中对deferredResult设置了返回值。可以说ListenableFuture类型的返回值只是DeferredResult类型返回值处理器的一种特殊使用方式。大家好好体会这里的处理过程就可以对<code>DeferredResult跟具体处理过程无关</code>这一点理解得更加深入。</p><p>下面来看一个ListenableFuture类型返回值处理器的例子。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.excelib.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/listenable"</span>,produces = <span class="string">"text/plain; charset=UTF-8"</span>)</span><br><span class="line">    <span class="keyword">public</span> ListenableFuture&lt;ResponseEntity&lt;String&gt;&gt; listenableFuture() &#123;</span><br><span class="line">        ListenableFuture&lt;ResponseEntity&lt;String&gt;&gt; future = <span class="keyword">new</span> AsyncRestTemplate().getForEntity(</span><br><span class="line">                <span class="string">"http://localhost:8080/index"</span>, String.class);</span><br><span class="line">        <span class="keyword">return</span> future;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里处理器的返回值ListenableFuture的泛型是ResponseEntity类型，所以不需要使用@ResponseBody注释也会将返回值直接显示到浏览器。当调用<code>http://localhost:8080/listenable</code>时，浏览器会显示<code>excelibGoGoGo!</code>，也就是<code>http://localhost:8080/index</code>的返回结果.。</p><p><strong>多知道点</strong></p><center>ListenableFuture和Future的比较</center><p>ListenableFuture在Future的基础上增加了可以添加处理成功和处理失败回调方法的方法，这就从Future的“拉”模式变成了ListenableFuture的“推”模式。</p><p>Future只能调用get方法来主动拉数据，而且get方法还是阻塞的，而ListenableFuture可以等待处理完成后自己将结果推过来，而且不会阻塞线程，这么看好像ListenableFuture比Future更好用。其实在很多地方Future中阻塞的get方法才是真正需要的，因为很多时候都需要等到线程处理的结果才可以向下进行，比如，要找四个数中最大的那个，可以将四个数分成两组然后启动两个线程分别选出每组中比较大的数，然后再启动一个线程取出两个结果中比较大的，那就是四个数中最大的数，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObtainBigger</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 需要查找最大数的数组</span></span><br><span class="line">        Double data[] = <span class="keyword">new</span> Double[]&#123;<span class="number">210.32</span>, <span class="number">517.96</span>, <span class="number">986.77</span>, <span class="number">325.13</span>&#125;;</span><br><span class="line">        <span class="comment">// 获取前两个里较大的</span></span><br><span class="line">        BiggerCallable c1 = <span class="keyword">new</span> BiggerCallable(data[<span class="number">0</span>],data[<span class="number">1</span>]);</span><br><span class="line">        Future&lt;Double&gt; bigger1 = executor.submit(c1);</span><br><span class="line">        <span class="comment">// 获取后两个里较大的</span></span><br><span class="line">        BiggerCallable c2 = <span class="keyword">new</span> BiggerCallable(data[<span class="number">2</span>],data[<span class="number">3</span>]);</span><br><span class="line">        Future&lt;Double&gt; bigger2 = executor.submit(c2);</span><br><span class="line">        <span class="comment">// 获取两个结果中较大的，这时会阻塞，只有前面两个结果都返回时才会往下进行</span></span><br><span class="line">        BiggerCallable c = <span class="keyword">new</span> BiggerCallable(bigger1.get(), bigger2.get());</span><br><span class="line">        Future&lt;Double&gt; bigger = executor.submit(c);</span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        System.out.println(bigger.get());</span><br><span class="line">        executor.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">BiggerCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span> </span>&#123;</span><br><span class="line">        Double d1, d2;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">BiggerCallable</span><span class="params">(Double d1, Double d2)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.d1 = d1;</span><br><span class="line">            <span class="keyword">this</span>.d2 = d2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> d1&gt;d2?d1:d2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里使用了内部类BiggerCallable来比较，第三个BiggerCallable创建时前两个cl）c2必须已经执行完才可以，否则就会出问题，所以在这种情况下阻塞就是必要的，而且这种需要线程返回结果后才能往下进行的情况很多。而ListenableFuture的典型用法就是Web异步请求这种并不需要对线程返回的结果进一步处理，而且线程在返回之前主线程可以继续往下走的情况，这时如果程序阻塞就起不到应有的作用了。</p><h2 id="22-3小结"><a href="#22-3小结" class="headerlink" title="22.3小结"></a>22.3小结</h2><p>本章系统地介绍了Servlet和SpringMVC中异步处理的原理和使用方法，首先介绍了Servlet3.0中对异步请求的支持及其使用方法，然后又分析了SpringMVC中异步处理的执行过程并编写了示例程序。</p><p>Servlet中使用异步请求非常方便，只需要调用request的startAsync方法，然后对其返回值AsyncContext进行处理，如果需要还可以为其添加AsyncListener监听器，它可以监听异步请求的启动、超时、处理完成和处理异常四个节点。</p><p>Spring MVC为异步请求提供了专门的工具，并对处理器默认提供了四种用于异步处理的返回值：</p><pre><code>1. Callable、2. WebAsyncTask、3. DeferredResult4. ListenableFuture。</code></pre><p>对异步请求的支持主要在RequestMappingHandlerAdapter中，启动异步处理在各返回值对应的返回值处理器中。</p>]]></content>
    
    <summary type="html">
    
      Spring MV异步请求&quot;
    
    </summary>
    
      <category term="java" scheme="http://www.wanqing520.cn/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>2016-10-12-ThinkPHP集成万象优图</title>
    <link href="http://www.wanqing520.cn/201610/12/php/2016-10-12-thinkphp-combine-tencent-cos.html"/>
    <id>http://www.wanqing520.cn/201610/12/php/2016-10-12-thinkphp-combine-tencent-cos.html</id>
    <published>2016-10-12T06:58:14.000Z</published>
    <updated>2017-12-13T11:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目原因"><a href="#项目原因" class="headerlink" title="项目原因"></a>项目原因</h2><p>不告诉你，反正需要把腾讯云的万象优图整合进来。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>下载PHP版的万象优图的SDK<br>下载地址：<a href="https://github.com/tencentyun/image-php-sdk" target="_blank" rel="noopener">https://github.com/tencentyun/image-php-sdk</a></p><h2 id="文件层次"><a href="#文件层次" class="headerlink" title="文件层次"></a>文件层次</h2><p>git clone 后的文件架构如下<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160703162752825" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure></p><h2 id="文件后缀"><a href="#文件后缀" class="headerlink" title="文件后缀"></a>文件后缀</h2><p>修改Tencentyun文件夹下面的7个文件的文件名为<code>*.class.php</code>.<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160703162951920" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure></p><h2 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h2><p>将修改好的sdk导入到项目中去，我这里导入到了<code>Application-&gt;Home-&gt;Controller-&gt;PhotoServer</code>中了，如下图。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160703163146733" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure></p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>Tencentyun文件夹下的7个<code>.class.php</code>文件的<code>namespace</code>为正确的<code>namespace</code> 。</p><blockquote><p><code>namespace Home\Controller\PhotoServer\Tencentyun;</code></p></blockquote><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>参考sdk文件夹下的<code>samplev2.php</code>编写测试<code>Controller</code>。代码如下 ：<br><strong>代码后面有注意事项。</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by PhpStorm.</span></span><br><span class="line"><span class="comment"> * User: Administrator</span></span><br><span class="line"><span class="comment"> * Date: 2016/7/3</span></span><br><span class="line"><span class="comment"> * Time: 11:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Home</span>\<span class="title">Controller</span>\<span class="title">PhotoServer</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Home</span>\<span class="title">Controller</span>\<span class="title">BaseController</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">require</span>(<span class="string">'include.php'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">Home</span>\<span class="title">Controller</span>\<span class="title">PhotoServer</span>\<span class="title">Tencentyun</span>\<span class="title">ImageV2</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Home</span>\<span class="title">Controller</span>\<span class="title">PhotoServer</span>\<span class="title">Tencentyun</span>\<span class="title">Auth</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">Home</span>\<span class="title">Controller</span>\<span class="title">PhotoServer</span>\<span class="title">Tencentyun</span>\<span class="title">ImageProcess</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span>  <span class="title">PhotoTestController</span> <span class="keyword">extends</span> <span class="title">BaseController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> view</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//智能鉴黄</span></span><br><span class="line">        $pornUrl = <span class="string">'http://b.hiphotos.baidu.com/image/pic/item/8ad4b31c8701a18b1efd50a89a2f07082938fec7.jpg'</span>;</span><br><span class="line">        $pornRet = ImageProcess::pornDetect($pornUrl);</span><br><span class="line">        var_dump($pornRet);</span><br><span class="line"></span><br><span class="line"><span class="comment">// V2增强版空间 带有空间和自定义文件名的示例</span></span><br><span class="line"><span class="comment">// 上传图片</span></span><br><span class="line">        $bucket = <span class="string">'zlktest'</span>; <span class="comment">// 自定义空间名称，在http://console.qcloud.com/image/bucket创建</span></span><br><span class="line">        $fileid = <span class="string">'sample'</span> . time();  <span class="comment">// 自定义文件名</span></span><br><span class="line">        $uploadRet = ImageV2::upload(<span class="string">'D:/123.jpg'</span>, $bucket, $fileid);</span><br><span class="line">        var_dump(<span class="string">'upload'</span>, $uploadRet);</span><br><span class="line"></span><br><span class="line"><span class="comment">//分片上传</span></span><br><span class="line">        $uploadSliceRet = ImageV2::uploadSlice(<span class="string">'D:/123.jpg'</span>);</span><br><span class="line">        var_dump(<span class="string">'upload_slice'</span>, $uploadSliceRet);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0</span> === $uploadRet[<span class="string">'code'</span>]) &#123;</span><br><span class="line">            $fileid = $uploadRet[<span class="string">'data'</span>][<span class="string">'fileid'</span>];</span><br><span class="line">            $downloadUrl = $uploadRet[<span class="string">'data'</span>][<span class="string">'downloadUrl'</span>];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 查询管理信息</span></span><br><span class="line">            $statRet = ImageV2::stat($bucket, $fileid);</span><br><span class="line">            var_dump(<span class="string">'stat'</span>, $statRet);</span><br><span class="line">            <span class="comment">// 复制</span></span><br><span class="line">            $copyRet = ImageV2::copy($bucket, $fileid);</span><br><span class="line">            var_dump(<span class="string">'copy'</span>, $copyRet);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生成私密下载url</span></span><br><span class="line">            $expired = time() + <span class="number">999</span>;</span><br><span class="line">            $sign = Auth::getAppSignV2($bucket, $fileid, $expired);</span><br><span class="line">            $signedUrl = $downloadUrl . <span class="string">'?sign='</span> . $sign;</span><br><span class="line">            var_dump(<span class="string">'downloadUrl:'</span>, $signedUrl);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成新的单次签名, 必须绑定资源fileid，复制和删除必须使用，其他不能使用</span></span><br><span class="line">            $fileid = $fileid . time() . rand();  <span class="comment">// 自定义文件名</span></span><br><span class="line">            $expired = <span class="number">0</span>;</span><br><span class="line">            $sign = Auth::getAppSignV2($bucket, $fileid, $expired);</span><br><span class="line">            var_dump($sign);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成新的多次签名, 可以不绑定资源fileid</span></span><br><span class="line">            $fileid = <span class="string">''</span>;</span><br><span class="line">            $expired = time() + <span class="number">999</span>;</span><br><span class="line">            $sign = Auth::getAppSignV2($bucket, $fileid, $expired);</span><br><span class="line">            var_dump($sign);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//$delRet = ImageV2::del($bucket, $fileid);</span></span><br><span class="line">            <span class="comment">//var_dump($delRet);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>代码中使用了地址为：<code>http://b.hiphotos.baidu.com/image/pic/item/8ad4b31c8701a18b1efd50a89a2f07082938fec7.jpg</code> 的图片。图片内容如下 ：<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160703163641360" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure></li><li><code>ImageV2::upload(&#39;D:/123.jpg&#39;, $bucket, $fileid);</code>这里的<code>D:/123.jpg</code>是用来模拟上传测试的。</li><li>测试示例会顺带使用万象优图的<code>黄图鉴别</code>功能。</li></ol><h2 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h2><p>访问<code>localhost/项目名/index.php/Home/PhotoServer/PhotoTest/index</code>路径返回结果如下，返回字段的详细信息请参考万象优图的官方文档。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160703164205317" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure></p><h2 id="测试上传是否成功"><a href="#测试上传是否成功" class="headerlink" title="测试上传是否成功"></a>测试上传是否成功</h2><p>我的<code>D:/123.jpg</code>的图片内容是步骤4中的<code>Tencentyun的文件结构图</code>。根据上面9中所得到的地址为：<code>http://zlktest-10010932.image.myqcloud.com/786c2e74-4591-42ed-861e-8fe27b356c14</code>.即可严重。</p>]]></content>
    
    <summary type="html">
    
      ThinkPHP集成万象优图
    
    </summary>
    
      <category term="php" scheme="http://www.wanqing520.cn/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>Neil | RequestToViewNameTranslator</title>
    <link href="http://www.wanqing520.cn/201610/12/java/2016-10-12-RequestToViewNameTranslator.html"/>
    <id>http://www.wanqing520.cn/201610/12/java/2016-10-12-RequestToViewNameTranslator.html</id>
    <published>2016-10-12T06:45:14.000Z</published>
    <updated>2017-12-13T11:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第15章-RequestToViewNameTranslator"><a href="#第15章-RequestToViewNameTranslator" class="headerlink" title="第15章 RequestToViewNameTranslator"></a>第15章 RequestToViewNameTranslator</h1><p>RequestToViewNameTranslator可以在处理器返回的view为空时使用它根据request获取viewName。Spring MVC提供的实现类只有一个DefaultRequestToViewNameTranslator，这个类也非常简单，只是因为有一些getter/setter方法，所以看起来代码比较多，实际执行解析的只有两个，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultRequestToViewNameTranslator</span> <span class="keyword">implements</span> <span class="title">RequestToViewNameTranslator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SLASH = <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String prefix = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String suffix = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String separator = SLASH;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> stripLeadingSlash = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> stripTrailingSlash = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> stripExtension = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> UrlPathHelper urlPathHelper = <span class="keyword">new</span> UrlPathHelper();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the prefix to prepend to generated view names.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> prefix the prefix to prepend to generated view names</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrefix</span><span class="params">(String prefix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.prefix = (prefix != <span class="keyword">null</span> ? prefix : <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the suffix to append to generated view names.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> suffix the suffix to append to generated view names</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuffix</span><span class="params">(String suffix)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.suffix = (suffix != <span class="keyword">null</span> ? suffix : <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the value that will replace '&#123;<span class="doctag">@code</span> /&#125;' as the separator</span></span><br><span class="line"><span class="comment"> * in the view name. The default behavior simply leaves '&#123;<span class="doctag">@code</span> /&#125;'</span></span><br><span class="line"><span class="comment"> * as the separator.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeparator</span><span class="params">(String separator)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.separator = separator;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set whether or not leading slashes should be stripped from the URI when</span></span><br><span class="line"><span class="comment"> * generating the view name. Default is "true".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStripLeadingSlash</span><span class="params">(<span class="keyword">boolean</span> stripLeadingSlash)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.stripLeadingSlash = stripLeadingSlash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set whether or not trailing slashes should be stripped from the URI when</span></span><br><span class="line"><span class="comment"> * generating the view name. Default is "true".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStripTrailingSlash</span><span class="params">(<span class="keyword">boolean</span> stripTrailingSlash)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.stripTrailingSlash = stripTrailingSlash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set whether or not file extensions should be stripped from the URI when</span></span><br><span class="line"><span class="comment"> * generating the view name. Default is "true".</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStripExtension</span><span class="params">(<span class="keyword">boolean</span> stripExtension)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.stripExtension = stripExtension;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set if URL lookup should always use the full path within the current servlet</span></span><br><span class="line"><span class="comment"> * context. Else, the path within the current servlet mapping is used</span></span><br><span class="line"><span class="comment"> * if applicable (i.e. in the case of a ".../*" servlet mapping in web.xml).</span></span><br><span class="line"><span class="comment"> * Default is "false".</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.util.UrlPathHelper#setAlwaysUseFullPath</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAlwaysUseFullPath</span><span class="params">(<span class="keyword">boolean</span> alwaysUseFullPath)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.urlPathHelper.setAlwaysUseFullPath(alwaysUseFullPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set if the context path and request URI should be URL-decoded.</span></span><br><span class="line"><span class="comment"> * Both are returned &lt;i&gt;undecoded&lt;/i&gt; by the Servlet API,</span></span><br><span class="line"><span class="comment"> * in contrast to the servlet path.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Uses either the request encoding or the default encoding according</span></span><br><span class="line"><span class="comment"> * to the Servlet spec (ISO-8859-1).</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.util.UrlPathHelper#setUrlDecode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrlDecode</span><span class="params">(<span class="keyword">boolean</span> urlDecode)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.urlPathHelper.setUrlDecode(urlDecode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set if ";" (semicolon) content should be stripped from the request URI.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.util.UrlPathHelper#setRemoveSemicolonContent(boolean)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRemoveSemicolonContent</span><span class="params">(<span class="keyword">boolean</span> removeSemicolonContent)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.urlPathHelper.setRemoveSemicolonContent(removeSemicolonContent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set the &#123;<span class="doctag">@link</span> org.springframework.web.util.UrlPathHelper&#125; to use for</span></span><br><span class="line"><span class="comment"> * the resolution of lookup paths.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Use this to override the default UrlPathHelper with a custom subclass,</span></span><br><span class="line"><span class="comment"> * or to share common UrlPathHelper settings across multiple web components.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrlPathHelper</span><span class="params">(UrlPathHelper urlPathHelper)</span> </span>&#123;</span><br><span class="line">Assert.notNull(urlPathHelper, <span class="string">"UrlPathHelper must not be null"</span>);</span><br><span class="line"><span class="keyword">this</span>.urlPathHelper = urlPathHelper;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Translates the request URI of the incoming &#123;<span class="doctag">@link</span> HttpServletRequest&#125;</span></span><br><span class="line"><span class="comment"> * into the view name based on the configured parameters.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> org.springframework.web.util.UrlPathHelper#getLookupPathForRequest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #transformPath</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getViewName</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">String lookupPath = <span class="keyword">this</span>.urlPathHelper.getLookupPathForRequest(request);</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span>.prefix + transformPath(lookupPath) + <span class="keyword">this</span>.suffix);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transform the request URI (in the context of the webapp) stripping</span></span><br><span class="line"><span class="comment"> * slashes and extensions, and replacing the separator as required.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> lookupPath the lookup path for the current request,</span></span><br><span class="line"><span class="comment"> * as determined by the UrlPathHelper</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the transformed path, with slashes and extensions stripped</span></span><br><span class="line"><span class="comment"> * if desired</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">transformPath</span><span class="params">(String lookupPath)</span> </span>&#123;</span><br><span class="line">String path = lookupPath;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.stripLeadingSlash &amp;&amp; path.startsWith(SLASH)) &#123;</span><br><span class="line">path = path.substring(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.stripTrailingSlash &amp;&amp; path.endsWith(SLASH)) &#123;</span><br><span class="line">path = path.substring(<span class="number">0</span>, path.length() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.stripExtension) &#123;</span><br><span class="line">path = StringUtils.stripFilenameExtension(path);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!SLASH.equals(<span class="keyword">this</span>.separator)) &#123;</span><br><span class="line">path = StringUtils.replace(path, SLASH, <span class="keyword">this</span>.separator);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>getViewName</code>足接口定义的方法，实际解析时就调用它。在<code>getViewName</code>中首先从<code>request</code>获得<code>lookupPath</code>，然后使用<code>transformPath</code>方法对其进行处理后加土前缀后缀返回。<code>transformPath</code>方法的作用简单来说就是根据配置对<code>lookupPath</code>“掐头去尾换分隔符”，它是根据其中的四个属性的设置来处理的，下面分别解释一下这四个属性，其中用到的Slash是一个静态常量，表示”/“。</p><ol><li><code>stripLeadingSlash</code>:如果最前面的字符为<code>Slash</code>是否将其去掉。</li><li><code>stripTrailingSlash</code>：如果最后一个字符为<code>Slash</code>是否将其去掉。</li><li><code>stripExtension</code>：是否需要去掉扩展名。</li><li><code>separator</code>:如果其值与<code>Slash</code>不同则用于替换原来的分隔符<code>Slash</code>。</li></ol><p><code>getViewName</code>中还使用了可以给返回值添加前缀和后缀的<code>prefix</code>和<code>suffix</code>，这些参数都可以配置。可以配置的参数除了这6个外还有4个：<code>urlDecode</code>、<code>removeSemicolonContent</code>、<code>alwaysUseFullPath</code>和<code>urlPathHelper</code>，前三个参数都是用在<code>urlPathHelper</code>中的，<code>urlDecode</code>用于设置<code>url</code>是否需要编解码，一般默认就行；<code>removeSemicolonContent</code>在前面已经说过了．用于设置是否删除<code>url</code>中与分号相关的内容；<code>alwaysUseFullPath</code>用于设置是否总使用完整路径；<code>urlpathHelper</code>是用于处理<code>url</code>的工具，一般使用<code>spring</code>默认提供的就可以了。<br><code>RequestToViewNameTranslator</code>组件非常简单，本章就介绍到这里。</p>]]></content>
    
    <summary type="html">
    
      RequestToViewNameTranslator
    
    </summary>
    
      <category term="java" scheme="http://www.wanqing520.cn/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Neil | 牛中超--B507实验室打印机连接</title>
    <link href="http://www.wanqing520.cn/201610/12/%E6%9D%82%E8%B0%88/2016-10-12-intranter-printer.html"/>
    <id>http://www.wanqing520.cn/201610/12/杂谈/2016-10-12-intranter-printer.html</id>
    <published>2016-10-12T06:13:14.000Z</published>
    <updated>2017-12-13T11:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、准备工具"><a href="#一、准备工具" class="headerlink" title="一、准备工具"></a>一、准备工具</h1><ol><li>实验室打印机内网IP地址：<code>172.16.135.41</code> ,这个地址要看具体的打印机地址（可能会更换）。</li><li>从实验室QQ群（<code>土匪窝</code>）上下载打印机驱动，如下图所示。<center></center></li></ol><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160622094458863" alt="图1" title="">                </div>                <div class="image-caption">图1</div>            </figure><br>3. 非常重要的事情：请链接实验室的有线网络或者是由有线网络<code>共享出来</code>的WIFI，不能连接<code>CS-*</code>这样的<code>WIFI</code><br><br># 二、连接步骤<br>1. <code>WIN+R</code> 输入如下这样的命令<code>\\+打印机IP地址</code><br><center><br><br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160622094802739" alt="图2" title="">                </div>                <div class="image-caption">图2</div>            </figure><p></p></center><p></p><ol start="2"><li>在登录界面输入用户名<code>GUI-YUAN</code> ，密码<code>为空</code>（写完文档发现：下图报错的原因是因为我写成小写的了这里是因为截图有问题，登录之后，下次就不要登录了，所以，这里没放正确的图）。<center></center></li></ol><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160622094925822" alt="图3" title="">                </div>                <div class="image-caption">图3</div>            </figure></p><ol start="3"><li>选中下图圈中的<code>HP LaserJet 1020</code><center></center></li></ol><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160622095419969" alt="图4" title="">                </div>                <div class="image-caption">图4</div>            </figure></p><ol start="4"><li>打开之后，系统会在更新中查找打印机驱动，一般是找不到的，让我们点击取消吧。<center></center></li></ol><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160622095458892" alt="图5" title="">                </div>                <div class="image-caption">图5</div>            </figure></p><ol start="5"><li>从QQ群文件中下载<code>hplaserjet1020plus.zip</code>文件，并解压。<center></center></li></ol><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160622095939290" alt="图6" title="">                </div>                <div class="image-caption">图6</div>            </figure></p><ol start="6"><li>运行解压后的<code>LJ1018_1020_1022_Full_Solution.exe</code><center></center></li></ol><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160622100026447" alt="图7" title="">                </div>                <div class="image-caption">图7</div>            </figure></p><ol start="7"><li>经过一小会的准备，看到安装的主界面如下，选择<code>安装(I)</code><center></center></li></ol><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160622100146432" alt="图8" title="">                </div>                <div class="image-caption">图8</div>            </figure></p><ol start="8"><li>step1<center></center></li></ol><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160622100219635" alt="图9" title="">                </div>                <div class="image-caption">图9</div>            </figure></p><ol start="9"><li>step2<center></center></li></ol><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160622100306934" alt="图10" title="">                </div>                <div class="image-caption">图10</div>            </figure></p><ol start="10"><li>出现上面<code>9</code>中所述的界面时，就表明可以回到<code>3</code>连接打印机了，这里点击取消<center></center></li></ol><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160622100422464" alt="图11" title="">                </div>                <div class="image-caption">图11</div>            </figure></p><ol start="11"><li>回到如下界面，再次连接打印机<center></center></li></ol><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160622100531750" alt="图12" title="">                </div>                <div class="image-caption">图12</div>            </figure></p><ol start="12"><li>打印机连接成功<center></center></li></ol><p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20160622100545657" alt="图13" title="">                </div>                <div class="image-caption">图13</div>            </figure></p><hr><p>OK，enjoy it !</p>]]></content>
    
    <summary type="html">
    
      B507实验室打印机连接
    
    </summary>
    
      <category term="杂谈" scheme="http://www.wanqing520.cn/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>Neil | 牛中超--OutofMemory in Action</title>
    <link href="http://www.wanqing520.cn/201610/12/java/2016-10-12-OutofMemory-in-Action.html"/>
    <id>http://www.wanqing520.cn/201610/12/java/2016-10-12-OutofMemory-in-Action.html</id>
    <published>2016-10-12T06:03:14.000Z</published>
    <updated>2017-12-13T11:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="./images/1476266075785.jpg" alt="enter description here" title="1476266075785.jpg"></p>]]></content>
    
    <summary type="html">
    
      R使用北京的镜像
    
    </summary>
    
      <category term="java" scheme="http://www.wanqing520.cn/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Neil | 牛中超--R简介</title>
    <link href="http://www.wanqing520.cn/201610/12/bigdata/simple_use_of_R.html"/>
    <id>http://www.wanqing520.cn/201610/12/bigdata/simple_use_of_R.html</id>
    <published>2016-10-12T06:03:14.000Z</published>
    <updated>2017-12-13T11:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第1章-R简介"><a href="#第1章-R简介" class="headerlink" title="第1章 R简介"></a>第1章 R简介</h1><p>1.2.4 向量化<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; v&lt;-c(<span class="number">4</span>,<span class="number">7</span>,<span class="number">23.5</span>,<span class="number">67.2</span>,<span class="number">80</span>)</span><br><span class="line">&gt; x&lt;-sqrt(v)</span><br><span class="line">&gt; x</span><br><span class="line">[<span class="number">1</span>] <span class="number">2.000000</span> <span class="number">2.645751</span> <span class="number">4.847680</span> <span class="number">8.197561</span> <span class="number">8.944272</span></span><br></pre></td></tr></table></figure></p><p>也可以使用R的这个热性进行向量的算术运算。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; v1&lt;-c(<span class="number">4</span>,<span class="number">6</span>,<span class="number">87</span>)</span><br><span class="line">&gt; v2&lt;-c(<span class="number">34</span>,<span class="number">32.4</span>,<span class="number">12</span>)</span><br><span class="line">&gt; v1+v2</span><br><span class="line">[<span class="number">1</span>] <span class="number">38.0</span> <span class="number">38.4</span> <span class="number">99.0</span></span><br></pre></td></tr></table></figure></p><p>如果两个向量的长度不同，R会自动的将较短的向量进行扩充。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; v1&lt;-c(<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">24</span>)</span><br><span class="line">&gt; v2&lt;-c(<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line">&gt; v1+v2</span><br><span class="line">[<span class="number">1</span>] <span class="number">14</span>  <span class="number">8</span> <span class="number">18</span> <span class="number">26</span></span><br></pre></td></tr></table></figure></p><p>如果较长的向量的长度不是较短的向量的长度的整数倍，R将会给出警告，注意是警告而不是错误。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; v1&lt;-c(<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">24</span>)</span><br><span class="line">&gt; v2&lt;-c(<span class="number">10</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">&gt; v1+v2</span><br><span class="line">[<span class="number">1</span>] <span class="number">14</span>  <span class="number">8</span> <span class="number">12</span> <span class="number">34</span></span><br><span class="line">Warning message:</span><br><span class="line">In v1 + v2 :</span><br><span class="line">  longer object length is not a multiple of shorter object length</span><br></pre></td></tr></table></figure></p><p>以上的内容是循环规则。</p><p>如前所述，单个数字在R中表示长度为1的向量。这种表示在下面的运算中非常方便：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; v1&lt;-c(<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">24</span>)</span><br><span class="line">&gt; <span class="number">2</span>*v1</span><br><span class="line">[<span class="number">1</span>]  <span class="number">8</span> <span class="number">12</span> <span class="number">16</span> <span class="number">48</span></span><br></pre></td></tr></table></figure></p><p>注意，数字<code>2</code>被循环，导致v1的所有元素都被乘以2,。正如我们将看到的，这种循环跪着也适用于其他对象，如数组和矩阵。</p><p>1.2.5 因子<br>因子提供了一个简单而又紧凑的形式来处理分类数据（名义）。因子用水平来表示所有可能的取值。如果数据集有取值个数固定的名义变量，因子就特别有用。R中的图形函数和汇总函数就是应用了因子的这种有点。对用户来说，这种使用和显示因子数据的方式显然是易于理解的，而R内部以数值编码的方式来存储因子值，这将大大提高内存的利用效率。</p><p>下面举个例子来说明如何在R中创建因子。假设有10个人的性别向量。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; g&lt;-c(<span class="string">"f"</span>,<span class="string">"m"</span>,<span class="string">"m"</span>,<span class="string">"m"</span>,<span class="string">"f"</span>,<span class="string">"m"</span>,<span class="string">"f"</span>,<span class="string">"m"</span>,<span class="string">"f"</span>,<span class="string">"m"</span>,<span class="string">"f"</span>,<span class="string">"f"</span>)</span><br><span class="line">&gt; g</span><br><span class="line"> [<span class="number">1</span>] <span class="string">"f"</span> <span class="string">"m"</span> <span class="string">"m"</span> <span class="string">"m"</span> <span class="string">"f"</span> <span class="string">"m"</span> <span class="string">"f"</span> <span class="string">"m"</span> <span class="string">"f"</span> <span class="string">"m"</span> <span class="string">"f"</span> <span class="string">"f"</span></span><br></pre></td></tr></table></figure></p><p>你可以把这个因子向量转为一个因子。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; g&lt;-factor(g)</span><br><span class="line">&gt; g</span><br><span class="line"> [<span class="number">1</span>] f m m m f m f m f m f f</span><br><span class="line">Levels: f m</span><br></pre></td></tr></table></figure></p><p>注意，这里得到的因子不再是一个字符向量。上面说到，实际上这些因子在R内部表示为数值向量。在这个例子中，因子有两个水平，<code>f</code>和<code>m</code>，在R内部分别表示1和2.然而，我们不需要关系在内部是如何表示的，因为你可以使用原始的字符值，R在显示因子的时候，也使用这种字符方式。因此，出于效率的考虑，R因子的编码转换对用户是透明的。</p><p>假设另外有5个人，需要把他们的性别信息存储在另一个透明的因子对象中。假设他们都是男性。如果都仍然需要这个因子对象与对象g有两个相同的因子水平，则必须使用下面的命令。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; other.g&lt;-factor(c(<span class="string">"m"</span>,<span class="string">"m"</span>,<span class="string">"m"</span>,<span class="string">"m"</span>,<span class="string">"m"</span>),levels = c(<span class="string">"f"</span>,<span class="string">"m"</span>))</span><br><span class="line">&gt; other.g</span><br><span class="line">[<span class="number">1</span>] m m m m m</span><br><span class="line">Levels: f m</span><br></pre></td></tr></table></figure></p><p>如果没有在输入参数中设定<code>level</code>参数，因子other.g将只有一个水平(‘m’).</p><p>在R这样的函数式编程语言中，最常见的函数之一就是像上例中的函数复合。</p><p>利用因子类型的数据，可以做的一件事情就是计算每个可能值得发生次数。例如：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; table(g)</span><br><span class="line">g</span><br><span class="line">f m</span><br><span class="line"><span class="number">6</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="selector-tag">table</span>(<span class="selector-tag">other</span><span class="selector-class">.g</span>)</span><br><span class="line"><span class="selector-tag">other</span><span class="selector-class">.g</span></span><br><span class="line"><span class="selector-tag">f</span> <span class="selector-tag">m</span></span><br><span class="line">0 5</span><br></pre></td></tr></table></figure><p><code>table</code>也可以获取多个因子的交叉表。假设向量<code>a</code>存储10个人的所属的年龄，那么可以得到这两个向量的交叉表。如下：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; a&lt;-factor(c(<span class="string">'adult'</span>,<span class="string">'adult'</span>,<span class="string">'juvenile'</span>,<span class="string">'juvenile'</span>,<span class="string">'adult'</span>,<span class="string">'adult'</span>,<span class="string">'adult'</span>,<span class="string">'juvenile'</span>,<span class="string">'adult'</span>,<span class="string">'juvenile'</span>))</span><br><span class="line">&gt; length(a)</span><br><span class="line">[<span class="number">1</span>] <span class="number">10</span></span><br><span class="line">&gt; length(g)</span><br><span class="line">[<span class="number">1</span>] <span class="number">10</span></span><br><span class="line">&gt; g</span><br><span class="line"> [<span class="number">1</span>] <span class="string">"f"</span> <span class="string">"m"</span> <span class="string">"m"</span> <span class="string">"f"</span> <span class="string">"m"</span> <span class="string">"f"</span> <span class="string">"m"</span> <span class="string">"f"</span> <span class="string">"m"</span> <span class="string">"f"</span></span><br><span class="line">&gt; table(a,g)</span><br><span class="line">          g</span><br><span class="line">a          f m</span><br><span class="line">  adult    <span class="number">2</span> <span class="number">4</span></span><br><span class="line">  juvenile <span class="number">3</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>如果数据过长的话，可以采用<code>+</code>进行换行输入。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; a&lt;-factor(c(<span class="string">'adult'</span>,<span class="string">'adult'</span>,<span class="string">'juvenile'</span>,<span class="string">'juvenile'</span>,<span class="string">'adult'</span>,</span><br><span class="line">+ <span class="string">'adult'</span>,<span class="string">'adult'</span>,<span class="string">'juvenile'</span>,<span class="string">'adult'</span>,<span class="string">'juvenile'</span>))</span><br><span class="line">&gt; a</span><br><span class="line"> [<span class="number">1</span>] adult    adult    juvenile juvenile adult    adult    adult    juvenile adult    juvenile</span><br><span class="line">Levels: adult juvenile</span><br></pre></td></tr></table></figure></p><p>有时候我们希望计算列联表的边际和相对频率。下面给出了上面数据集的性别和年龄因子的总计。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; t&lt;-table(a,g)</span><br><span class="line">&gt; margin.table(t,<span class="number">1</span>)</span><br><span class="line">a</span><br><span class="line">   adult juvenile</span><br><span class="line">       <span class="number">6</span>        <span class="number">4</span></span><br><span class="line">&gt; margin.table(t,<span class="number">2</span>)</span><br><span class="line">g</span><br><span class="line">f m</span><br><span class="line"><span class="number">5</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>输入参数<code>1</code>和<code>2</code>分别代表列联表的第一和第二个维度，即表示t的行和列。每个维度边际和总计的相对频率如下：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt; prop.table(t,<span class="number">1</span>)</span><br><span class="line">          g</span><br><span class="line">a                  f         m</span><br><span class="line">  adult    <span class="number">0.3333333</span> <span class="number">0.6666667</span></span><br><span class="line">  juvenile <span class="number">0.7500000</span> <span class="number">0.2500000</span></span><br><span class="line">&gt; prop.table(t,<span class="number">2</span>)</span><br><span class="line">          g</span><br><span class="line">a            f   m</span><br><span class="line">  adult    <span class="number">0.4</span> <span class="number">0.8</span></span><br><span class="line">  juvenile <span class="number">0.6</span> <span class="number">0.2</span></span><br><span class="line">&gt; prop.table(t)</span><br><span class="line">          g</span><br><span class="line">a            f   m</span><br><span class="line">  adult    <span class="number">0.2</span> <span class="number">0.4</span></span><br><span class="line">  juvenile <span class="number">0.3</span> <span class="number">0.1</span></span><br></pre></td></tr></table></figure></p><p>注意：如果需要的是百分比，可以在调用函数时乘以100<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">100</span>*prop.table(t)</span><br><span class="line">          g</span><br><span class="line">a           f  m</span><br><span class="line">  adult    <span class="number">20</span> <span class="number">40</span></span><br><span class="line">  juvenile <span class="number">30</span> <span class="number">10</span></span><br></pre></td></tr></table></figure></p><h3 id="1-2-6-生产序列"><a href="#1-2-6-生产序列" class="headerlink" title="1.2.6 生产序列"></a>1.2.6 生产序列</h3><p>R提供了狠多种生产不同类型序列的方法。比如：创建一个1~1000所有整数的向量，可以简单的输入<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; x&lt;-<span class="number">1</span>:<span class="number">1000</span></span><br><span class="line">&gt; length(x)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1000</span></span><br></pre></td></tr></table></figure></p><p>通过上面的语句就创建了一个名为<code>x</code>的向量，它包含了1000个元素。<br>注意运算符<code>:</code>的优先级，我们通过下面的例子来说明这个问题。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">10</span>:<span class="number">15</span>-<span class="number">1</span></span><br><span class="line">[<span class="number">1</span>]  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span></span><br><span class="line">&gt; <span class="number">10</span>:(<span class="number">15</span>-<span class="number">1</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span></span><br></pre></td></tr></table></figure></p><p>这里需要理解第一个命令的结果（记住循环规则），<code>:</code>的优先级高于减法<code>-</code>。<br>同样，可以利用<code>seq()</code>生成实数序列。比如：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; seq(-<span class="number">4</span>,<span class="number">1</span>,<span class="number">0.5</span>)</span><br><span class="line"> [<span class="number">1</span>] -<span class="number">4.0</span> -<span class="number">3.5</span> -<span class="number">3.0</span> -<span class="number">2.5</span> -<span class="number">2.0</span> -<span class="number">1.5</span> -<span class="number">1.0</span> -<span class="number">0.5</span>  <span class="number">0.0</span>  <span class="number">0.5</span>  <span class="number">1.0</span></span><br></pre></td></tr></table></figure></p><p>生成了一个从-4到1的步长为0.5的一个实数序列。函数seq还有其他的功能。下面举例说明seq的其他功能。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seq(from=<span class="number">1</span>,to=<span class="number">5</span>,length=<span class="number">4</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1.000000</span> <span class="number">2.333333</span> <span class="number">3.666667</span> <span class="number">5.000000</span></span><br><span class="line">&gt; seq(from=<span class="number">1</span>,to=<span class="number">5</span>,length=<span class="number">2</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">5</span></span><br><span class="line">&gt; seq(length=<span class="number">10</span>,from = -<span class="number">2</span>,by = <span class="number">0.2</span>)</span><br><span class="line"> [<span class="number">1</span>] -<span class="number">2.0</span> -<span class="number">1.8</span> -<span class="number">1.6</span> -<span class="number">1.4</span> -<span class="number">1.2</span> -<span class="number">1.0</span> -<span class="number">0.8</span> -<span class="number">0.6</span> -<span class="number">0.4</span> -<span class="number">0.2</span></span><br></pre></td></tr></table></figure></p><p>通过上面的例子，我们可以看到我们可以任意指定参数的顺序：但是要先给出参数名，再给出参数值。因此，当我们使用多个参数且大部分参数都采用默认值的函数时，这将非常方便。一旦这些默认参数能满足我们的要求，我们就可以避免人为的设置这些参数。</p><p>另一个产生具有某种模式序列的有用的函数时req()函数。比如：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; rep(<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line"> [<span class="number">1</span>] <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span></span><br><span class="line">&gt; rep(<span class="string">"hi"</span>,<span class="number">3</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="string">"hi"</span> <span class="string">"hi"</span> <span class="string">"hi"</span></span><br><span class="line">&gt; rep(<span class="number">1</span>:<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line">&gt; rep(<span class="number">1</span>:<span class="number">2</span>,each=<span class="number">3</span>)</span><br><span class="line">[<span class="number">1</span>] <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p><code>gl()</code>函数可用于生成带有因子的序列。这个函数的语法是<code>gl(k,n)</code>，其中k是因子水平的个数，n是每个每个因子水平的重复数。这里举两字例子：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; gl(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"> [<span class="number">1</span>] <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line">Levels: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br><span class="line">&gt; gl(<span class="number">2</span>,<span class="number">5</span>,labels=c(<span class="string">'female'</span>,<span class="string">'male'</span>))</span><br><span class="line"> [<span class="number">1</span>] female female female female female male   male   male   male   male  </span><br><span class="line">Levels: female male</span><br></pre></td></tr></table></figure></p><p>最后R有多个可以根据不同概率密度函数来生成随机序列的函数。这些函数的通用结果是<code>xfunc(n,par1,par2,...)</code>,其中，func是概率分布的名称，n是要生成的随机数的个数，<code>par1,par2,...</code>是概率密度函数所需要的一些参数值。例如，可以产生10个服从均值为0，标准差为1的正态分布的随机数值：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rnorm(<span class="number">10</span>)</span><br><span class="line"> [<span class="number">1</span>]  <span class="number">1.29219470</span> -<span class="number">0.38849339</span>  <span class="number">1.88505193</span>  <span class="number">0.48227844</span>  <span class="number">1.23505790</span>  <span class="number">1.49568939</span> -<span class="number">1.14704749</span> -<span class="number">0.41806913</span> -<span class="number">0.09506815</span>  <span class="number">0.73086971</span></span><br></pre></td></tr></table></figure></p><p>为了获得5个服从自由度为10的t分布的随机变量，可以输入：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; rt(<span class="number">5</span>, df = <span class="number">10</span>)</span><br><span class="line">[<span class="number">1</span>]  <span class="number">1.4049026</span> -<span class="number">0.5510834</span>  <span class="number">0.1607854</span>  <span class="number">1.4629028</span> -<span class="number">0.6332299</span></span><br></pre></td></tr></table></figure></p><p>R还有很多其他的概率函数，以及其他获取概率密度、累计概率和这些分布的分位数函数。</p><h3 id="1-2-7-数据子集"><a href="#1-2-7-数据子集" class="headerlink" title="1.2.7 数据子集"></a>1.2.7 数据子集</h3><p>前面的例证提到，可以在方括号内放入元素的位置来获取向量的某个元素。R也允许在方括号中使用向量。R有很类型的索引向量。逻辑索引向量可以提取相应于真值的元素。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; x&lt;-c(<span class="number">0</span>,-<span class="number">3</span>,<span class="number">4</span>,-<span class="number">1</span>,<span class="number">45</span>,<span class="number">90</span>,-<span class="number">5</span>)</span><br><span class="line">&gt; x&gt;<span class="number">0</span></span><br><span class="line">[<span class="number">1</span>] <span class="literal">FALSE</span> <span class="literal">FALSE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span>  <span class="literal">TRUE</span>  <span class="literal">TRUE</span> <span class="literal">FALSE</span></span><br></pre></td></tr></table></figure></p><p>上面显示的第二个命令是逻辑条件。由于x是向量，所以将向量中的所有的元素与0进行比较，产生一个长度与向量x相同的逻辑值向量。如果使用该逻辑值向量对x进行索引，就可以得到相应TRUE值位置的向量x的元素。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; x[x&gt;<span class="number">0</span>]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">4</span> <span class="number">45</span> <span class="number">90</span></span><br></pre></td></tr></table></figure></p><p>利用R中的逻辑运算符，可以使用更复杂的逻辑索引向量。如下：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; x[x&lt;=<span class="number">2</span>|x&gt;<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0</span> -<span class="number">3</span> -<span class="number">1</span> <span class="number">45</span> <span class="number">90</span> -<span class="number">5</span></span><br><span class="line">&gt; x[x&gt;<span class="number">40</span>&amp;x&lt;<span class="number">100</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">45</span> <span class="number">90</span></span><br></pre></td></tr></table></figure></p><p>上面都是简单的逻辑运算。就不再详细解释了。</p><p>R还可以使用整数向量来提取向量中的多个元素，索引向量中的数字表示提取的元素在原向量中的位置。例如：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; x</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0</span> -<span class="number">3</span>  <span class="number">4</span> -<span class="number">1</span> <span class="number">45</span> <span class="number">90</span> -<span class="number">5</span></span><br><span class="line">&gt; x[c(<span class="number">4</span>,<span class="number">6</span>)]</span><br><span class="line">[<span class="number">1</span>] -<span class="number">1</span> <span class="number">90</span></span><br><span class="line">&gt; x[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0</span> -<span class="number">3</span>  <span class="number">4</span></span><br><span class="line">&gt; y&lt;-c(<span class="number">1</span>,<span class="number">4</span>)</span><br><span class="line">&gt; x[y]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0</span> -<span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>另外可以使用一个负值的索引表示哪些元素可以排除。例如：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; x[-<span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>] -<span class="number">3</span>  <span class="number">4</span> -<span class="number">1</span> <span class="number">45</span> <span class="number">90</span> -<span class="number">5</span></span><br><span class="line">&gt; x[-c(<span class="number">4</span>,<span class="number">6</span>)]</span><br><span class="line">[<span class="number">1</span>]  <span class="number">0</span> -<span class="number">3</span>  <span class="number">4</span> <span class="number">45</span> -<span class="number">5</span></span><br><span class="line">&gt; x[-(<span class="number">1</span>:<span class="number">3</span>)]</span><br><span class="line">[<span class="number">1</span>] -<span class="number">1</span> <span class="number">45</span> <span class="number">90</span> -<span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>这里-1表示删除第一个位置上的元素，其他的类似。</p><p>可以通过R函数names()来给向量中的元素命名，对于命名的向量元素，可以通过字符串向量来进行索引。由于命名的元素位置更容易进驻，所以有时候更名元素更受欢迎。例如，在5个不同的地方测量了一个化学参数的测量值向量。可以创建如下的命名空间：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; pH&lt;-c(<span class="number">4.5</span>,<span class="number">7</span>,<span class="number">7.3</span>,<span class="number">8.2</span>,<span class="number">6.3</span>)</span><br><span class="line">&gt; names(pH)&lt;-c('area1','area2','mud','dam','middle')</span><br><span class="line">&gt; pH</span><br><span class="line"> area1  area2    mud    dam middle</span><br><span class="line">   <span class="number">4.5</span>    <span class="number">7.0</span>    <span class="number">7.3</span>    <span class="number">8.2</span>    <span class="number">6.3</span></span><br><span class="line">&gt; table(pH)</span><br><span class="line">pH</span><br><span class="line"><span class="number">4.5</span> <span class="number">6.3</span>   <span class="number">7</span> <span class="number">7.3</span> <span class="number">8.2</span></span><br><span class="line">  <span class="number">1</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">1</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>实际上，我们可以使用如下的方法进行创建。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; pH&lt;-c(area1=<span class="number">4.5</span>,area2=<span class="number">7</span>, mud = <span class="number">7.3</span>, dam = <span class="number">8.2</span>, middle = <span class="number">6.3</span>)</span><br><span class="line">&gt; pH[<span class="string">'middle'</span>]</span><br><span class="line">middle</span><br><span class="line">   <span class="number">6.3</span></span><br><span class="line">&gt; pH[c(<span class="string">'mud'</span>,<span class="string">'middle'</span>)]</span><br><span class="line">   mud middle</span><br><span class="line">   <span class="number">7.3</span>    <span class="number">6.3</span></span><br></pre></td></tr></table></figure></p><h3 id="1-2-8-矩阵和数组"><a href="#1-2-8-矩阵和数组" class="headerlink" title="1.2.8 矩阵和数组"></a>1.2.8 矩阵和数组</h3><p>数据元素可以保存在具有多个维度的对象中。在多种情况下这尤其有用，数组存储的是多维数据。矩阵是数组的特殊情况，它具有两个维度。在R中数组和矩阵都是带有维度这个属性的向量。假设一个数值向量c(45,23,66,77,33,44,56,12,78,23),下面要把这10个数值组织为一个矩阵：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt; m&lt;- c(<span class="number">45</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">56</span>,<span class="number">12</span>,<span class="number">78</span>,<span class="number">23</span>)</span><br><span class="line">&gt; m</span><br><span class="line"> [<span class="number">1</span>] <span class="number">45</span> <span class="number">23</span> <span class="number">66</span> <span class="number">77</span> <span class="number">33</span> <span class="number">44</span> <span class="number">56</span> <span class="number">12</span> <span class="number">78</span> <span class="number">23</span></span><br><span class="line">&gt; dim(m)&lt;-c(<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line">&gt; m</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>] [,<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,]   <span class="number">45</span>   <span class="number">66</span>   <span class="number">33</span>   <span class="number">56</span>   <span class="number">78</span></span><br><span class="line">[<span class="number">2</span>,]   <span class="number">23</span>   <span class="number">77</span>   <span class="number">44</span>   <span class="number">12</span>   <span class="number">23</span></span><br></pre></td></tr></table></figure></p><p>注意，数值如何分配到这2行5列的矩阵中。我们还可以使用更简单的命令：<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; m&lt;-matrix(c(<span class="number">45</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">56</span>,<span class="number">12</span>,<span class="number">78</span>,<span class="number">23</span>),<span class="number">2</span>,<span class="number">5</span>)</span><br><span class="line">&gt; m</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>] [,<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,]   <span class="number">45</span>   <span class="number">66</span>   <span class="number">33</span>   <span class="number">56</span>   <span class="number">78</span></span><br><span class="line">[<span class="number">2</span>,]   <span class="number">23</span>   <span class="number">77</span>   <span class="number">44</span>   <span class="number">12</span>   <span class="number">23</span></span><br></pre></td></tr></table></figure></p><p>通过上面的这两个例子，我们注意到向量中的数据通过矩阵的列进行拓展。我们可以通过指定matrix的参数来指定向量以按行的方式进行拓展。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; m&lt;-m&lt;-matrix(c(<span class="number">45</span>,<span class="number">23</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">33</span>,<span class="number">44</span>,<span class="number">56</span>,<span class="number">12</span>,<span class="number">78</span>,<span class="number">23</span>),<span class="number">2</span>,<span class="number">5</span>,byrow = <span class="literal">T</span>)</span><br><span class="line">&gt; m</span><br><span class="line">     [,<span class="number">1</span>] [,<span class="number">2</span>] [,<span class="number">3</span>] [,<span class="number">4</span>] [,<span class="number">5</span>]</span><br><span class="line">[<span class="number">1</span>,]   <span class="number">45</span>   <span class="number">23</span>   <span class="number">66</span>   <span class="number">77</span>   <span class="number">33</span></span><br><span class="line">[<span class="number">2</span>,]   <span class="number">44</span>   <span class="number">56</span>   <span class="number">12</span>   <span class="number">78</span>   <span class="number">23</span></span><br></pre></td></tr></table></figure></p><p>如矩阵的显示，我们可以通过类似以向量中的索引的方式来访问矩阵的元素。但是现在需要两个索引，因为矩阵至少是二维的。<br><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; m[<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>] <span class="number">12</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      R简介像
    
    </summary>
    
      <category term="bigdata" scheme="http://www.wanqing520.cn/categories/bigdata/"/>
    
    
  </entry>
  
  <entry>
    <title>Neil | 牛中超--R使用北京的镜像</title>
    <link href="http://www.wanqing520.cn/201610/12/bigdata/2016-10-12-R-Using-China-Source.html"/>
    <id>http://www.wanqing520.cn/201610/12/bigdata/2016-10-12-R-Using-China-Source.html</id>
    <published>2016-10-12T06:03:14.000Z</published>
    <updated>2017-12-13T11:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&gt; chooseCRANmirror()</span><br><span class="line">HTTPS CRAN mirror</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span>: <span class="number">0</span>-Cloud [https]                   <span class="number">2</span>: Algeria [https]                   <span class="number">3</span>: Austria [https]</span><br><span class="line"> <span class="number">4</span>: Belgium (Ghent) [https]           <span class="number">5</span>: Brazil (SP <span class="number">1</span>) [https]             <span class="number">6</span>: Canada (MB) [https]</span><br><span class="line"> <span class="number">7</span>: Chile [https]                     <span class="number">8</span>: China (Beijing <span class="number">4</span>) [https]         <span class="number">9</span>: Colombia (Cali) [https]</span><br><span class="line"><span class="number">10</span>: France (Lyon <span class="number">1</span>) [https]          <span class="number">11</span>: France (Lyon <span class="number">2</span>) [https]          <span class="number">12</span>: France (Paris <span class="number">2</span>) [https]</span><br><span class="line"><span class="number">13</span>: Germany (Münster) [https]        <span class="number">14</span>: Iceland [https]                  <span class="number">15</span>: Italy (Padua) [https]</span><br><span class="line"><span class="number">16</span>: Japan (Tokyo) [https]            <span class="number">17</span>: Malaysia [https]                 <span class="number">18</span>: Mexico (Mexico City) [https]</span><br><span class="line"><span class="number">19</span>: New Zealand [https]              <span class="number">20</span>: Russia (Moscow) [https]          <span class="number">21</span>: Serbia [https]</span><br><span class="line"><span class="number">22</span>: Spain (A Coru&lt;U+00F1&gt;a) [https]  <span class="number">23</span>: Spain (Madrid) [https]           <span class="number">24</span>: Switzerland [https]</span><br><span class="line"><span class="number">25</span>: UK (Bristol) [https]             <span class="number">26</span>: UK (Cambridge) [https]           <span class="number">27</span>: USA (CA <span class="number">1</span>) [https]</span><br><span class="line"><span class="number">28</span>: USA (KS) [https]                 <span class="number">29</span>: USA (MI <span class="number">1</span>) [https]               <span class="number">30</span>: USA (TN) [https]</span><br><span class="line"><span class="number">31</span>: USA (TX) [https]                 <span class="number">32</span>: USA (WA) [https]                 <span class="number">33</span>: (HTTP mirrors)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Selection: <span class="number">33</span></span><br><span class="line">HTTP CRAN mirror</span><br><span class="line"></span><br><span class="line"> <span class="number">1</span>: <span class="number">0</span>-Cloud                       <span class="number">2</span>: Algeria                       <span class="number">3</span>: Argentina (La Plata)</span><br><span class="line"> <span class="number">4</span>: Australia (Canberra)          <span class="number">5</span>: Australia (Melbourne)         <span class="number">6</span>: Austria</span><br><span class="line"> <span class="number">7</span>: Belgium (Antwerp)             <span class="number">8</span>: Belgium (Ghent)               <span class="number">9</span>: Brazil (BA)</span><br><span class="line"><span class="number">10</span>: Brazil (PR)                  <span class="number">11</span>: Brazil (RJ)                  <span class="number">12</span>: Brazil (SP <span class="number">1</span>)</span><br><span class="line"><span class="number">13</span>: Brazil (SP <span class="number">2</span>)                <span class="number">14</span>: Bulgaria                     <span class="number">15</span>: Canada (BC)</span><br><span class="line"><span class="number">16</span>: Canada (MB)                  <span class="number">17</span>: Canada (NS)                  <span class="number">18</span>: Canada (ON)</span><br><span class="line"><span class="number">19</span>: Chile                        <span class="number">20</span>: China (Beijing <span class="number">4</span>)            <span class="number">21</span>: China (Xiamen)</span><br><span class="line"><span class="number">22</span>: Colombia (Cali)              <span class="number">23</span>: Czech Republic               <span class="number">24</span>: Ecuador</span><br><span class="line"><span class="number">25</span>: El Salvador                  <span class="number">26</span>: Estonia                      <span class="number">27</span>: France (Lyon <span class="number">2</span>)</span><br><span class="line"><span class="number">28</span>: France (Marseille)           <span class="number">29</span>: France (Montpellier)         <span class="number">30</span>: France (Paris <span class="number">2</span>)</span><br><span class="line"><span class="number">31</span>: Germany (G&lt;U+00F6&gt;ttingen)   <span class="number">32</span>: Germany (Münster)            <span class="number">33</span>: Greece</span><br><span class="line"><span class="number">34</span>: Hungary                      <span class="number">35</span>: Iceland                      <span class="number">36</span>: India</span><br><span class="line"><span class="number">37</span>: Indonesia (Jakarta)          <span class="number">38</span>: Iran                         <span class="number">39</span>: Ireland</span><br><span class="line"><span class="number">40</span>: Italy (Milano)               <span class="number">41</span>: Italy (Padua)                <span class="number">42</span>: Italy (Palermo)</span><br><span class="line"><span class="number">43</span>: Japan (Tokyo)                <span class="number">44</span>: Korea (Seoul <span class="number">1</span>)              <span class="number">45</span>: Korea (Seoul <span class="number">2</span>)</span><br><span class="line"><span class="number">46</span>: Korea (Ulsan)                <span class="number">47</span>: Lebanon                      <span class="number">48</span>: Malaysia</span><br><span class="line"><span class="number">49</span>: Mexico (Mexico City)         <span class="number">50</span>: Mexico (Texcoco)             <span class="number">51</span>: Netherlands (Amsterdam)</span><br><span class="line"><span class="number">52</span>: Netherlands (Utrecht)        <span class="number">53</span>: New Zealand                  <span class="number">54</span>: Norway</span><br><span class="line"><span class="number">55</span>: Philippines                  <span class="number">56</span>: Poland                       <span class="number">57</span>: Portugal (Lisbon)</span><br><span class="line"><span class="number">58</span>: Russia (Moscow)              <span class="number">59</span>: Singapore                    <span class="number">60</span>: South Africa (Cape Town)</span><br><span class="line"><span class="number">61</span>: South Africa (Johannesburg)  <span class="number">62</span>: Spain (A Coru&lt;U+00F1&gt;a)      <span class="number">63</span>: Spain (Madrid)</span><br><span class="line"><span class="number">64</span>: Sweden                       <span class="number">65</span>: Switzerland                  <span class="number">66</span>: Taiwan (Chungli)</span><br><span class="line"><span class="number">67</span>: Taiwan (Taipei)              <span class="number">68</span>: Thailand                     <span class="number">69</span>: Turkey (Denizli)</span><br><span class="line"><span class="number">70</span>: Turkey (Mersin)              <span class="number">71</span>: UK (Bristol)                 <span class="number">72</span>: UK (Cambridge)</span><br><span class="line"><span class="number">73</span>: UK (London <span class="number">1</span>)                <span class="number">74</span>: UK (London <span class="number">2</span>)                <span class="number">75</span>: UK (St Andrews)</span><br><span class="line"><span class="number">76</span>: USA (CA <span class="number">1</span>)                   <span class="number">77</span>: USA (CA <span class="number">2</span>)                   <span class="number">78</span>: USA (IA)</span><br><span class="line"><span class="number">79</span>: USA (IN)                     <span class="number">80</span>: USA (KS)                     <span class="number">81</span>: USA (MI <span class="number">1</span>)</span><br><span class="line"><span class="number">82</span>: USA (MO)                     <span class="number">83</span>: USA (NC)                     <span class="number">84</span>: USA (OH <span class="number">1</span>)</span><br><span class="line"><span class="number">85</span>: USA (OH <span class="number">2</span>)                   <span class="number">86</span>: USA (OR)                     <span class="number">87</span>: USA (PA <span class="number">1</span>)</span><br><span class="line"><span class="number">88</span>: USA (PA <span class="number">2</span>)                   <span class="number">89</span>: USA (TN)                     <span class="number">90</span>: USA (TX)</span><br><span class="line"><span class="number">91</span>: USA (WA)                     <span class="number">92</span>: Venezuela</span><br><span class="line"></span><br><span class="line">Selection: <span class="number">20</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      R使用北京的镜像
    
    </summary>
    
      <category term="bigdata" scheme="http://www.wanqing520.cn/categories/bigdata/"/>
    
    
  </entry>
  
  <entry>
    <title>Neil | 牛中超--易企秀如何开启伪静态支持？ 一秀如何开启伪静态</title>
    <link href="http://www.wanqing520.cn/201610/12/php/2016-10-12-yiqixiu-use-php-rewrite.html"/>
    <id>http://www.wanqing520.cn/201610/12/php/2016-10-12-yiqixiu-use-php-rewrite.html</id>
    <published>2016-10-12T06:03:14.000Z</published>
    <updated>2017-12-13T11:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h1><p>易企秀如何开启伪静态支持？ 一秀如何开启伪静态？</p><h1 id="下载易企秀源码"><a href="#下载易企秀源码" class="headerlink" title="下载易企秀源码"></a>下载易企秀源码</h1><p>oschina:  <a href="http://git.oschina.net/jsper/html5Editor" target="_blank" rel="noopener">http://git.oschina.net/jsper/html5Editor</a></p><h1 id="Windows下搭建环境"><a href="#Windows下搭建环境" class="headerlink" title="Windows下搭建环境"></a>Windows下搭建环境</h1><ol><li>安卓phpstudy</li><li>导入数据库<br>数据库文件是：<code>ewesambo.sql</code></li><li><p>修改html5Editor项目下的配置文件：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20161004123214631" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure><p>修改systemConfig.php的内容，数据库地址，数据库库名，用户名和密码</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://img.blog.csdn.net/20161004123307772" alt="这里写图片描述" title="">                </div>                <div class="image-caption">这里写图片描述</div>            </figure></li><li><p>在html5Editor根目录下编写重定向文件.htaccess文件，文件内容如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;IfModule mod_rewrite.c&gt;</span></span><br><span class="line">  <span class="attribute"><span class="nomarkup">Options</span></span> +FollowSymlinks</span><br><span class="line">  <span class="attribute"><span class="nomarkup">RewriteEngine</span></span> <span class="literal">On</span></span><br><span class="line"></span><br><span class="line">  <span class="attribute"><span class="nomarkup">RewriteCond</span></span> <span class="variable">%&#123;REQUEST_FILENAME&#125;</span> !-d</span><br><span class="line">  <span class="attribute"><span class="nomarkup">RewriteCond</span></span> <span class="variable">%&#123;REQUEST_FILENAME&#125;</span> !-f</span><br><span class="line">  <span class="attribute"><span class="nomarkup">RewriteRule</span></span> ^(.*)$ index.php/<span class="number">$1</span><span class="meta"> [QSA,PT,L]</span></span><br><span class="line"><span class="section">&lt;/IfModule&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动phpstudy的mysql和apache服务器就可访问了</p></li></ol><h1 id="linux下的nginx配置"><a href="#linux下的nginx配置" class="headerlink" title="linux下的nginx配置"></a>linux下的nginx配置</h1><ol><li>安装mysql +nginx +mysql-php 等环境，具体的自行百度。</li><li>将项目放置在www目录或者html目录下</li><li><p>编辑/usr/local/nginx/conf/nginx.conf文件<br>示例如下：注意，下面的示例是针对外网访问的，如果是本地测试的话，请修改localhost的server配置</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    <span class="keyword">listen</span>       <span class="number">80</span>;</span><br><span class="line">    server_name wanqi52<span class="number">0</span>.cn; <span class="comment"># 这里换成你自己的域名</span></span><br><span class="line"><span class="comment"># 下面的if语句是为了支持thinkphp的重定向，URL_MODE使用的是2</span></span><br><span class="line"><span class="keyword">if</span> (!-e $request_filename) &#123;</span><br><span class="line">rewrite  ^(.*)$  /index.php?<span class="keyword">s</span>=$1  <span class="keyword">last</span>;</span><br><span class="line"><span class="keyword">break</span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#if</span></span><br><span class="line"><span class="comment"># 下面的语句制定html5Editor的根目录</span></span><br><span class="line">    root   /usr/<span class="keyword">local</span>/nginx/html;</span><br><span class="line">    <span class="keyword">index</span> index.php;</span><br><span class="line">    charset utf-<span class="number">8</span>;</span><br><span class="line">        <span class="comment">#include /usr/local/nginx/html/.htaccess;</span></span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">    fastcgi_index  index.php;</span><br><span class="line"><span class="comment">#fastcgi_pass unix:/var/run/php5-fpm.sock;</span></span><br><span class="line">    fastcgi_pass   <span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9000</span>;</span><br><span class="line">    fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ <span class="regexp">/phpmyadmin &#123;</span></span><br><span class="line"><span class="regexp">    root /data</span><span class="regexp">/www/phpmyadmin</span>;</span><br><span class="line">    <span class="keyword">index</span> index.php;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ <span class="regexp">/phpmyadmin/</span>.+\.php$ &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ($fastcgi_script_name ~ <span class="regexp">/phpmyadmin/</span>(.+\.php.*)$) &#123;</span><br><span class="line">    set $valid_fastcgi_script_name $1;</span><br><span class="line">    &#125;</span><br><span class="line">    include fastcgi_params;</span><br><span class="line">    fastcgi_pass   <span class="number">127.0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">9000</span>;</span><br><span class="line">    fastcgi_param SCRIPT_FILENAME /data/www/phpmyadmin/$valid_fastcgi_script_name;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>同样的需要更改systemConfig.php文件，以及导入数据库。</p></li><li>这样就应该可以访问了</li></ol>]]></content>
    
    <summary type="html">
    
      易企秀如何开启伪静态支持？ 一秀如何开启伪静态？
    
    </summary>
    
      <category term="php" scheme="http://www.wanqing520.cn/categories/php/"/>
    
    
  </entry>
  
  <entry>
    <title>Neil | 牛中超--Pseudo-class（伪类）、Pseudo-Element（伪元素）简要记录</title>
    <link href="http://www.wanqing520.cn/201605/03/java/2016-4-29-Pseudo-class-Pseudo-Element.html"/>
    <id>http://www.wanqing520.cn/201605/03/java/2016-4-29-Pseudo-class-Pseudo-Element.html</id>
    <published>2016-05-03T08:47:14.000Z</published>
    <updated>2017-12-13T11:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>伪类、伪元素配合CSS3可以完成非常多有意思的效果，为方便个人开发时候的快速查阅，记录了以下常用到的一些伪类伪元素的简要中文说明；</p><p>简单区分：</p><pre><code>:Pseudo-classes        伪类:DOM在不同状态、不同位置下的特殊效果；::Pseudo-elements    伪元素：DOM按匹配规则伪造出的元素；</code></pre><h4 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h4><ul><li>伪类添加的内容元素或伪类效果通在DOM的源代码中是看不见的，需要借助开发者工具才能看见;</li><li>使用屏幕阅读器等设备无法访问和读取伪元素生成的内容。因此不应该使用伪元素来添加正文内容等重要信息到页面上展示，应确保主体内容的完整性。</li><li>伪类添加的元素也可以使用CSS样式进行控制,具体查看下面浏览器的兼容性；</li><li>content方式可以添加的图片、unicode、字符串；其中图片不能调整大小，要选择合适的图片;</li><li>伪元素是在DOM内容生成之后添加的，它将被堆积在DOM的父元素的顶上；</li><li>伪元素由双冒号和伪元素名称组成，为了兼容使用单冒号的伪类也有效；</li><li>伪类添加的内容和元素不能使用任何Javascript的事件处理程序；</li><li>js获取伪类的值：win.getComputedStyle(doc.querySelector(‘.element’), ‘:before’).getPropertyValue(‘color’)</li></ul><h4 id="Browser-Support"><a href="#Browser-Support" class="headerlink" title="Browser Support"></a>Browser Support</h4><ul><li>具体浏览器兼容性可以使用 <a href="http://caniuse.com/#search=CSS3" target="_blank" rel="noopener">Can I Use</a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS" target="_blank" rel="noopener">MDN CSS Browser Support</a></li></ul><h4 id="常用伪元素、伪类列表"><a href="#常用伪元素、伪类列表" class="headerlink" title="常用伪元素、伪类列表"></a>常用伪元素、伪类列表</h4><pre><code>::after         在元素的内容之后::before          在元素的内容之前::first-line     元素的第一行::first-letter     元素的第一个字母::placeholder    占位符，用于input输入框之类的提醒::selection     被选取的元素，用于改变网页被选中部分的效果:active         当元素被点击的时:blank          空白的元素:checked          被选中的元素:default         默认被选中或默认会被提交的元素:dir()             匹配特定文字书写方向的元素:disabled        处于被禁止操作状态的元素:empty             没有任何内容的元素:enabled         处于可操作状态的元素:first             用于打印文档的第一页:first-child     父级元素下的第一个子元素:first-of-type     父级元素下的第一个同类子元素:focus             当元素成为焦点:fullscreen        当元素被HTML5 API调用RequestFullscreen方式全屏时:hover             当鼠标移动到链接元素上面时:in-range        当元素属性值处于其指定的范围内时:indeterminate    当元素属性值处于不确定状态的:invalid        当元素属性值不是指定的type属性时:lang()          匹配有正确lang 属性值的元素，如 lang(zh-Hans):last-child        元素的最后一个子元素:last-of-type     元素的最后一个同类子元素:left            选择打印文档的左侧页:link             未被访问的链接元素:not()             否定选择器（不匹配条件则生效）:nth-child()     元素的一个或多个特定的子元素:nth-last-child() 元素的一个或多个特定的子元素，从该元素的最后一个子元素开始算；:nth-of-type()     选择指定的元素:nth-last-of-type()    选择指定的元素，从元素的最后一个开始计算:only-child        元素是它的父元素的唯一子元素:only-of-type     元素是它的父级元素的唯一一个相同类型的子元素:optional        未指定required属性的表单元素:out-of-range    超出规定值范围的元素:read-only        元素设置了 &apos;readonly&apos; 属性生效:read-write        元素没有 &quot;readonly&quot; 属性生效:required        设置了 &quot;required&quot; 属性的元素:right            选择打印文档的左侧页:root             文档的根元素:scope            作用域的伪类，默认为HTML（案例 :scope #mammma {...}）:target         当前活动的元素（匹配页面URI中对应的目标元素）:valid             表示有效的元素:visited         已被访问过的元素 content        在元素之前或之后添加的内容。</code></pre><h3 id="Related-Entries"><a href="#Related-Entries" class="headerlink" title="Related Entries"></a>Related Entries</h3><ul><li><a href="http://www.w3.org/TR/2005/WD-css3-selectors-20051215/#pseudo-elements" target="_blank" rel="noopener">Pseudo-elements</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/DOM/Using_fullscreen_mode" target="_blank" rel="noopener">Fullscreen API </a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/:scope" target="_blank" rel="noopener">:scope</a></li></ul>]]></content>
    
    <summary type="html">
    
      Pseudo-class（伪类）、Pseudo-Element（伪元素）简要记录和使用说明
    
    </summary>
    
      <category term="java" scheme="http://www.wanqing520.cn/categories/java/"/>
    
    
  </entry>
  
  <entry>
    <title>Neil | 牛中超--Git 简单使用说明</title>
    <link href="http://www.wanqing520.cn/201512/14/git/2015-12-14-instruction-Git.html"/>
    <id>http://www.wanqing520.cn/201512/14/git/2015-12-14-instruction-Git.html</id>
    <published>2015-12-13T16:47:14.000Z</published>
    <updated>2017-12-13T11:08:20.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code>/*Name:  UED Git 简单使用说明Author:markyunCreate Date:2014-10-18*/</code></pre><p>1安装msysgit：</p><p>msysgit是Windows版的Git，从<a href="http://msysgit.github.io/下载，然后按默认选项安装即可。" target="_blank" rel="noopener">http://msysgit.github.io/下载，然后按默认选项安装即可。</a></p><p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><p>2 配置用户名：</p><pre><code>git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot;</code></pre><p>3、创建仓库（或者 克隆一个远程仓库 ）：</p><pre><code>git initInitialized empty Git repository in /Users/michael/learngit/.git/ （告诉你是一个空的仓库）</code></pre><p>请确保目录名（包括父目录）不包含中文</p><p>4、添加文件到仓库：</p><p>把文件（readme.txt）放在创建的仓库内</p><pre><code>git add readme.txt  //可反复多次使用，</code></pre><p>添加多个文件；</p><pre><code>git add .</code></pre><p>（.）点表示当前目录下的所有内容，交给git管理，也就是提交到了git的本地仓库。<br>用命令git commit告诉Git，把文件提交到仓库：</p><pre><code>git commit -m &quot;Update README.md, add the front-end interview questions &quot;[master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt</code></pre><p>5、修改文件后，更新仓库</p><pre><code>git status   查看仓库当前的状态， 告诉我们，什么文件被修改过了，但还没有准备提交的修改。git diff  文件名，  查看具体修改了什么内容git add 文件名    更新和添加一样git commit</code></pre><p>6、版本回退：</p><p>先 git log 添加的注释</p><p>也可以：git reflog 记录你的每一次添加命令和注释 和commit_id：</p><p>只回到上一个版本就是HEAD^，</p><pre><code>git reset --hard HEAD^</code></pre><p>上上一个版本就是HEAD^^ git reset –hard HEAD^^</p><pre><code>git reset --hard commit_id。</code></pre><p>7、暂存区</p><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。<br>第一次修改 -&gt; add -&gt; 第二次修改 -&gt; add -&gt; commit</p><p>只会提交第一次的修改内容到主分支</p><p>8、撤销提交操作（add）</p><pre><code>git checkout -- readme.txt   //（--很重要，没有--，就变成了“创建一个新分支”的命令）</code></pre><p>把readme.txt文件在工作区的修改全部撤销，这里有两种情况：<br>当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令</p><pre><code>git checkout -- file</code></pre><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；<br>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，</p><p>第一步用命令git reset HEAD file，就回到了场景1，第二步按场景1操作</p><p>二是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到【最近一次git commit后】 或【git add之前】的状态；</p><p>假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？ 可以回退到上一个版本。<br>不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。</p><p>9、删除文件</p><pre><code>git rm test.txtrm &apos;test.txt&apos;m &quot;remove test.txt&quot;git commit-//如果删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：git checkout -- test.txt</code></pre><p>10、设置SSH Key</p><p>由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要SSH Key</p><p>默认存放在 C:\Users\Administrator.ssh   id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。</p><pre><code>ssh-keygen -t rsa -C “mygood@126.com&quot;</code></pre><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，<br>而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><p>11、绑定到远程仓库  （注意格式的gitlab，不支持ssh，请使用http）</p><pre><code>关联一个远程库   git remote add origin git@github.com:markyun/beilibao.git远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。</code></pre><p>12、推送到远程仓库</p><pre><code>git remote -v //查看你当前项目远程连接的是哪个仓库地址。git push -u origin master //将本地的项目提交到远程仓库中。</code></pre><p>正常情况下这样显示：</p><pre><code>git push -u origin masterCounting objects: 19, done.o 4 threads.Compressing objects: 100% (Delta compression using upt19/19), done.Writing objects: 100% (19/19), 13.73 KiB, done.lliao/learngit.git * [new branch]Total 23 (delta 6), reused 0 (delta 0)To git@github.com:michae  master -&gt; master to track remote branch master from origin.Branch master set up</code></pre><p>如果提示：</p><pre><code>ssh:connect to host github.com port 22:bad file number could not read from remote repository</code></pre><p>（说不能读取远端库，请确保有正确的访问权限并且仓库存在。看看你本机22端口有没有打开）</p><pre><code>ssh github.com 测试是否能正常使用SSH</code></pre><p>当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告：</p><pre><code>The authenticity of host &apos;github.com (xx.xx.xx.xx)&apos; can&apos;t be established.RSA key fingerprint is xx.xx.xx.xx.xx.cting (yes/no)?Are you sure you want to continue conne</code></pre><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。<br>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><pre><code>Warning: Permanently added &apos;github.com&apos; (RSA) to the list of known hosts.</code></pre><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><p>13、从服务器上把一个远程仓库中的工程完全的拷贝下来</p><pre><code>git clone git@github.com:china-UED/test.git假如本地已经存在了这个项目，而仓库中又有一新的更新，如何把更的合并到本地的项目中？git fetch origin    //取得远程更新，这里可以看做是准备要取了git merge origin/master  //把更新的内容合并到本地分支/master</code></pre><p>—————-待补充————–</p><p>14、创建与合并分支</p><p>15、冲突的处理</p><p>16、多人协作</p><p>17、其他</p><pre><code>git config --list 查看配置git config --global core.autocrlf false  关闭 github的换行符自动转换”功能</code></pre><p>补充 Git 命令快速查询表</p><pre><code>命令        简要说明git add    添加至暂存区git add–interactive    交互式添加git apply    应用补丁git am    应用邮件格式补丁git annotate    同义词，等同于 git blamegit archive    文件归档打包git bisect    二分查找git blame    文件逐行追溯git branch    分支管理git cat-file    版本库对象研究工具git checkout    检出到工作区、切换或创建分支git cherry-pick    提交拣选git citool    图形化提交，相当于 git gui 命令git clean    清除工作区未跟踪文件git clone    克隆版本库git commit    提交git config    查询和修改配置git describe    通过里程碑直观地显示提交IDgit diff    差异比较git difftool    调用图形化差异比较工具git fetch    获取远程版本库的提交git format-patch    创建邮件格式的补丁文件。参见 git am 命令git grep    文件内容搜索定位工具git gui    基于Tcl/Tk的图形化工具，侧重提交等操作git help    帮助git init    版本库初始化git init-db*    同义词，等同于 git initgit log    显示提交日志git merge    分支合并git mergetool    图形化冲突解决git mv    重命名git pull    拉回远程版本库的提交git push    推送至远程版本库git reBase    分支变基git rebase–interactive    交互式分支变基git reflog    分支等引用变更记录管理git remote    远程版本库管理git repo-config*    同义词，等同于 git configgit reset    重置改变分支“游标”指向git rev-parse    将各种引用表示法转换为哈希值等git revert    反转提交git rm    删除文件git show    显示各种类型的对象git stage*    同义词，等同于 git addgit stash    保存和恢复进度git status    显示工作区文件状态git tag    里程碑管理</code></pre><p>2、对象库操作相关命令</p><pre><code>命令    简要说明git commit-tree    从树对象创建提交git hash-object    从标准输入或文件计算哈希值或创建对象git ls-files    显示工作区和暂存区文件git ls-tree    显示树对象包含的文件git mktag    读取标准输入创建一个里程碑对象git mktree    读取标准输入创建一个树对象git read-tree    读取树对象到暂存区git update-index    工作区内容注册到暂存区及暂存区管理git unpack-file    创建临时文件包含指定 blob 的内容git write-tree    从暂存区创建一个树对象</code></pre><p>3、引用操作相关命令</p><pre><code>命令    简要说明git check-ref-format    检查引用名称是否符合规范git for-each-ref    引用迭代器，用于shell编程git ls-remote    显示远程版本库的引用git name-rev    将提交ID显示为友好名称git peek-remote*    过时命令，请使用 git ls-remotegit rev-list    显示版本范围git show-branch    显示分支列表及拓扑关系git show-ref    显示本地引用git symbolic-ref    显示或者设置符号引用git update-ref    更新引用的指向git verify-tag    校验 GPG 签名的Tag</code></pre><p>4、版本库管理相关命令</p><pre><code>命令    简要说明git count-objects    显示松散对象的数量和磁盘占用git filter-branch    版本库重构git fsck    对象库完整性检查git fsck-objects*    同义词，等同于 git fsckgit gc    版本库存储优化git index-pack    从打包文件创建对应的索引文件git lost-found*    过时，请使用 git fsck –lost-found 命令git pack-objects    从标准输入读入对象ID，打包到文件git pack-redundant    查找多余的 pack 文件git pack-refs    将引用打包到 .git/packed-refs 文件中git prune    从对象库删除过期对象git prune-packed    将已经打包的松散对象删除git relink    为本地版本库中相同的对象建立硬连接git repack    将版本库未打包的松散对象打包git show-index    读取包的索引文件，显示打包文件中的内容git unpack-objects    从打包文件释放文件git verify-pack    校验对象库打包文件</code></pre><p>5、数据传输相关命令</p><pre><code>命令    简要说明git fetch-pack    执行 git fetch 或 git pull 命令时在本地执行此命令，用于从其他版本库获取缺失的对象git receive-pack    执行 git push 命令时在远程执行的命令，用于接受推送的数据git send-pack    执行 git push 命令时在本地执行的命令，用于向其他版本库推送数据git upload-archive    执行 git archive –remote 命令基于远程版本库创建归档时，远程版本库执行此命令传送归档git upload-pack    执行 git fetch 或 git pull 命令时在远程执行此命令，将对象打包、上传</code></pre><p>6、邮件相关命令</p><pre><code>命令    简要说明git imap-send    将补丁通过 IMAP 发送git mailinfo    从邮件导出提交说明和补丁git mailsplit    将 mbox 或 Maildir 格式邮箱中邮件逐一提取为文件git request-pull    创建包含提交间差异和执行PULL操作地址的信息git send-email    发送邮件</code></pre><p>7、协议相关命令</p><pre><code>命令    简要说明git daemon    实现Git协议git http-backend    实现HTTP协议的CGI程序，支持智能HTTP协议git instaweb    即时启动浏览器通过 gitweb 浏览当前版本库git shell    受限制的shell，提供仅执行Git命令的SSH访问git update-server-info    更新哑协议需要的辅助文件git http-fetch    通过HTTP协议获取版本库git http-push    通过HTTP/DAV协议推送git remote-ext    由Git命令调用，通过外部命令提供扩展协议支持git remote-fd    由Git命令调用，使用文件描述符作为协议接口git remote-ftp    由Git命令调用，提供对FTP协议的支持git remote-ftps    由Git命令调用，提供对FTPS协议的支持git remote-http    由Git命令调用，提供对HTTP协议的支持git remote-https    由Git命令调用，提供对HTTPS协议的支持git remote-testgit    协议扩展示例脚本</code></pre><p>8、版本库转换和交互相关命令</p><pre><code>命令    简要说明git archimport    导入Arch版本库到Gitgit bundle    提交打包和解包，以便在不同版本库间传递git cvsexportcommit    将Git的一个提交作为一个CVS检出git cvsimport    导入CVS版本库到Git。或者使用 cvs2gitgit cvsserver    Git的CVS协议模拟器，可供CVS命令访问Git版本库git fast-export    将提交导出为 git-fast-import 格式git fast-import    其他版本库迁移至Git的通用工具git svn    Git 作为前端操作 Subversion</code></pre><p>9、合并相关的辅助命令</p><pre><code>命令    简要说明git merge-base    供其他脚本调用，找到两个或多个提交最近的共同祖先git merge-file    针对文件的两个不同版本执行三向文件合并git merge-index    对index中的冲突文件调用指定的冲突解决工具git merge-octopus    合并两个以上分支。参见 git merge 的octopus合并策略git merge-one-file    由 git merge-index 调用的标准辅助程序git merge-ours    合并使用本地版本，抛弃他人版本。参见 git merge 的ours合并策略git merge-recursive    针对两个分支的三向合并。参见 git merge 的recursive合并策略git merge-resolve    针对两个分支的三向合并。参见 git merge 的resolve合并策略git merge-subtree    子树合并。参见 git merge 的 subtree 合并策略git merge-tree    显式三向合并结果，不改变暂存区git fmt-merge-msg    供执行合并操作的脚本调用，用于创建一个合并提交说明git rerere    重用所记录的冲突解决方案</code></pre><p>10、 杂项</p><pre><code>命令    简要说明git bisect–helper    由 git bisect 命令调用，确认二分查找进度git check-attr    显示某个文件是否设置了某个属性git checkout-index    从暂存区拷贝文件至工作区git cherry    查找没有合并到上游的提交git diff-files    比较暂存区和工作区，相当于 git diff –rawgit diff-index    比较暂存区和版本库，相当于 git diff –cached –rawgit diff-tree    比较两个树对象，相当于 git diff –raw A Bgit difftool–helper    由 git difftool 命令调用，默认要使用的差异比较工具git get-tar-commit-id    从 git archive 创建的 tar 包中提取提交IDgit gui–askpass    命令 git gui 的获取用户口令输入界面git notes    提交评论管理git patch-id    补丁过滤行号和空白字符后生成补丁唯一IDgit quiltimport    将Quilt补丁列表应用到当前分支git replace    提交替换git shortlog    对 git log 的汇总输出，适合于产品发布说明git stripspace    删除空行，供其他脚本调用git submodule    子模组管理git tar-tree    过时命令，请使用 git archivegit var    显示 Git 环境变量git web–browse    启动浏览器以查看目录或文件git whatchanged    显示提交历史及每次提交的改动git-mergetool–lib    包含于其他脚本中，提供合并/差异比较工具的选择和执行git-parse-remote    包含于其他脚本中，提供操作远程版本库的函数git-sh-setup    包含于其他脚本中，提供 shell 编程的函数库</code></pre><p><a href="http://www.bootcss.com/p/git-guide/" title="git-guide" target="_blank" rel="noopener">git-guide </a></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/markyun/markyun.github.io/master/assets/images/Nanjing2.jpg" alt="南京" title="">                </div>                <div class="image-caption">南京</div>            </figure>]]></content>
    
    <summary type="html">
    
      Git 简单使用说明
    
    </summary>
    
      <category term="git" scheme="http://www.wanqing520.cn/categories/git/"/>
    
    
  </entry>
  
</feed>
